<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>我是ajian</title>
    <link>http://yoursite.com/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>选择的方向优胜于谋略的策略，方法比努力更有价值</description>
    <pubDate>Fri, 31 Jul 2020 07:34:35 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>leetCode-no-88</title>
      <link>http://yoursite.com/2020/07/31/leetCode-no-88/</link>
      <guid>http://yoursite.com/2020/07/31/leetCode-no-88/</guid>
      <pubDate>Fri, 31 Jul 2020 07:21:47 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化 nums1 和 nums2 的元素数量分别为 m 和 n&lt;/li&gt;
&lt;li&gt;你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p><p>说明：</p><ul><li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n</li><li>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<a id="more"></a></li></ul><p>示例：<br>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6], n = 3<br>输出:<br>[1,2,2,3,5,6]</p><p>思路：</p><ol><li>利用插入排序的思想，将nums1看成有序序列，nums2看成无序序列；</li><li>逐个将nums2中的元素插入nums1数组中；</li></ol><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：1 ms, 在所有 Java 提交中击败了23.39%的用户</span></span><br><span class="line"><span class="comment">内存消耗：39.7 MB, 在所有 Java 提交中击败了80.87%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode_no_88</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//insertIndex插入位置下标；insertValue待插入元素</span></span><br><span class="line">        <span class="keyword">int</span> insertIndex,insertValue;</span><br><span class="line">        <span class="comment">//遍历待插入数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//顺序获得待插入insertValue</span></span><br><span class="line">            insertValue=nums2[i];</span><br><span class="line">            <span class="comment">//有序数组nums1不断增大，故待插入下标开始的值也要递增</span></span><br><span class="line">            insertIndex=m+i-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//寻找待插入位置</span></span><br><span class="line">            <span class="keyword">while</span>(insertIndex&gt;=<span class="number">0</span>&amp;&amp;insertValue&lt;nums1[insertIndex]) insertIndex--;</span><br><span class="line">            <span class="comment">//给待插入位置元素腾开位置，即后移待插入位置后面的元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m+i;j&gt;insertIndex+<span class="number">1</span>;j--) nums1[j]=nums1[j-<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//插入元素</span></span><br><span class="line">            nums1[insertIndex+<span class="number">1</span>]=insertValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=<span class="number">3</span>,n=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span>[] nums1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] nums2=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        merge4(nums1, m, nums2, n);</span><br><span class="line">        System.out.println(Arrays.toString(nums1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：<br>时间复杂度较大，效率不高<br>时间复杂度 : O(n * m)。<br>空间复杂度 : O(m + n)。</p><h4 id="官方Java代码实现一"><a href="#官方Java代码实现一" class="headerlink" title="官方Java代码实现一"></a>官方Java代码实现一</h4><p><strong>双指针 / 从前往后</strong><br>一般而言，对于有序数组可以通过 双指针法 达到O(n + m)的时间复杂度。<br>最直接的算法实现是将指针p1 置为 nums1的开头， p2为 nums2的开头，在每一步将最小值放入输出数组中。<br>由于 nums1 是用于输出的数组，需要将nums1中的前m个元素放在其他地方，也就需要 O(m)的空间复杂度。<br><img data-src="/images/leetcode_img/leetCode_No_88/method1.png" alt="解答一图例"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge3</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将nums1数组复制到一个新的数组空间nums1Copy</span></span><br><span class="line">    <span class="keyword">int</span>[] nums1Copy=<span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    System.arraycopy(nums1, <span class="number">0</span>, nums1Copy, <span class="number">0</span>,m);</span><br><span class="line">    <span class="comment">//定义分别指向三个数组的指针p1指向nums1Copy,p2指向nums2,p指向nums1</span></span><br><span class="line">    <span class="keyword">int</span> p1=<span class="number">0</span>,p2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1&lt;m&amp;&amp;p2&lt;n) nums1[p++]=nums1Copy[p1]&lt;nums2[p2]?nums1Copy[p1++]:nums2[p2++];</span><br><span class="line">    <span class="comment">//排除一个数组全部数值比另外一个数组的全部数值小的情况</span></span><br><span class="line">    <span class="keyword">if</span>(p1&lt;m) System.arraycopy(nums1Copy, p1, nums1, p1+p2, m+n-p1-p2);</span><br><span class="line">    <span class="keyword">if</span>(p2&lt;n) System.arraycopy(nums2, p2,nums1, p1+p2, m+n-p1-p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetcode/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>时间复杂度 : O(n + m)。<br>空间复杂度 : O(m)</p><h4 id="官方Java代码实现二"><a href="#官方Java代码实现二" class="headerlink" title="官方Java代码实现二"></a>官方Java代码实现二</h4><p><strong>双指针 / 从后往前</strong><br>已经取得了最优的时间复杂度O(n + m)，但需要使用额外空间。这是由于在从头改变nums1的值时，需要把nums1中的元素存放在其他位置<br>如果我们从结尾开始改写 nums1 的值又会如何呢？这里没有信息，因此不需要额外空间。<br><img data-src="/images/leetcode_img/leetCode_No_88/method2.png" alt="解答二图例"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge4</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1=m-<span class="number">1</span>,p2=n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p=nums1.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1&gt;=<span class="number">0</span>&amp;&amp;p2&gt;=<span class="number">0</span>) nums1[p--]=nums1[p1]&gt;nums2[p2]?nums1[p1--]:nums2[p2--];</span><br><span class="line">    System.arraycopy(nums2, <span class="number">0</span>, nums1, <span class="number">0</span>, p2+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetcode/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>时间复杂度 : O(n + m)<br>空间复杂度 : O(1)</p><h3 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行用时：20 ms, 在所有 Python 提交中击败了73.83%的用户</span></span><br><span class="line"><span class="string">内存消耗：12.6 MB, 在所有 Python 提交中击败了82.05%的用户</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">:type nums1: List[int]</span></span><br><span class="line"><span class="string">:type m: int</span></span><br><span class="line"><span class="string">:type nums2: List[int]</span></span><br><span class="line"><span class="string">:type n: int</span></span><br><span class="line"><span class="string">:rtype: None Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        insertIndex,insertValue=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums2)):</span><br><span class="line">            insertValue=nums2[i]</span><br><span class="line">            insertIndex=m<span class="number">-1</span>+i</span><br><span class="line">            <span class="keyword">while</span> insertIndex&gt;=<span class="number">0</span> <span class="keyword">and</span> insertValue&lt;nums1[insertIndex]:</span><br><span class="line">                insertIndex-=<span class="number">1</span></span><br><span class="line">            j=m+i</span><br><span class="line">            <span class="keyword">while</span> j&gt;insertIndex+<span class="number">1</span>:</span><br><span class="line">                nums1[j]=nums1[j<span class="number">-1</span>]</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            nums1[insertIndex+<span class="number">1</span>]=insertValue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s=Solution()</span><br><span class="line">nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">m = <span class="number">3</span></span><br><span class="line">nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">s.merge(nums1,m,nums2,n)</span><br><span class="line">print(nums1)</span><br></pre></td></tr></table></figure><h4 id="官方Python代码实现"><a href="#官方Python代码实现" class="headerlink" title="官方Python代码实现"></a>官方Python代码实现</h4><p><strong>双指针 / 从后往前</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># two get pointers for nums1 and nums2</span></span><br><span class="line">        p1 = m - <span class="number">1</span></span><br><span class="line">        p2 = n - <span class="number">1</span></span><br><span class="line">        <span class="comment"># set pointer for nums1</span></span><br><span class="line">        p = m + n - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># while there are still elements to compare</span></span><br><span class="line">        <span class="keyword">while</span> p1 &gt;= <span class="number">0</span> <span class="keyword">and</span> p2 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[p1] &lt; nums2[p2]:</span><br><span class="line">                nums1[p] = nums2[p2]</span><br><span class="line">                p2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[p] =  nums1[p1]</span><br><span class="line">                p1 -= <span class="number">1</span></span><br><span class="line">            p -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># add missing elements from nums2</span></span><br><span class="line">        nums1[:p2 + <span class="number">1</span>] = nums2[:p2 + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">作者：LeetCode</span></span><br><span class="line"><span class="string">链接：https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetcode/</span></span><br><span class="line"><span class="string">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="string">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/31/leetCode-no-88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>leetCode-no-26</title>
      <link>http://yoursite.com/2020/07/31/leetCode-no-26/</link>
      <guid>http://yoursite.com/2020/07/31/leetCode-no-26/</guid>
      <pubDate>Thu, 30 Jul 2020 17:29:54 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&lt;br&gt;不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><a id="more"></a><p>给定数组 nums = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。</p><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素。</p><p>思路：</p><ol><li>首先判断数组长度等于1或者等于0的情况</li><li>从数组第1位开始遍历数组，如果数组当前索引的前一位与当前数值不相等，则nums[++newArrayIndex]=nums[i];</li><li>不断重复步骤2，最后返回newArrayIndex+1即新数组的长度。</li></ol><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：1 ms, 在所有 Java 提交中击败了98.21%的用户</span></span><br><span class="line"><span class="comment">内存消耗：41.8 MB, 在所有 Java 提交中击败了22.09%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">leetcode_no_26</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//newArrayLen表示新数组长度</span></span><br><span class="line">        <span class="comment">//newArrayIndex表示新数组下标</span></span><br><span class="line">        <span class="keyword">int</span> newArrayLen=<span class="number">1</span>,newArrayIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断数组小于或等于0的情况</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//筛除重复数据，得到不重复数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i-<span class="number">1</span>]!=nums[i])&#123;</span><br><span class="line">                nums[++newArrayIndex]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newArrayLen=newArrayIndex+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> newArrayLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> result=removeDuplicates(nums);</span><br><span class="line">        System.out.println(<span class="string">"The new array's length is :"</span>+result);</span><br><span class="line">        System.out.println(<span class="string">"The new array is :"</span>+Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行用时：32 ms, 在所有 Python 提交中击败了61.68%的用户</span></span><br><span class="line"><span class="string">内存消耗：14.6 MB, 在所有 Python 提交中击败了5.88%的用户</span></span><br><span class="line"><span class="string">:type nums: List[int]</span></span><br><span class="line"><span class="string">:rtype: int</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        newArrayLen,newArrayIndex=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i<span class="number">-1</span>]!=nums[i]:</span><br><span class="line">                newArrayIndex+=<span class="number">1</span></span><br><span class="line">                nums[newArrayIndex]=nums[i]</span><br><span class="line">        newArrayLen=newArrayIndex+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> newArrayLen</span><br><span class="line">nums=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">s=Solution()</span><br><span class="line">result=s.removeDuplicates(nums)</span><br><span class="line">print(<span class="string">"The new Array's length is :&#123;&#125; and the new Array is : &#123;&#125;"</span>.format(result,nums))</span><br></pre></td></tr></table></figure><h3 id="官方Java代码解答"><a href="#官方Java代码解答" class="headerlink" title="官方Java代码解答"></a>官方Java代码解答</h3><p>方法：<strong>双指针法</strong></p><ol><li>数组完成排序后，我们可以放置两个指针 i和 j，其中 i是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，我们就增加 j以跳过重复项；</li><li>当我们遇到 nums[i] !=nums[j] 时，跳过重复项的运行已经结束，因此我们必须把它 nums[j] 的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程，直到 j到达数组的末尾为止。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-xiang-by-/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/31/leetCode-no-26/#disqus_thread</comments>
    </item>
    
    <item>
      <title>leetCode-no-674</title>
      <link>http://yoursite.com/2020/07/30/leetCode-no-674/</link>
      <guid>http://yoursite.com/2020/07/30/leetCode-no-674/</guid>
      <pubDate>Thu, 30 Jul 2020 15:51:50 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个未经排序的整数数组，找到最长且连续的的递增序列，并返回该序列的长度&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个未经排序的整数数组，找到最长且连续的的递增序列，并返回该序列的长度</p><a id="more"></a><p>输入: [1,3,5,4,7]<br>输出: 3<br>解释: 最长连续递增序列是 [1,3,5], 长度为3。<br>尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。</p><p>输入: [2,2,2,2,2]<br>输出: 1<br>解释: 最长连续递增序列是 [2], 长度为1</p><p>思路：</p><ol><li>如果数组长度为1或者0的情况，返回该数组长度；</li><li>从数组索引为1的位置开始遍历数组，如果当前位置的前一位置数值比当前位置数值大，则判断 result和当前连续递增子序列的长度谁更大，数值大的保存到result，同时maxLength重置为1开始计数新的连续递增子序列；</li><li>不断重复步骤2，最后在返回最大连续递增数组长度前，需判断result&gt;maxLength?result:maxLength，为了防止整个数组都是连续递增的情况。</li></ol><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：1 ms, 在所有 Java 提交中击败了99.79%的用户</span></span><br><span class="line"><span class="comment">内存消耗：40.5 MB, 在所有 Java 提交中击败了48.15%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">leetcode_no_674</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义最终结果result及当前数组的连续递增序列的最大长度maxLength</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>,maxLength=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//判断数组长度等于或者为0的情况</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i-<span class="number">1</span>]&gt;=nums[i])&#123;</span><br><span class="line">                result=result&gt;maxLength?result:maxLength;</span><br><span class="line">                maxLength=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                maxLength++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排除整个数组都是递增的情况</span></span><br><span class="line">        result=result&gt;maxLength?result:maxLength;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> result=findLengthOfLCIS(nums);</span><br><span class="line">        System.out.println(<span class="string">"The result is:"</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="官方Java代码解释"><a href="#官方Java代码解释" class="headerlink" title="官方Java代码解释"></a>官方Java代码解释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ans是返回的最终结果；anchor是连续递增的子序列的分界点</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, anchor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="comment">//如果到达分界点，即遍历到了一个使原先连续递增的序列不再连续的数，则令anchor=i</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i-<span class="number">1</span>] &gt;= nums[i]) anchor = i;          </span><br><span class="line">            <span class="comment">//（i + 1- anchor） 记录的连续递增的子序列的连续数量</span></span><br><span class="line">            ans = Math.max(ans, i - anchor + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/solution/zui-chang-lian-xu-di-zeng-xu-lie-by-leetcode/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="官方代码的理解"><a href="#官方代码的理解" class="headerlink" title="官方代码的理解"></a>官方代码的理解</h4><p>每次循环都更新结果的值，当碰到分界点时，i - anchor + 1重新记录新的连续递增子序列的连续数量，而ans则代表前一连续递增子序列的连续数量，当再次碰到下一个分界点，ans = Math.max(ans, i - anchor + 1);会拿当前连续递增子序列的连续数量和上一次的比较，这样不断循环遍历，ans保存的是最大的连续递增子序列连续数量；<br>优点：<br>无需判断数组长度为0或者为1的情况；无需在整个数组都是连续递增的情况下做判断，代码简洁；</p><h3 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行用时：64 ms, 在所有 Python 提交中击败了76.75%的用户</span></span><br><span class="line"><span class="string">内存消耗：13.8 MB, 在所有 Python 提交中击败了10.00%的用户</span></span><br><span class="line"><span class="string">:type nums: List[int]</span></span><br><span class="line"><span class="string">:rtype: int</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLengthOfLCIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        result,maxLength=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i<span class="number">-1</span>]&gt;=nums[i]:</span><br><span class="line">                result=max(result,maxLength)</span><br><span class="line">                maxLength=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                maxLength+=<span class="number">1</span></span><br><span class="line">        result=max(result,maxLength)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>]</span><br><span class="line">s=Solution()</span><br><span class="line">result=s.findLengthOfLCIS(nums)</span><br><span class="line">print(<span class="string">"This result is :&#123;&#125;"</span>.format(result))</span><br></pre></td></tr></table></figure><h3 id="官方Python代码解释"><a href="#官方Python代码解释" class="headerlink" title="官方Python代码解释"></a>官方Python代码解释</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLengthOfLCIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        ans = anchor = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">and</span> nums[i<span class="number">-1</span>] &gt;= nums[i]: anchor = i</span><br><span class="line">            ans = max(ans, i - anchor + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">作者：LeetCode</span></span><br><span class="line"><span class="string">链接：https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/solution/zui-chang-lian-xu-di-zeng-xu-lie-by-leetcode/</span></span><br><span class="line"><span class="string">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="string">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/30/leetCode-no-674/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法-马踏棋盘问题-贪心算法优化</title>
      <link>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/</link>
      <guid>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/</guid>
      <pubDate>Tue, 28 Jul 2020 10:24:13 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;马踏棋盘问题介绍&quot;&gt;&lt;a href=&quot;#马踏棋盘问题介绍&quot; class=&quot;headerlink&quot; title=&quot;马踏棋盘问题介绍&quot;&gt;&lt;/a&gt;马踏棋盘问题介绍&lt;/h3&gt;&lt;p&gt;在 8×8 的国际象棋棋盘上，用一个马按照马步(马走日字)跳遍整个棋盘，要求每个格子都只跳到一次，最后回到出发点。&lt;br&gt;马踏棋盘问题同时也是图的深度优先搜索的应用&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="马踏棋盘问题介绍"><a href="#马踏棋盘问题介绍" class="headerlink" title="马踏棋盘问题介绍"></a>马踏棋盘问题介绍</h3><p>在 8×8 的国际象棋棋盘上，用一个马按照马步(马走日字)跳遍整个棋盘，要求每个格子都只跳到一次，最后回到出发点。<br>马踏棋盘问题同时也是图的深度优先搜索的应用</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>策略选择：</p><ol><li>暴力搜索</li><li>贪心算法优化</li></ol><p>策略分析：<br>暴力搜索耗费时间长，使用贪心算法每次选择当前位置的所有可选位置中最少的进行前进，即对当前位置的所有位置的下一个落脚点的可选序列数量进行非递减顺序排序，从其中选择最少的前进。这样回溯速度快，总体运行时间少。</p><p>马踏棋盘问题图例：<br><img src="/images/algorithm_img/horseCheck/horseCheck.png" alt="棋盘"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>马踏棋盘问题代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/25</span></span><br><span class="line"><span class="comment">* @功能：运用贪心算法对马踏棋盘问题进行优化,比原先暴力搜索的策略效率大大增强</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> tsp;</span><br><span class="line"><span class="keyword">import</span> java.awt.Point;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HorseStepCheckBoard</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义棋盘的行数</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> X;</span><br><span class="line">     <span class="comment">// 定义棋盘的列数</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> Y;</span><br><span class="line">     <span class="comment">// 定义棋盘,每个棋位表示棋子下的第几步</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span>[][] checkBoard;</span><br><span class="line">     <span class="comment">// 定义与棋盘同样大小的二维数组,每个位置表示棋子是否走过</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">boolean</span>[][] stepVisited;</span><br><span class="line">     <span class="comment">// 定义标识马踏棋盘任务完成的标识</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">boolean</span> finished;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 初始化值</span></span><br><span class="line">           X = <span class="number">8</span>;</span><br><span class="line">           Y = <span class="number">8</span>;</span><br><span class="line">           checkBoard = <span class="keyword">new</span> <span class="keyword">int</span>[X][Y];</span><br><span class="line">           stepVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[X][Y];</span><br><span class="line">           <span class="comment">// 定义起始位置</span></span><br><span class="line">           <span class="keyword">int</span> row = <span class="number">1</span>, column = <span class="number">1</span>;</span><br><span class="line">           <span class="comment">// 开始时间</span></span><br><span class="line">           <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">           traverseCheckBoard(row - <span class="number">1</span>, column - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">           <span class="comment">// 结束时间</span></span><br><span class="line">           <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">           System.out.println(<span class="string">"完成马踏棋盘游戏花费： "</span> + (endTime -  startTime)+<span class="string">"毫秒"</span>);</span><br><span class="line">           showCheckBoard();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 输出棋盘的结果</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showCheckBoard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"***********************checkBoard***********************"</span>);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; checkBoard.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; checkBoard[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                     System.out.print(checkBoard[i][j] + <span class="string">"\t"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">"***********************checkBoard***********************"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseCheckBoard</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>  step)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 将当前位置置为已访问</span></span><br><span class="line">           checkBoard[x][y] = step;</span><br><span class="line">           stepVisited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">           <span class="comment">// 获得下一个可访问的位置</span></span><br><span class="line">           ArrayList&lt;Point&gt; next = nextPoint(<span class="keyword">new</span> Point(y, x));</span><br><span class="line">           <span class="comment">//贪心算法优化</span></span><br><span class="line">           sortPoint(next);</span><br><span class="line">           <span class="keyword">while</span> (!next.isEmpty()) &#123;</span><br><span class="line">                Point p = next.remove(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 该位置未访问才能作为下一步的棋子位置</span></span><br><span class="line">                <span class="keyword">if</span> (!stepVisited[p.x][p.y]) &#123;</span><br><span class="line">                     traverseCheckBoard(p.x, p.y, step + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 未完成则当前位置置为0且标志未访问</span></span><br><span class="line">           <span class="keyword">if</span> (!finished &amp;&amp; step &lt; X * Y) &#123;</span><br><span class="line">                checkBoard[x][y] = <span class="number">0</span>;</span><br><span class="line">                stepVisited[x][y] = <span class="keyword">false</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                finished = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 判断当前位置的下一步位置</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Point&gt; <span class="title">nextPoint</span><span class="params">(Point curPoint)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义存放可走位置的容器</span></span><br><span class="line">           ArrayList&lt;Point&gt; pointSet = <span class="keyword">new</span> ArrayList&lt;Point&gt;();</span><br><span class="line">           <span class="comment">// 定义暂存点</span></span><br><span class="line">           Point p1 = <span class="keyword">new</span> Point();</span><br><span class="line">           <span class="comment">// 左上角平日字,5号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y =  curPoint.y - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 左上角竖日字,6号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y =  curPoint.y - <span class="number">2</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 右上角竖日字,7号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y  - <span class="number">2</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 右上角平日字,0号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y  - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 右下角平日字,1号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y  + <span class="number">1</span>) &lt; Y) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 右下角竖日字,2号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y  + <span class="number">2</span>) &lt; Y) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 左下角竖日字,3号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y =  curPoint.y + <span class="number">2</span>) &lt; Y) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 左下角平日字,4号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y =  curPoint.y + <span class="number">1</span>) &lt; Y) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> pointSet;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 对当前位置的下一步按照非递减排序后选择合适的位置以致减少回溯的次数</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortPoint</span><span class="params">(ArrayList&lt;Point&gt; pointSet)</span> </span>&#123;</span><br><span class="line">           pointSet.sort(<span class="keyword">new</span> Comparator&lt;Point&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">                     <span class="comment">// 获取p1的下一步所有位置个数</span></span><br><span class="line">                     <span class="keyword">int</span> count1 = nextPoint(p1).size();</span><br><span class="line">                     <span class="comment">// 获取p2的下一步所有位置个数</span></span><br><span class="line">                     <span class="keyword">int</span> count2 = nextPoint(p2).size();</span><br><span class="line">                     <span class="keyword">if</span> (count1 &lt; count2) &#123;</span><br><span class="line">                           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                     &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count1==count2) &#123;</span><br><span class="line">                           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法-弗洛伊德算法-最短路径问题</title>
      <link>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</link>
      <guid>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Tue, 28 Jul 2020 10:23:14 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;弗洛伊德算法介绍&quot;&gt;&lt;a href=&quot;#弗洛伊德算法介绍&quot; class=&quot;headerlink&quot; title=&quot;弗洛伊德算法介绍&quot;&gt;&lt;/a&gt;弗洛伊德算法介绍&lt;/h3&gt;&lt;p&gt;是用于寻找给定加权图中顶点间的最短路径的算法。&lt;/p&gt;
&lt;p&gt;弗洛伊德算法与迪杰斯特拉算法的区别：&lt;br&gt;弗洛伊德算法是求解每个顶点(每一个顶点都是出发顶点)到其他各顶点的最短路径问题，而迪杰斯特拉算法是求其中一个顶点(出发顶点)到其他顶点的最短路径问题。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="弗洛伊德算法介绍"><a href="#弗洛伊德算法介绍" class="headerlink" title="弗洛伊德算法介绍"></a>弗洛伊德算法介绍</h3><p>是用于寻找给定加权图中顶点间的最短路径的算法。</p><p>弗洛伊德算法与迪杰斯特拉算法的区别：<br>弗洛伊德算法是求解每个顶点(每一个顶点都是出发顶点)到其他各顶点的最短路径问题，而迪杰斯特拉算法是求其中一个顶点(出发顶点)到其他顶点的最短路径问题。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>算法步骤：</p><ol><li>设置顶点vi到顶点vk的最短路径已知为Lik,顶点vk到vj的最短路径已知为Lkj,顶点vi到vj的路径为Lij，则vi到vj的最短路径为：min((Lik+Lkj),Lij)，vk的取值为图中所有的顶点，则可获得vi到vj的最短路径；</li><li>vi到vk的最短路径Lik或者vk到vj的最短路径Lkj以上述同样方式获得。</li></ol><p>算法应用案例：</p><ol><li>有7个村庄（A,B,C,D,E,F,G），现在需要求每个村庄到其他村庄路径最短距离？</li><li>比如A到其他所有村庄的最短距离，B到其他所有村庄的最短距离？</li></ol><p><img src="/images/algorithm_img/road.png" alt="村庄"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>弗洛伊德应用案例代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/25</span></span><br><span class="line"><span class="comment">* @功能：使用弗洛伊德算法求解各顶点到其他顶点最短路径问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> floyd;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FloydAlgorithm</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = <span class="number">65535</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">char</span>[] vertexArray = &#123; <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>,  <span class="string">'G'</span> &#125;;</span><br><span class="line">           <span class="keyword">int</span>[][] graphEdgesValues = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123; INF, <span class="number">5</span>, <span class="number">7</span>,  INF, INF, INF, <span class="number">2</span> &#125;, &#123; <span class="number">5</span>, INF, INF, <span class="number">9</span>, INF, INF, <span class="number">3</span> &#125;,</span><br><span class="line">                     &#123; <span class="number">7</span>, INF, INF, INF, <span class="number">8</span>, INF, INF &#125;, &#123; INF,  <span class="number">9</span>, INF, INF, INF, <span class="number">4</span>, INF &#125;, &#123; INF, INF, <span class="number">8</span>, INF, INF, <span class="number">5</span>, <span class="number">4</span> &#125;,</span><br><span class="line">                     &#123; INF, INF, INF, <span class="number">4</span>, <span class="number">5</span>, INF, <span class="number">6</span> &#125;, &#123; <span class="number">2</span>, <span class="number">3</span>,  INF, INF, <span class="number">4</span>, <span class="number">6</span>, INF &#125;, &#125;;</span><br><span class="line">           Graph graph = <span class="keyword">new</span> Graph(vertexArray.length,  vertexArray, graphEdgesValues);</span><br><span class="line">           graph.floyd();</span><br><span class="line">           graph.showGraph();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 图的顶点数</span></span><br><span class="line">     <span class="keyword">int</span> graphVertexNum;</span><br><span class="line">     <span class="comment">// 图的顶点数组</span></span><br><span class="line">     <span class="keyword">char</span>[] graphVertexValues;</span><br><span class="line">     <span class="comment">// 图的顶点之间的距离二维数组</span></span><br><span class="line">     <span class="keyword">int</span>[][] graphVertexDistance;</span><br><span class="line">     <span class="comment">// 图的前驱顶点的二维数组</span></span><br><span class="line">     <span class="keyword">int</span>[][] graphVertexPreNode;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> vNum, <span class="keyword">char</span>[] vertexArray, <span class="keyword">int</span>[][] Matrix)</span>  </span>&#123;</span><br><span class="line">           <span class="comment">// 初始化数组的长度</span></span><br><span class="line">           <span class="keyword">this</span>.graphVertexNum = vNum;</span><br><span class="line">           <span class="keyword">this</span>.graphVertexValues = <span class="keyword">new</span> <span class="keyword">char</span>[graphVertexNum];</span><br><span class="line">           <span class="keyword">this</span>.graphVertexDistance = <span class="keyword">new</span>  <span class="keyword">int</span>[graphVertexNum][graphVertexNum];</span><br><span class="line">           <span class="keyword">this</span>.graphVertexPreNode = <span class="keyword">new</span>  <span class="keyword">int</span>[graphVertexNum][graphVertexNum];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graphVertexNum; i++) &#123;</span><br><span class="line">                <span class="keyword">this</span>.graphVertexValues[i] = vertexArray[i];</span><br><span class="line">                <span class="comment">//给每一个起始点对应其他顶点的前驱顶点赋值</span></span><br><span class="line">                Arrays.fill(graphVertexPreNode[i], i);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphVertexNum; j++) &#123;</span><br><span class="line">                     graphVertexDistance[i][j] = Matrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 显示图的效果</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graphVertexNum; i++) &#123;</span><br><span class="line">                <span class="comment">// 显示起始顶点到达的终点顶点的前驱顶点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphVertexNum; j++) &#123;</span><br><span class="line">                     System.out.print(graphVertexValues[graphVertexPreNode[i][j]]+<span class="string">"\t"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="comment">// 显示起始点到达其他顶点的最短路径长度</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; graphVertexNum; k++) &#123;</span><br><span class="line">                     System.out.print(graphVertexValues[i] +  <span class="string">"-&gt;"</span> + graphVertexValues[k] + <span class="string">" :"</span> + graphVertexDistance[i][k]+<span class="string">"  | "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"\n"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//弗洛伊德算法核心代码</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//第一层循环,遍历中间顶点</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;graphVertexNum;k++) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//第二层循环,遍历起始顶点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graphVertexNum;i++) &#123;</span><br><span class="line">                     <span class="comment">//第三层循环,遍历终点顶点</span></span><br><span class="line">                     <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;graphVertexNum;j++) &#123;</span><br><span class="line">                           <span class="comment">//记录从起始顶点经中间顶点到终点顶点的路径长度</span></span><br><span class="line">                           <span class="keyword">int</span>  len=graphVertexDistance[i][k]+graphVertexDistance[k][j];</span><br><span class="line">                           <span class="keyword">if</span>(len&lt;graphVertexDistance[i][j]) &#123;</span><br><span class="line">                                graphVertexDistance[i][j]=len;</span><br><span class="line">                                <span class="comment">//更新前驱顶点</span></span><br><span class="line">                                graphVertexPreNode[i][j]=graphVertexPreNode[k][j];</span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法-迪杰斯特拉算法-最短路径问题</title>
      <link>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</link>
      <guid>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Tue, 28 Jul 2020 10:22:36 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;迪杰斯特拉算法介绍&quot;&gt;&lt;a href=&quot;#迪杰斯特拉算法介绍&quot; class=&quot;headerlink&quot; title=&quot;迪杰斯特拉算法介绍&quot;&gt;&lt;/a&gt;迪杰斯特拉算法介绍&lt;/h3&gt;&lt;p&gt;迪杰斯特拉算法是典型的最短路径算法，用于计算一个节点到其他节点的最短路径，它的主要特点是以起始点为中心向外层以广度优先搜索思想扩展，直到扩展到终点为止。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="迪杰斯特拉算法介绍"><a href="#迪杰斯特拉算法介绍" class="headerlink" title="迪杰斯特拉算法介绍"></a>迪杰斯特拉算法介绍</h3><p>迪杰斯特拉算法是典型的最短路径算法，用于计算一个节点到其他节点的最短路径，它的主要特点是以起始点为中心向外层以广度优先搜索思想扩展，直到扩展到终点为止。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>迪杰斯特拉算法步骤：</p><ol><li>设置出发顶点为v，顶点集合V{v1,v2,vi…},v到V中各顶点的距离构成距离集合Dis,Dis{d1,d2,di…},Dis集合记录着v到途中各顶点的距离(到自身看作0，v到vi距离对应为di)；</li><li>从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi，此时的v到vi即为最短路径；</li><li>更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值比较小的一个，同时更新顶点的前驱节点为vi，表明是通过vi到达的；</li><li>重复执行步骤2和步骤3，直到最短路径顶点为目标顶点即可结束。</li></ol><p>问题实例：</p><ol><li>有7个村庄（A,B,C,D,E,F,G），现在需要求村庄G到其他村庄路径最短距离？</li></ol><p><img src="/images/algorithm_img/road.png" alt="村庄"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/24</span></span><br><span class="line"><span class="comment">* @功能：使用迪杰斯特拉算法解决顶点到各个点最短路径的求法问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> dijkstra;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DijkstraAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = <span class="number">65535</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] graphVertexValues = &#123; <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] graphEdgesValues = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123; INF, <span class="number">5</span>, <span class="number">7</span>, INF, INF, INF, <span class="number">2</span> &#125;, &#123; <span class="number">5</span>, INF, INF, <span class="number">9</span>, INF, INF, <span class="number">3</span> &#125;,</span><br><span class="line">                &#123; <span class="number">7</span>, INF, INF, INF, <span class="number">8</span>, INF, INF &#125;, &#123; INF, <span class="number">9</span>, INF, INF, INF, <span class="number">4</span>, INF &#125;, &#123; INF, INF, <span class="number">8</span>, INF, INF, <span class="number">5</span>, <span class="number">4</span> &#125;,</span><br><span class="line">                &#123; INF, INF, INF, <span class="number">4</span>, <span class="number">5</span>, INF, <span class="number">6</span> &#125;, &#123; <span class="number">2</span>, <span class="number">3</span>, INF, INF, <span class="number">4</span>, <span class="number">6</span>, INF &#125;, &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        DijkstraMethod dij = <span class="keyword">new</span> DijkstraMethod(graphVertexValues, graphEdgesValues, <span class="number">0</span>);</span><br><span class="line">        dij.showGraph();</span><br><span class="line">        <span class="comment">// 调用迪杰斯特拉算法求得顶点到各点的最短路径</span></span><br><span class="line">        dij.dijkstra();</span><br><span class="line">        <span class="comment">// 显示结果</span></span><br><span class="line">        dij.result();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义类封装迪杰斯特拉相关方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DijkstraMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    Graph graph;</span><br><span class="line">    <span class="comment">// 定义顶点访问数组</span></span><br><span class="line">    <span class="keyword">int</span>[] visited;</span><br><span class="line">    <span class="comment">// 定义初始点到各点距离数组</span></span><br><span class="line">    <span class="keyword">int</span>[] distance;</span><br><span class="line">    <span class="comment">// 定义各顶点的前驱顶点</span></span><br><span class="line">    <span class="keyword">int</span>[] preVertex;</span><br><span class="line">    <span class="comment">// 开始顶点</span></span><br><span class="line">    <span class="keyword">int</span> beginIndex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DijkstraMethod</span><span class="params">(<span class="keyword">char</span>[] graphVertexValues, <span class="keyword">int</span>[][] graphEdgesValues, <span class="keyword">int</span> beginVertex)</span> </span>&#123;</span><br><span class="line">        graph = <span class="keyword">new</span> Graph(graphVertexValues, graphEdgesValues);</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">int</span>[graph.graphVertexNum];</span><br><span class="line">        distance = <span class="keyword">new</span> <span class="keyword">int</span>[graph.graphVertexNum];</span><br><span class="line">        preVertex = <span class="keyword">new</span> <span class="keyword">int</span>[graph.graphVertexNum];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (beginVertex &lt; <span class="number">0</span> || beginVertex &gt;= graph.graphVertexNum) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"beginVertex out of range!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化开始节点各数组情况</span></span><br><span class="line">        <span class="comment">// 初始顶点已访问</span></span><br><span class="line">        <span class="keyword">this</span>.beginIndex = beginVertex;</span><br><span class="line">        visited[beginVertex] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 初始化距离数组的数值</span></span><br><span class="line">        Arrays.fill(distance, <span class="number">65535</span>);</span><br><span class="line">        distance[beginVertex] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        graph.showGraph();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dijkstra核心代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 更新开始点的距离数组等信息</span></span><br><span class="line">        updateMessage(beginIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; graph.graphVertexNum; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curIndex = getNextVertexIndex();</span><br><span class="line">            <span class="comment">// 更新开始点关联的其他点的距离数组等信息</span></span><br><span class="line">            updateMessage(curIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得下一个访问顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextVertexIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, minValue = <span class="number">65535</span>;</span><br><span class="line">        <span class="comment">// 遍历每一个顶点对应的其他顶点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.graphVertexNum; i++) &#123;</span><br><span class="line">            <span class="comment">// 若未访问且距离小于minValue</span></span><br><span class="line">            <span class="keyword">if</span> (visited[i] != <span class="number">1</span> &amp;&amp; distance[i] &lt; minValue) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                minValue = distance[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 选中访问的顶点,则标志为已经访问</span></span><br><span class="line">        visited[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新每一个顶点对应的前驱顶点数组,访问数组,距离数组的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateMessage</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.graphEdgesValues[index].length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = distance[index] + graph.graphEdgesValues[index][i];</span><br><span class="line">            <span class="keyword">if</span> (len &lt; distance[i] &amp;&amp; visited[i] != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 若当前距离可达则更新当前点到其他点的距离数组</span></span><br><span class="line">                distance[i] = len;</span><br><span class="line">                <span class="comment">// 且更新前驱顶点</span></span><br><span class="line">                preVertex[i] = index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示迪杰斯特拉算法的结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.graphVertexValues.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"顶点"</span> + graph.graphVertexValues[beginIndex] + <span class="string">"距离"</span> + graph.graphVertexValues[i] + <span class="string">"的距离为："</span></span><br><span class="line">                    + distance[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义图的属性类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 图顶点的个数</span></span><br><span class="line">    <span class="keyword">int</span> graphVertexNum;</span><br><span class="line">    <span class="comment">// 存放图顶点的数组</span></span><br><span class="line">    <span class="keyword">char</span>[] graphVertexValues;</span><br><span class="line">    <span class="comment">// 存放图中边的权值的邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span>[][] graphEdgesValues;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法初始化顶点及边的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">char</span>[] graphVertexValues, <span class="keyword">int</span>[][] graphEdgesValues)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.graphVertexNum = graphVertexValues.length;</span><br><span class="line">        <span class="keyword">this</span>.graphVertexValues = <span class="keyword">new</span> <span class="keyword">char</span>[graphVertexNum];</span><br><span class="line">        <span class="keyword">this</span>.graphEdgesValues = <span class="keyword">new</span> <span class="keyword">int</span>[graphVertexNum][graphVertexNum];</span><br><span class="line">        <span class="comment">// 初始化图顶点数组及图中边的权值的邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graphVertexNum; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.graphVertexValues[i] = graphVertexValues[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphVertexNum; j++) &#123;</span><br><span class="line">                <span class="keyword">this</span>.graphEdgesValues[i][j] = graphEdgesValues[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"**********************************GraphMatrix****************************************"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graphVertexNum; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphVertexNum; j++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%12d"</span>, graphEdgesValues[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"*************************************************************************************"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法-克鲁斯卡尔算法-最小生成树</title>
      <link>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link>
      <guid>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</guid>
      <pubDate>Tue, 28 Jul 2020 10:22:01 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;克鲁斯卡尔算法介绍&quot;&gt;&lt;a href=&quot;#克鲁斯卡尔算法介绍&quot; class=&quot;headerlink&quot; title=&quot;克鲁斯卡尔算法介绍&quot;&gt;&lt;/a&gt;克鲁斯卡尔算法介绍&lt;/h3&gt;&lt;p&gt;克鲁斯卡尔算法是求连通网的最小生成树的另一种方法。与普里姆算法不同，它的时间复杂度为O（eloge）（e为网中的边数），所以，适合于求边稀疏的网的最小生成树。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="克鲁斯卡尔算法介绍"><a href="#克鲁斯卡尔算法介绍" class="headerlink" title="克鲁斯卡尔算法介绍"></a>克鲁斯卡尔算法介绍</h3><p>克鲁斯卡尔算法是求连通网的最小生成树的另一种方法。与普里姆算法不同，它的时间复杂度为O（eloge）（e为网中的边数），所以，适合于求边稀疏的网的最小生成树。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>克鲁斯卡尔算法步骤：</p><ol><li>按照边的权值从小到大顺序排序；</li><li>从排好顺序的边从小到大选择，选择最小的边加入森林中，但前提是加入的边在森林中不构成回路，直到森林变成一棵树为止。</li></ol><p>应用场景问题：</p><ol><li>某城市有7个公交站点(A,B,C,D,E,F,G)，现在需要修路把7个站点连通，站点之间的距离表示权值；</li><li>如何修路既能保证各站点连通且修建里程最短。</li></ol><p>公交站站点示意图：</p><p><img src="/images/algorithm_img/kruskal/kruskal.jpg" alt="公交站"></p><p><strong>代码难点：</strong><br>如何判断俩个顶点的终点索引相同，即如何判断是否产生回路？</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/23</span></span><br><span class="line"><span class="comment">* @功能：利用克鲁斯卡尔算法思想解决公交站里程问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> kruskal;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalAlgorithmDemo</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义边的最大值,表示俩顶点之间不可达</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义顶点的值</span></span><br><span class="line">           <span class="keyword">char</span>[] vertexValues = &#123; <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>,  <span class="string">'G'</span> &#125;;</span><br><span class="line">           <span class="comment">// 定义顶点与顶点之间的关系</span></span><br><span class="line">           <span class="keyword">int</span>[][] edgesValueMatrix = &#123;</span><br><span class="line">                                <span class="comment">/* A */</span><span class="comment">/* B */</span><span class="comment">/* C */</span><span class="comment">/* D */</span><span class="comment">/* E  */</span><span class="comment">/* F */</span><span class="comment">/* G */</span></span><br><span class="line">                     <span class="comment">/* A */</span> &#123; <span class="number">0</span>, <span class="number">12</span>, INF, INF, INF, <span class="number">16</span>, <span class="number">14</span> &#125;,</span><br><span class="line">                     <span class="comment">/* B */</span> &#123; <span class="number">12</span>, <span class="number">0</span>, <span class="number">10</span>, INF, INF, <span class="number">7</span>, INF &#125;,</span><br><span class="line">                     <span class="comment">/* C */</span> &#123; INF, <span class="number">10</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, INF &#125;,</span><br><span class="line">                     <span class="comment">/* D */</span> &#123; INF, INF, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, INF, INF &#125;,</span><br><span class="line">                     <span class="comment">/* E */</span> &#123; INF, INF, <span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span> &#125;,</span><br><span class="line">                     <span class="comment">/* F */</span> &#123; <span class="number">16</span>, <span class="number">7</span>, <span class="number">6</span>, INF, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span> &#125;,</span><br><span class="line">                     <span class="comment">/* G */</span> &#123; <span class="number">14</span>, INF, INF, INF, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span> &#125; &#125;;</span><br><span class="line">           <span class="comment">// 初始化图的顶点及边关系</span></span><br><span class="line">           CreateGraph graph = <span class="keyword">new</span>  CreateGraph(vertexValues.length, vertexValues,edgesValueMatrix);</span><br><span class="line">           graph.showGraphMatrix();</span><br><span class="line">           <span class="comment">//将所有边存入数组</span></span><br><span class="line">           graph.setEdgesArray();</span><br><span class="line">           System.out.println(<span class="string">"********************Min  Tree*************************"</span>);</span><br><span class="line">           graph.kruskal();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateGraph</span> </span>&#123;</span><br><span class="line">     <span class="comment">//定义图类的变量</span></span><br><span class="line">     DefinitionGraph graph;</span><br><span class="line">     <span class="comment">//定义边类的变量</span></span><br><span class="line">     DefinitionEdge edge;</span><br><span class="line">     <span class="comment">// 定义边的最大值,表示俩顶点之间不可达</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line">     <span class="comment">//统计边的数量</span></span><br><span class="line">     <span class="keyword">int</span> edgesCount;</span><br><span class="line">     <span class="comment">//定义存放边的数组</span></span><br><span class="line">     DefinitionEdge[] edgesArray;</span><br><span class="line">     <span class="comment">// 在构造方法中初始化图中边及顶点的属性,同时统计边的条数</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">CreateGraph</span><span class="params">(<span class="keyword">int</span> vertexNum, <span class="keyword">char</span>[] vertexValues,  <span class="keyword">int</span>[][] edgesValueMatrix)</span> </span>&#123;</span><br><span class="line">           graph = <span class="keyword">new</span> DefinitionGraph(vertexNum);</span><br><span class="line">           <span class="comment">// 给边及顶点赋值</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.vertexNum; i++) &#123;</span><br><span class="line">                graph.vertexValues[i] = vertexValues[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph.vertexNum; j++) &#123;</span><br><span class="line">                     graph.edgesValueMatrix[i][j] =  edgesValueMatrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 统计边的条数及存放边的数组</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.vertexNum; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; graph.vertexNum; j++) &#123;</span><br><span class="line">                     <span class="keyword">if</span>(graph.edgesValueMatrix[i][j]!=INF) &#123;</span><br><span class="line">                           edgesCount++;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           graph.graphEdgeNum=edgesCount;</span><br><span class="line">           </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 显示邻接矩阵</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraphMatrix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"**********************************GraphMatrix****************************************"</span>);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.vertexNum; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph.vertexNum; j++) &#123;</span><br><span class="line">                     System.out.printf(<span class="string">"%12d"</span>,  graph.edgesValueMatrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">"*************************************************************************************"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//显示边的条数</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEdgeNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> graph.graphEdgeNum;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//定义存放边的数组,将来对这个数组进行排序</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEdgesArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//定义存放边的数组</span></span><br><span class="line">           edgesArray=<span class="keyword">new</span> DefinitionEdge[getEdgeNum()];</span><br><span class="line">           <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.vertexNum; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; graph.vertexNum; j++) &#123;</span><br><span class="line">                     <span class="keyword">if</span>(graph.edgesValueMatrix[i][j]!=INF) &#123;</span><br><span class="line">                           edgesArray[count++]=<span class="keyword">new</span>  DefinitionEdge(graph.vertexValues[i], graph.vertexValues[j],  graph.edgesValueMatrix[i][j]);</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//遍历边的数量</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showEdgesArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;getEdgeNum();i++) &#123;</span><br><span class="line">                System.out.println(edgesArray[i]);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//对边的数组进行升序排序</span></span><br><span class="line">     DefinitionEdge curEdge=<span class="keyword">null</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortEdgesArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;getEdgeNum()-<span class="number">1</span>;i++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;getEdgeNum()-<span class="number">1</span>-i;j++) &#123;</span><br><span class="line">                     <span class="keyword">if</span>(edgesArray[j].curEdgesValues&gt;edgesArray[j+<span class="number">1</span>].curEdgesValues)  &#123;</span><br><span class="line">                           curEdge=edgesArray[j];</span><br><span class="line">                           edgesArray[j]=edgesArray[j+<span class="number">1</span>];</span><br><span class="line">                           edgesArray[j+<span class="number">1</span>]=curEdge;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//获得当前顶点的下标</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurVertexIndex</span><span class="params">(<span class="keyword">char</span> v)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.vertexNum;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(graph.vertexValues[i]==v) &#123;</span><br><span class="line">                     <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//设置当前顶点的终点节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEndVertexIndex</span><span class="params">(<span class="keyword">int</span>[] end,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">while</span>(end[index]!=<span class="number">0</span>) &#123;<span class="comment">//若当前顶点的终点索引为0则返回自己的索引</span></span><br><span class="line">                index= end[index];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> index;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     <span class="comment">//克鲁斯卡尔算法核心代码</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//先对边的权值排序</span></span><br><span class="line">           sortEdgesArray();</span><br><span class="line">           <span class="comment">//定义顶点的终点索引数组</span></span><br><span class="line">           <span class="keyword">int</span>[] end=<span class="keyword">new</span> <span class="keyword">int</span>[getEdgeNum()];</span><br><span class="line">           <span class="comment">//定义构成图最小生成树所需的边数</span></span><br><span class="line">           <span class="keyword">int</span> edgesCount=<span class="number">0</span>;</span><br><span class="line">           </span><br><span class="line">           DefinitionEdge[] minTree=<span class="keyword">new</span>  DefinitionEdge[getEdgeNum()];</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;getEdgeNum();i++) &#123;</span><br><span class="line">                <span class="comment">//获得当前边一个点的下标</span></span><br><span class="line">                <span class="keyword">int</span>  startVertex=getCurVertexIndex(edgesArray[i].curVertex);</span><br><span class="line">                <span class="comment">//获得当前边的另一个顶点下标</span></span><br><span class="line">                <span class="keyword">int</span>  endVErtex=getCurVertexIndex(edgesArray[i].nextVertex);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//获得当前边俩个顶点的终点下标</span></span><br><span class="line">                <span class="keyword">int</span> v1_end=getEndVertexIndex(end, startVertex);</span><br><span class="line">                <span class="keyword">int</span> v2_end=getEndVertexIndex(end, endVErtex);</span><br><span class="line">                <span class="comment">//终点下标不相等,即不构成回路</span></span><br><span class="line">                <span class="keyword">if</span>(v1_end!=v2_end) &#123;</span><br><span class="line">                     minTree[edgesCount++]=edgesArray[i];</span><br><span class="line">                     end[v1_end]=v2_end;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//构成回路则不添加</span></span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edgesCount;i++) &#123;</span><br><span class="line">                System.out.println(minTree[i]);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义边的属性类,该类的实例化对象为一条边</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefinitionEdge</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义当前边的一个顶点</span></span><br><span class="line">     <span class="keyword">char</span> curVertex;</span><br><span class="line">     <span class="comment">// 定义当前边的下一个顶点</span></span><br><span class="line">     <span class="keyword">char</span> nextVertex;</span><br><span class="line">     <span class="comment">// 定义俩顶点之间边的权值</span></span><br><span class="line">     <span class="keyword">int</span> curEdgesValues;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">DefinitionEdge</span><span class="params">(<span class="keyword">char</span> curv, <span class="keyword">char</span> nextv, <span class="keyword">int</span> values)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.curVertex = curv;</span><br><span class="line">           <span class="keyword">this</span>.nextVertex = nextv;</span><br><span class="line">           <span class="keyword">this</span>.curEdgesValues = values;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"edge &lt;"</span> + curVertex + <span class="string">", "</span> + nextVertex + <span class="string">"&gt;  edgesValues="</span> + curEdgesValues;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义的图属性类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefinitionGraph</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义顶点个数</span></span><br><span class="line">     <span class="keyword">int</span> vertexNum;</span><br><span class="line">     <span class="comment">// 定义存储顶点值的数组</span></span><br><span class="line">     <span class="keyword">char</span>[] vertexValues;</span><br><span class="line">     <span class="comment">// 定义存储顶点与顶点之间权值的邻接矩阵</span></span><br><span class="line">     <span class="keyword">int</span>[][] edgesValueMatrix;</span><br><span class="line">     <span class="comment">// 定义图的边数</span></span><br><span class="line">     <span class="keyword">int</span> graphEdgeNum;</span><br><span class="line">     <span class="comment">// 构造方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">DefinitionGraph</span><span class="params">(<span class="keyword">int</span> vertexNums)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.vertexNum = vertexNums;</span><br><span class="line">           vertexValues = <span class="keyword">new</span> <span class="keyword">char</span>[vertexNum];</span><br><span class="line">           edgesValueMatrix = <span class="keyword">new</span> <span class="keyword">int</span>[vertexNum][vertexNum];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法-普利姆算法-最小生成树</title>
      <link>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link>
      <guid>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</guid>
      <pubDate>Tue, 28 Jul 2020 10:21:29 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;普利姆算法介绍&quot;&gt;&lt;a href=&quot;#普利姆算法介绍&quot; class=&quot;headerlink&quot; title=&quot;普利姆算法介绍&quot;&gt;&lt;/a&gt;普利姆算法介绍&lt;/h3&gt;&lt;p&gt;普里姆算法（Prim算法），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点（英语：Vertex (graph theory)），且其所有边的权值之和亦为最小。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="普利姆算法介绍"><a href="#普利姆算法介绍" class="headerlink" title="普利姆算法介绍"></a>普利姆算法介绍</h3><p>普里姆算法（Prim算法），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点（英语：Vertex (graph theory)），且其所有边的权值之和亦为最小。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>普利姆算法步骤如下：</p><ol><li>设G=(V,E)是连通图，T=(U,D)是最小生成树,V,U是顶点集合,E,D是边的集合；</li><li>若从顶点u开始构造最小生成树，则从集合V中取出顶点放入集合U中，标记顶点v的visited[u]=1;</li><li>若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边(ui，vj)加入集合D中，标记visited[vj]=1;</li><li>重复步骤2，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边；</li></ol><p>应用场景-修路问题：</p><ol><li>有7个村庄（A,B,C,D,E,F,G），现在需要修路把7个村庄连通；</li><li>各个村庄的距离用边线表示(权)，比如A-B距离5公里；</li><li>问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短？</li></ol><p><img src="/images/algorithm_img/road.png" alt="路"></p><p>修路问题本质就是最小生成树问题(Minimun Cost Spanning Tree),简称MST，给定一个带权的无向连通图，如何选取一棵生成树使得树上的所有边上权的总和为最小，这叫最小生成树。</p><ol><li>N个顶点，一定有N-1条边</li><li>包含全部顶点</li><li>N-1条边都在图中</li></ol><p>图的邻接矩阵：<br><img src="/images/algorithm_img/roadMatrix.png" alt="图的邻接矩阵"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/23</span></span><br><span class="line"><span class="comment">* @功能：利用普利姆算法思想解决修路问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> prim;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimAlgorithm</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义边的最大值,表示俩顶点之间不可达</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义顶点的值</span></span><br><span class="line">           <span class="keyword">char</span>[] vertexs = &#123; <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>  &#125;;</span><br><span class="line">           <span class="comment">// 定义顶点的个数</span></span><br><span class="line">           <span class="keyword">int</span> vertexNum = vertexs.length;</span><br><span class="line">           DefinitionGraph graph = <span class="keyword">new</span>  DefinitionGraph(vertexNum);</span><br><span class="line">          <span class="keyword">int</span>[][] graphMatrix = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123; INF, <span class="number">5</span>, <span class="number">7</span>, INF, INF, INF,  <span class="number">2</span> &#125;,</span><br><span class="line">                     &#123; <span class="number">5</span>, INF, INF, <span class="number">9</span>, INF, INF, <span class="number">3</span> &#125;, &#123; <span class="number">7</span>, INF,  INF, INF, <span class="number">8</span>, INF, INF &#125;,</span><br><span class="line">                     &#123; INF, <span class="number">9</span>, INF, INF, INF, <span class="number">4</span>, INF &#125;, &#123; INF,  INF, <span class="number">8</span>, INF, INF, <span class="number">5</span>, <span class="number">4</span> &#125;,</span><br><span class="line">                     &#123; INF, INF, INF, <span class="number">4</span>, <span class="number">5</span>, INF, <span class="number">6</span> &#125;, &#123; <span class="number">2</span>, <span class="number">3</span>,  INF, INF, <span class="number">4</span>, <span class="number">6</span>, INF &#125;, &#125;;</span><br><span class="line">           createMinimumCostSpanningTree minTree = <span class="keyword">new</span>  createMinimumCostSpanningTree();</span><br><span class="line">           <span class="comment">// 初始化图的各顶点值及边的值</span></span><br><span class="line">           minTree.createGraphMatrix(graph, vertexNum, vertexs,  graphMatrix);</span><br><span class="line">           <span class="comment">// 输出邻接矩阵</span></span><br><span class="line">           minTree.showgraphMatrix(graph);</span><br><span class="line">           <span class="comment">// 输出构造最小生成树的过程</span></span><br><span class="line">           minTree.minTree(graph, <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">createMinimumCostSpanningTree</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 生成图的邻接矩阵</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createGraphMatrix</span><span class="params">(DefinitionGraph graph, <span class="keyword">int</span>  graphVertexNum, <span class="keyword">char</span>[] vertexValue, <span class="keyword">int</span>[][] graphMatrix)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graphVertexNum; i++) &#123;</span><br><span class="line">                <span class="comment">// 给每个顶点赋值</span></span><br><span class="line">                graph.vertexValue[i] = vertexValue[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphVertexNum; j++) &#123;</span><br><span class="line">                     <span class="comment">// 给边与边之间加上权值</span></span><br><span class="line">                     graph.graphMatrix[i][j] =  graphMatrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 显示图的邻接矩阵</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showgraphMatrix</span><span class="params">(DefinitionGraph graph)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span>[] row : graph.graphMatrix) &#123;</span><br><span class="line">                System.out.println(Arrays.toString(row));</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 显示最小连同图的路径</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">minTree</span><span class="params">(DefinitionGraph graph, <span class="keyword">int</span>  beginVertex)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义当前顶点的索引</span></span><br><span class="line">           <span class="keyword">int</span> curVertexIndex = -<span class="number">1</span>;</span><br><span class="line">           <span class="comment">// 定义当前顶点的下一个连同顶点的索引</span></span><br><span class="line">           <span class="keyword">int</span> curVertexNextIndex = -<span class="number">1</span>;</span><br><span class="line">           <span class="comment">// 定义顶点被访问的标识</span></span><br><span class="line">           <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span>  <span class="keyword">boolean</span>[graph.graphVertexNum];</span><br><span class="line">           <span class="comment">// 首先先标明当前的顶点已经被访问</span></span><br><span class="line">           visited[beginVertex] = <span class="keyword">true</span>;</span><br><span class="line">           <span class="comment">// 定义边的最小权值</span></span><br><span class="line">           <span class="keyword">int</span> minEdgeValue;</span><br><span class="line">           <span class="comment">// 最外层循环输出图的最小权边的构造过程,边数为顶点数减一</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; graph.graphVertexNum; i++) &#123;</span><br><span class="line">                minEdgeValue = <span class="number">10000</span>;</span><br><span class="line">                <span class="comment">// 里面俩层循环遍历邻接矩阵得到当前点的最小权值的边</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph.graphVertexNum; j++) &#123;</span><br><span class="line">                     <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; graph.graphVertexNum;  k++) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (visited[j] == <span class="keyword">true</span> &amp;&amp; visited[k]  == <span class="keyword">false</span> &amp;&amp; graph.graphMatrix[j][k] &lt; minEdgeValue) &#123;</span><br><span class="line">                                curVertexIndex = j;</span><br><span class="line">                                curVertexNextIndex = k;</span><br><span class="line">                                minEdgeValue =  graph.graphMatrix[j][k];</span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(</span><br><span class="line">                           <span class="string">"第"</span> + i + <span class="string">"条边：&lt; "</span> +  graph.vertexValue[curVertexIndex] + <span class="string">","</span> +  graph.vertexValue[curVertexNextIndex] + <span class="string">"&gt; ,边的权值为： "</span> +  minEdgeValue);</span><br><span class="line">                visited[curVertexNextIndex] = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefinitionGraph</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义图的顶点个数</span></span><br><span class="line">     <span class="keyword">int</span> graphVertexNum;</span><br><span class="line">     <span class="comment">// 定义顶点</span></span><br><span class="line">     <span class="keyword">char</span>[] vertexValue;</span><br><span class="line">     <span class="comment">// 定义邻接矩阵</span></span><br><span class="line">     <span class="keyword">int</span>[][] graphMatrix;</span><br><span class="line">     <span class="comment">// DefinitionGraph的构造方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">DefinitionGraph</span><span class="params">(<span class="keyword">int</span> graphVertexNum)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.graphVertexNum = graphVertexNum;</span><br><span class="line">           vertexValue = <span class="keyword">new</span> <span class="keyword">char</span>[graphVertexNum];</span><br><span class="line">           graphMatrix = <span class="keyword">new</span>  <span class="keyword">int</span>[graphVertexNum][graphVertexNum];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法-贪心算法-集合覆盖问题</title>
      <link>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E9%9B%86%E5%90%88%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/</link>
      <guid>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E9%9B%86%E5%90%88%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Tue, 28 Jul 2020 10:20:55 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;贪心算法介绍&quot;&gt;&lt;a href=&quot;#贪心算法介绍&quot; class=&quot;headerlink&quot; title=&quot;贪心算法介绍&quot;&gt;&lt;/a&gt;贪心算法介绍&lt;/h3&gt;&lt;p&gt;贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="贪心算法介绍"><a href="#贪心算法介绍" class="headerlink" title="贪心算法介绍"></a>贪心算法介绍</h3><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>贪心算法一般按如下步骤进行：</p><ol><li>建立数学模型来描述问题；</li><li>把求解的问题分成若干个子问题；</li><li>对每个子问题求解，得到子问题的局部最优解，可能不是最优解；</li><li>把子问题的解局部最优解合成原来解问题的一个解。</li></ol><p>集合覆盖问题：<br>存在以下表的广播台覆盖的地区，如何让选择最少的广播台让更多的地区接收到信号？<br><img src="/images/algorithm_img/greedy/broadcastSet.png" alt="广播站覆盖地区"></p><p>步骤分析：</p><ol><li>先获取到所有广播台的所有地区序列 allAreas { 北京、上海、天津、广州、深圳、成都、杭州、大连 }；</li><li>定义最大地区匹配值maxAreaNum，循环拿到每个广播台对应覆盖地区与allAreas取交集，如果下一个广播台的areaNum&gt;maxAreaNum,则令当前广播台为最大maxAreaNum；</li><li>一个循环结束，将所有地区序列allAreas中包含maxAreaNum对应的地区清楚，同时将最大覆盖地区的广播台放入选择集合；</li><li>拿到新的地区序列，继续重复步骤2和步骤3。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/21</span></span><br><span class="line"><span class="comment">* @fuction:利用贪心算法思想完成集合覆盖问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> greedy;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreedyAlgorithm</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义广播台HashMap键值对集合,String是广播台,HashSet存放地区</span></span><br><span class="line">           HashMap&lt;String, HashSet&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span>  HashMap&lt;String, HashSet&lt;String&gt;&gt;();</span><br><span class="line">           <span class="comment">// 广播台K1</span></span><br><span class="line">           HashSet&lt;String&gt; area1 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           area1.add(<span class="string">"北京"</span>);</span><br><span class="line">           area1.add(<span class="string">"上海"</span>);</span><br><span class="line">           area1.add(<span class="string">"天津"</span>);</span><br><span class="line">           <span class="comment">// 广播台K2</span></span><br><span class="line">           HashSet&lt;String&gt; area2 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           area2.add(<span class="string">"广州"</span>);</span><br><span class="line">           area2.add(<span class="string">"北京"</span>);</span><br><span class="line">           area2.add(<span class="string">"深圳"</span>);</span><br><span class="line">           <span class="comment">// 广播台K3</span></span><br><span class="line">           HashSet&lt;String&gt; area3 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           area3.add(<span class="string">"成都"</span>);</span><br><span class="line">           area3.add(<span class="string">"上海"</span>);</span><br><span class="line">           area3.add(<span class="string">"杭州"</span>);</span><br><span class="line">           <span class="comment">// 广播台K4</span></span><br><span class="line">           HashSet&lt;String&gt; area4 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           area4.add(<span class="string">"上海"</span>);</span><br><span class="line">           area4.add(<span class="string">"天津"</span>);</span><br><span class="line">           <span class="comment">// 广播台K5</span></span><br><span class="line">           HashSet&lt;String&gt; area5 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           area5.add(<span class="string">"杭州"</span>);</span><br><span class="line">           area5.add(<span class="string">"大连"</span>);</span><br><span class="line">           broadcasts.put(<span class="string">"K1"</span>, area1);</span><br><span class="line">           broadcasts.put(<span class="string">"K2"</span>, area2);</span><br><span class="line">           broadcasts.put(<span class="string">"K3"</span>, area3);</span><br><span class="line">           broadcasts.put(<span class="string">"K4"</span>, area4);</span><br><span class="line">           broadcasts.put(<span class="string">"K5"</span>, area5);</span><br><span class="line">           <span class="comment">// 获得广播站所有城市的序列</span></span><br><span class="line">           HashSet&lt;String&gt; allAreas = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           String[] area = &#123; <span class="string">"北京"</span>, <span class="string">"上海"</span>, <span class="string">"天津"</span>, <span class="string">"广州"</span>, <span class="string">"深圳"</span>, <span class="string">"成都"</span>, <span class="string">"杭州"</span>, <span class="string">"大连"</span> &#125;;</span><br><span class="line">           <span class="keyword">for</span> (String s : area) &#123;</span><br><span class="line">                allAreas.add(s);</span><br><span class="line">           &#125;</span><br><span class="line">           Object[] result=setCoverProblem(allAreas,  broadcasts);</span><br><span class="line">           <span class="comment">// 输出最终选择结果</span></span><br><span class="line">           System.out.println(Arrays.toString(result));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Object[] setCoverProblem(HashSet&lt;String&gt;  allAreas, HashMap&lt;String, HashSet&lt;String&gt;&gt; broadcasts) &#123;</span><br><span class="line">           <span class="comment">// 选择的广播站集合</span></span><br><span class="line">           HashSet&lt;String&gt; selected = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           <span class="comment">// 展示存放城市序列的集合</span></span><br><span class="line">           HashSet&lt;String&gt; tempSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           <span class="comment">// 定义覆盖最多城市广播站</span></span><br><span class="line">           String maxBroadcast = <span class="string">""</span>;</span><br><span class="line">           <span class="comment">// allAreas不为空则继续循环</span></span><br><span class="line">           <span class="keyword">while</span> (allAreas.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                maxBroadcast = <span class="keyword">null</span>;</span><br><span class="line">                tempSet = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 遍历获得各个广播站的键</span></span><br><span class="line">                <span class="keyword">for</span> (String key : broadcasts.keySet()) &#123;</span><br><span class="line">                     <span class="comment">// 获得当前广播站键对应的城市集合</span></span><br><span class="line">                     tempSet = broadcasts.get(key);</span><br><span class="line">                     tempSet.retainAll(allAreas);</span><br><span class="line">                     <span class="comment">// 若当前遍历到的广播站的与所有城市序列交集大于0</span></span><br><span class="line">                     <span class="comment">// 且最大城市未赋值或者当前遍历到的广播站与所有城市序列的交集大于最大广播站城市序列</span></span><br><span class="line">                     <span class="keyword">if</span> (tempSet.size() &gt; <span class="number">0</span></span><br><span class="line">                                &amp;&amp; (maxBroadcast == <span class="keyword">null</span> ||  tempSet.size() &gt; broadcasts.get(maxBroadcast).size())) &#123;</span><br><span class="line">                           maxBroadcast = key;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (maxBroadcast != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// 当前循环的相对最优选择被选中</span></span><br><span class="line">                     selected.add(maxBroadcast);</span><br><span class="line">                     <span class="comment">// 删除当前所有城市序列的的被选中城市,准备进入下一次选择</span></span><br><span class="line">                     allAreas.removeAll(broadcasts.get(maxBroadcast));</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> selected.toArray();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E9%9B%86%E5%90%88%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法-KMP算法</title>
      <link>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/</link>
      <guid>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/</guid>
      <pubDate>Tue, 28 Jul 2020 10:20:24 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;KMP算法介绍&quot;&gt;&lt;a href=&quot;#KMP算法介绍&quot; class=&quot;headerlink&quot; title=&quot;KMP算法介绍&quot;&gt;&lt;/a&gt;KMP算法介绍&lt;/h3&gt;&lt;p&gt;KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作，简称KMP算法。&lt;br&gt;KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。&lt;br&gt;具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n)。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="KMP算法介绍"><a href="#KMP算法介绍" class="headerlink" title="KMP算法介绍"></a>KMP算法介绍</h3><p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作，简称KMP算法。<br>KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。<br>具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n)。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>BF(Brute Force)算法和KMP算法的对比：<br>BF算法步骤：</p><ol><li>BF算法通过暴力匹配的方式，让文本串和模式串的每一个字符匹配；</li><li>匹配成功，则同时让文本串和模式串的当前索引 i 和 j移动到下一个字符的位置；</li><li>匹配失败，则令j回到初始位置，i移动到不匹配的字符的下一个位置，即 i-j+1的位置。<br>缺点：匹配速度慢，i回溯的位置重复匹配，效率低。</li></ol><p>KMP算法步骤：<br>比较详细的一篇文章： <a href="https://www.cnblogs.com/zzuuoo666/p/9028287.html" target="_blank" rel="noopener">比较详细的KMP算法文章</a><br>相对BF算法解决的问题：</p><ol><li>主要不是让文本串的索引 i 回溯，而是让模式串的 j 依据最大长度表来改变 j 的值，让模式串移动匹配文本串。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>BF算法实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/21</span></span><br><span class="line"><span class="comment">* @function:bf算法,和kmp算法形成比对</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> kmp;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BFAlgorithm</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           String str1 = <span class="string">"BBC ABCDAB ABCDABCDABDE"</span>;</span><br><span class="line">           String str2 = <span class="string">"ABCDABD"</span>;</span><br><span class="line">           <span class="keyword">int</span> index = bf(str1, str2);</span><br><span class="line">           System.out.println(<span class="string">"index= "</span> + index);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bf</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//i为文本串索引,j为模式串索引</span></span><br><span class="line">           <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span>(i&lt;str1.length()&amp;&amp;j&lt;str2.length()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(str1.charAt(i)==str2.charAt(j)) &#123;</span><br><span class="line">                     i++;</span><br><span class="line">                     j++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                     i=i-j+<span class="number">1</span>;</span><br><span class="line">                     j=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当j等于str2的长度则返回在str1的首个字符匹配的索引</span></span><br><span class="line">                <span class="keyword">if</span>(j==str2.length()) &#123;</span><br><span class="line">                     <span class="keyword">return</span> i-j;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KMP算法实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/21</span></span><br><span class="line"><span class="comment">* @function:实现KMP算法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> kmp;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMPAlgorithm</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           String str1 = <span class="string">"BBC ABCDAB ABCDABCDABDE"</span>;</span><br><span class="line">           String str2 = <span class="string">"ABCDABD"</span>;</span><br><span class="line">           <span class="comment">//String str2 = "BBC";</span></span><br><span class="line">           <span class="keyword">int</span>[] table = matchTable(str2);</span><br><span class="line">           <span class="keyword">int</span> index = kmp(str1, str2, table);</span><br><span class="line">           System.out.println(<span class="string">"index= "</span> + index);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(String str1, String str2, <span class="keyword">int</span>[]  table)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str1.charAt(i) !=  str2.charAt(j)) &#123;</span><br><span class="line">                     <span class="comment">//若当前文本串索引的字符与模式串索引字符不匹配;</span></span><br><span class="line">                     <span class="comment">//则令j的值为最大长度表前一个匹配的最大前缀后缀长度匹配值;</span></span><br><span class="line">                     <span class="comment">//举例子：比如当前模式串最后一个字符D与文本串索引17的字符C不匹配,</span></span><br><span class="line">                     <span class="comment">//但是最大长度匹配表中字符串ABCDAB的前缀后缀最大匹配长度为2,</span></span><br><span class="line">                     <span class="comment">//则意味则模式串前俩个字符AB不必再与文本串第15,16索引匹配,直接向下移动当前j=6,j-2个位置,</span></span><br><span class="line">                     <span class="comment">//则现在模式串的前俩个字符AB刚好与文本串第15,16的索引AB对应,模式串从第2个索引C开始和文本串第17个索引开始匹配</span></span><br><span class="line">                     j = table[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">                     j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == str2.length()) &#123;</span><br><span class="line">                     <span class="comment">// j等于str2的长度则返回在str1中位置开头字符索引</span></span><br><span class="line">                     <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] matchTable(String str) &#123;</span><br><span class="line">           <span class="comment">// 定义匹配表数组</span></span><br><span class="line">           <span class="keyword">int</span>[] table = <span class="keyword">new</span> <span class="keyword">int</span>[str.length()];</span><br><span class="line">           <span class="comment">// 匹配字符串第一个字母的前缀后缀匹配为零</span></span><br><span class="line">           table[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str.charAt(i) != str.charAt(j))  &#123;</span><br><span class="line">                     j = table[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (str.charAt(i) == str.charAt(j)) &#123;</span><br><span class="line">                     j++;</span><br><span class="line">                &#125;</span><br><span class="line">                table[i] = j;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> table;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
