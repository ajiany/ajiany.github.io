<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>我是ajian</title>
    <link>http://yoursite.com/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>选择的方向优胜于谋略的策略，方法比努力更有价值</description>
    <pubDate>Tue, 28 Jul 2020 11:26:21 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>算法-马踏棋盘问题-贪心算法优化</title>
      <link>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/</link>
      <guid>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/</guid>
      <pubDate>Tue, 28 Jul 2020 10:24:13 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;马踏棋盘问题介绍&quot;&gt;&lt;a href=&quot;#马踏棋盘问题介绍&quot; class=&quot;headerlink&quot; title=&quot;马踏棋盘问题介绍&quot;&gt;&lt;/a&gt;马踏棋盘问题介绍&lt;/h3&gt;&lt;p&gt;在 8×8 的国际象棋棋盘上，用一个马按照马步(马走日字)跳遍整个棋盘，要求每个格子都只跳到一次，最后回到出发点。&lt;br&gt;马踏棋盘问题同时也是图的深度优先搜索的应用&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="马踏棋盘问题介绍"><a href="#马踏棋盘问题介绍" class="headerlink" title="马踏棋盘问题介绍"></a>马踏棋盘问题介绍</h3><p>在 8×8 的国际象棋棋盘上，用一个马按照马步(马走日字)跳遍整个棋盘，要求每个格子都只跳到一次，最后回到出发点。<br>马踏棋盘问题同时也是图的深度优先搜索的应用</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>策略选择：</p><ol><li>暴力搜索</li><li>贪心算法优化</li></ol><p>策略分析：<br>暴力搜索耗费时间长，使用贪心算法每次选择当前位置的所有可选位置中最少的进行前进，即对当前位置的所有位置的下一个落脚点的可选序列数量进行非递减顺序排序，从其中选择最少的前进。这样回溯速度快，总体运行时间少。</p><p>马踏棋盘问题图例：<br><img src="/images/algorithm_img/horseCheck/horseCheck.png" alt="棋盘"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>马踏棋盘问题代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/25</span></span><br><span class="line"><span class="comment">* @功能：运用贪心算法对马踏棋盘问题进行优化,比原先暴力搜索的策略效率大大增强</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> tsp;</span><br><span class="line"><span class="keyword">import</span> java.awt.Point;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HorseStepCheckBoard</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义棋盘的行数</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> X;</span><br><span class="line">     <span class="comment">// 定义棋盘的列数</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> Y;</span><br><span class="line">     <span class="comment">// 定义棋盘,每个棋位表示棋子下的第几步</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span>[][] checkBoard;</span><br><span class="line">     <span class="comment">// 定义与棋盘同样大小的二维数组,每个位置表示棋子是否走过</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">boolean</span>[][] stepVisited;</span><br><span class="line">     <span class="comment">// 定义标识马踏棋盘任务完成的标识</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">boolean</span> finished;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 初始化值</span></span><br><span class="line">           X = <span class="number">8</span>;</span><br><span class="line">           Y = <span class="number">8</span>;</span><br><span class="line">           checkBoard = <span class="keyword">new</span> <span class="keyword">int</span>[X][Y];</span><br><span class="line">           stepVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[X][Y];</span><br><span class="line">           <span class="comment">// 定义起始位置</span></span><br><span class="line">           <span class="keyword">int</span> row = <span class="number">1</span>, column = <span class="number">1</span>;</span><br><span class="line">           <span class="comment">// 开始时间</span></span><br><span class="line">           <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">           traverseCheckBoard(row - <span class="number">1</span>, column - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">           <span class="comment">// 结束时间</span></span><br><span class="line">           <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">           System.out.println(<span class="string">"完成马踏棋盘游戏花费： "</span> + (endTime -  startTime)+<span class="string">"毫秒"</span>);</span><br><span class="line">           showCheckBoard();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 输出棋盘的结果</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showCheckBoard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"***********************checkBoard***********************"</span>);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; checkBoard.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; checkBoard[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                     System.out.print(checkBoard[i][j] + <span class="string">"\t"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">"***********************checkBoard***********************"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseCheckBoard</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>  step)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 将当前位置置为已访问</span></span><br><span class="line">           checkBoard[x][y] = step;</span><br><span class="line">           stepVisited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">           <span class="comment">// 获得下一个可访问的位置</span></span><br><span class="line">           ArrayList&lt;Point&gt; next = nextPoint(<span class="keyword">new</span> Point(y, x));</span><br><span class="line">           <span class="comment">//贪心算法优化</span></span><br><span class="line">           sortPoint(next);</span><br><span class="line">           <span class="keyword">while</span> (!next.isEmpty()) &#123;</span><br><span class="line">                Point p = next.remove(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 该位置未访问才能作为下一步的棋子位置</span></span><br><span class="line">                <span class="keyword">if</span> (!stepVisited[p.x][p.y]) &#123;</span><br><span class="line">                     traverseCheckBoard(p.x, p.y, step + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 未完成则当前位置置为0且标志未访问</span></span><br><span class="line">           <span class="keyword">if</span> (!finished &amp;&amp; step &lt; X * Y) &#123;</span><br><span class="line">                checkBoard[x][y] = <span class="number">0</span>;</span><br><span class="line">                stepVisited[x][y] = <span class="keyword">false</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                finished = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 判断当前位置的下一步位置</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Point&gt; <span class="title">nextPoint</span><span class="params">(Point curPoint)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义存放可走位置的容器</span></span><br><span class="line">           ArrayList&lt;Point&gt; pointSet = <span class="keyword">new</span> ArrayList&lt;Point&gt;();</span><br><span class="line">           <span class="comment">// 定义暂存点</span></span><br><span class="line">           Point p1 = <span class="keyword">new</span> Point();</span><br><span class="line">           <span class="comment">// 左上角平日字,5号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y =  curPoint.y - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 左上角竖日字,6号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y =  curPoint.y - <span class="number">2</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 右上角竖日字,7号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y  - <span class="number">2</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 右上角平日字,0号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y  - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 右下角平日字,1号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y  + <span class="number">1</span>) &lt; Y) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 右下角竖日字,2号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y  + <span class="number">2</span>) &lt; Y) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 左下角竖日字,3号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y =  curPoint.y + <span class="number">2</span>) &lt; Y) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 左下角平日字,4号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y =  curPoint.y + <span class="number">1</span>) &lt; Y) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> pointSet;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 对当前位置的下一步按照非递减排序后选择合适的位置以致减少回溯的次数</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortPoint</span><span class="params">(ArrayList&lt;Point&gt; pointSet)</span> </span>&#123;</span><br><span class="line">           pointSet.sort(<span class="keyword">new</span> Comparator&lt;Point&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">                     <span class="comment">// 获取p1的下一步所有位置个数</span></span><br><span class="line">                     <span class="keyword">int</span> count1 = nextPoint(p1).size();</span><br><span class="line">                     <span class="comment">// 获取p2的下一步所有位置个数</span></span><br><span class="line">                     <span class="keyword">int</span> count2 = nextPoint(p2).size();</span><br><span class="line">                     <span class="keyword">if</span> (count1 &lt; count2) &#123;</span><br><span class="line">                           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                     &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count1==count2) &#123;</span><br><span class="line">                           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法-弗洛伊德算法-最短路径问题</title>
      <link>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</link>
      <guid>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Tue, 28 Jul 2020 10:23:14 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;弗洛伊德算法介绍&quot;&gt;&lt;a href=&quot;#弗洛伊德算法介绍&quot; class=&quot;headerlink&quot; title=&quot;弗洛伊德算法介绍&quot;&gt;&lt;/a&gt;弗洛伊德算法介绍&lt;/h3&gt;&lt;p&gt;是用于寻找给定加权图中顶点间的最短路径的算法。&lt;/p&gt;
&lt;p&gt;弗洛伊德算法与迪杰斯特拉算法的区别：&lt;br&gt;弗洛伊德算法是求解每个顶点(每一个顶点都是出发顶点)到其他各顶点的最短路径问题，而迪杰斯特拉算法是求其中一个顶点(出发顶点)到其他顶点的最短路径问题。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="弗洛伊德算法介绍"><a href="#弗洛伊德算法介绍" class="headerlink" title="弗洛伊德算法介绍"></a>弗洛伊德算法介绍</h3><p>是用于寻找给定加权图中顶点间的最短路径的算法。</p><p>弗洛伊德算法与迪杰斯特拉算法的区别：<br>弗洛伊德算法是求解每个顶点(每一个顶点都是出发顶点)到其他各顶点的最短路径问题，而迪杰斯特拉算法是求其中一个顶点(出发顶点)到其他顶点的最短路径问题。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>算法步骤：</p><ol><li>设置顶点vi到顶点vk的最短路径已知为Lik,顶点vk到vj的最短路径已知为Lkj,顶点vi到vj的路径为Lij，则vi到vj的最短路径为：min((Lik+Lkj),Lij)，vk的取值为图中所有的顶点，则可获得vi到vj的最短路径；</li><li>vi到vk的最短路径Lik或者vk到vj的最短路径Lkj以上述同样方式获得。</li></ol><p>算法应用案例：</p><ol><li>有7个村庄（A,B,C,D,E,F,G），现在需要求每个村庄到其他村庄路径最短距离？</li><li>比如A到其他所有村庄的最短距离，B到其他所有村庄的最短距离？</li></ol><p><img src="/images/algorithm_img/road.png" alt="村庄"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>弗洛伊德应用案例代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/25</span></span><br><span class="line"><span class="comment">* @功能：使用弗洛伊德算法求解各顶点到其他顶点最短路径问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> floyd;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FloydAlgorithm</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = <span class="number">65535</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">char</span>[] vertexArray = &#123; <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>,  <span class="string">'G'</span> &#125;;</span><br><span class="line">           <span class="keyword">int</span>[][] graphEdgesValues = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123; INF, <span class="number">5</span>, <span class="number">7</span>,  INF, INF, INF, <span class="number">2</span> &#125;, &#123; <span class="number">5</span>, INF, INF, <span class="number">9</span>, INF, INF, <span class="number">3</span> &#125;,</span><br><span class="line">                     &#123; <span class="number">7</span>, INF, INF, INF, <span class="number">8</span>, INF, INF &#125;, &#123; INF,  <span class="number">9</span>, INF, INF, INF, <span class="number">4</span>, INF &#125;, &#123; INF, INF, <span class="number">8</span>, INF, INF, <span class="number">5</span>, <span class="number">4</span> &#125;,</span><br><span class="line">                     &#123; INF, INF, INF, <span class="number">4</span>, <span class="number">5</span>, INF, <span class="number">6</span> &#125;, &#123; <span class="number">2</span>, <span class="number">3</span>,  INF, INF, <span class="number">4</span>, <span class="number">6</span>, INF &#125;, &#125;;</span><br><span class="line">           Graph graph = <span class="keyword">new</span> Graph(vertexArray.length,  vertexArray, graphEdgesValues);</span><br><span class="line">           graph.floyd();</span><br><span class="line">           graph.showGraph();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 图的顶点数</span></span><br><span class="line">     <span class="keyword">int</span> graphVertexNum;</span><br><span class="line">     <span class="comment">// 图的顶点数组</span></span><br><span class="line">     <span class="keyword">char</span>[] graphVertexValues;</span><br><span class="line">     <span class="comment">// 图的顶点之间的距离二维数组</span></span><br><span class="line">     <span class="keyword">int</span>[][] graphVertexDistance;</span><br><span class="line">     <span class="comment">// 图的前驱顶点的二维数组</span></span><br><span class="line">     <span class="keyword">int</span>[][] graphVertexPreNode;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> vNum, <span class="keyword">char</span>[] vertexArray, <span class="keyword">int</span>[][] Matrix)</span>  </span>&#123;</span><br><span class="line">           <span class="comment">// 初始化数组的长度</span></span><br><span class="line">           <span class="keyword">this</span>.graphVertexNum = vNum;</span><br><span class="line">           <span class="keyword">this</span>.graphVertexValues = <span class="keyword">new</span> <span class="keyword">char</span>[graphVertexNum];</span><br><span class="line">           <span class="keyword">this</span>.graphVertexDistance = <span class="keyword">new</span>  <span class="keyword">int</span>[graphVertexNum][graphVertexNum];</span><br><span class="line">           <span class="keyword">this</span>.graphVertexPreNode = <span class="keyword">new</span>  <span class="keyword">int</span>[graphVertexNum][graphVertexNum];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graphVertexNum; i++) &#123;</span><br><span class="line">                <span class="keyword">this</span>.graphVertexValues[i] = vertexArray[i];</span><br><span class="line">                <span class="comment">//给每一个起始点对应其他顶点的前驱顶点赋值</span></span><br><span class="line">                Arrays.fill(graphVertexPreNode[i], i);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphVertexNum; j++) &#123;</span><br><span class="line">                     graphVertexDistance[i][j] = Matrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 显示图的效果</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graphVertexNum; i++) &#123;</span><br><span class="line">                <span class="comment">// 显示起始顶点到达的终点顶点的前驱顶点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphVertexNum; j++) &#123;</span><br><span class="line">                     System.out.print(graphVertexValues[graphVertexPreNode[i][j]]+<span class="string">"\t"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="comment">// 显示起始点到达其他顶点的最短路径长度</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; graphVertexNum; k++) &#123;</span><br><span class="line">                     System.out.print(graphVertexValues[i] +  <span class="string">"-&gt;"</span> + graphVertexValues[k] + <span class="string">" :"</span> + graphVertexDistance[i][k]+<span class="string">"  | "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"\n"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//弗洛伊德算法核心代码</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//第一层循环,遍历中间顶点</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;graphVertexNum;k++) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//第二层循环,遍历起始顶点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graphVertexNum;i++) &#123;</span><br><span class="line">                     <span class="comment">//第三层循环,遍历终点顶点</span></span><br><span class="line">                     <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;graphVertexNum;j++) &#123;</span><br><span class="line">                           <span class="comment">//记录从起始顶点经中间顶点到终点顶点的路径长度</span></span><br><span class="line">                           <span class="keyword">int</span>  len=graphVertexDistance[i][k]+graphVertexDistance[k][j];</span><br><span class="line">                           <span class="keyword">if</span>(len&lt;graphVertexDistance[i][j]) &#123;</span><br><span class="line">                                graphVertexDistance[i][j]=len;</span><br><span class="line">                                <span class="comment">//更新前驱顶点</span></span><br><span class="line">                                graphVertexPreNode[i][j]=graphVertexPreNode[k][j];</span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法-迪杰斯特拉算法-最短路径问题</title>
      <link>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</link>
      <guid>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Tue, 28 Jul 2020 10:22:36 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;迪杰斯特拉算法介绍&quot;&gt;&lt;a href=&quot;#迪杰斯特拉算法介绍&quot; class=&quot;headerlink&quot; title=&quot;迪杰斯特拉算法介绍&quot;&gt;&lt;/a&gt;迪杰斯特拉算法介绍&lt;/h3&gt;&lt;p&gt;迪杰斯特拉算法是典型的最短路径算法，用于计算一个节点到其他节点的最短路径，它的主要特点是以起始点为中心向外层以广度优先搜索思想扩展，直到扩展到终点为止。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="迪杰斯特拉算法介绍"><a href="#迪杰斯特拉算法介绍" class="headerlink" title="迪杰斯特拉算法介绍"></a>迪杰斯特拉算法介绍</h3><p>迪杰斯特拉算法是典型的最短路径算法，用于计算一个节点到其他节点的最短路径，它的主要特点是以起始点为中心向外层以广度优先搜索思想扩展，直到扩展到终点为止。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>迪杰斯特拉算法步骤：</p><ol><li>设置出发顶点为v，顶点集合V{v1,v2,vi…},v到V中各顶点的距离构成距离集合Dis,Dis{d1,d2,di…},Dis集合记录着v到途中各顶点的距离(到自身看作0，v到vi距离对应为di)；</li><li>从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi，此时的v到vi即为最短路径；</li><li>更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值比较小的一个，同时更新顶点的前驱节点为vi，表明是通过vi到达的；</li><li>重复执行步骤2和步骤3，直到最短路径顶点为目标顶点即可结束。</li></ol><p>问题实例：</p><ol><li>有7个村庄（A,B,C,D,E,F,G），现在需要求村庄G到其他村庄路径最短距离？</li></ol><p><img src="/images/algorithm_img/road.png" alt="村庄"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/24</span></span><br><span class="line"><span class="comment">* @功能：使用迪杰斯特拉算法解决顶点到各个点最短路径的求法问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> dijkstra;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DijkstraAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = <span class="number">65535</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] graphVertexValues = &#123; <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] graphEdgesValues = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123; INF, <span class="number">5</span>, <span class="number">7</span>, INF, INF, INF, <span class="number">2</span> &#125;, &#123; <span class="number">5</span>, INF, INF, <span class="number">9</span>, INF, INF, <span class="number">3</span> &#125;,</span><br><span class="line">                &#123; <span class="number">7</span>, INF, INF, INF, <span class="number">8</span>, INF, INF &#125;, &#123; INF, <span class="number">9</span>, INF, INF, INF, <span class="number">4</span>, INF &#125;, &#123; INF, INF, <span class="number">8</span>, INF, INF, <span class="number">5</span>, <span class="number">4</span> &#125;,</span><br><span class="line">                &#123; INF, INF, INF, <span class="number">4</span>, <span class="number">5</span>, INF, <span class="number">6</span> &#125;, &#123; <span class="number">2</span>, <span class="number">3</span>, INF, INF, <span class="number">4</span>, <span class="number">6</span>, INF &#125;, &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        DijkstraMethod dij = <span class="keyword">new</span> DijkstraMethod(graphVertexValues, graphEdgesValues, <span class="number">0</span>);</span><br><span class="line">        dij.showGraph();</span><br><span class="line">        <span class="comment">// 调用迪杰斯特拉算法求得顶点到各点的最短路径</span></span><br><span class="line">        dij.dijkstra();</span><br><span class="line">        <span class="comment">// 显示结果</span></span><br><span class="line">        dij.result();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义类封装迪杰斯特拉相关方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DijkstraMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    Graph graph;</span><br><span class="line">    <span class="comment">// 定义顶点访问数组</span></span><br><span class="line">    <span class="keyword">int</span>[] visited;</span><br><span class="line">    <span class="comment">// 定义初始点到各点距离数组</span></span><br><span class="line">    <span class="keyword">int</span>[] distance;</span><br><span class="line">    <span class="comment">// 定义各顶点的前驱顶点</span></span><br><span class="line">    <span class="keyword">int</span>[] preVertex;</span><br><span class="line">    <span class="comment">// 开始顶点</span></span><br><span class="line">    <span class="keyword">int</span> beginIndex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DijkstraMethod</span><span class="params">(<span class="keyword">char</span>[] graphVertexValues, <span class="keyword">int</span>[][] graphEdgesValues, <span class="keyword">int</span> beginVertex)</span> </span>&#123;</span><br><span class="line">        graph = <span class="keyword">new</span> Graph(graphVertexValues, graphEdgesValues);</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">int</span>[graph.graphVertexNum];</span><br><span class="line">        distance = <span class="keyword">new</span> <span class="keyword">int</span>[graph.graphVertexNum];</span><br><span class="line">        preVertex = <span class="keyword">new</span> <span class="keyword">int</span>[graph.graphVertexNum];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (beginVertex &lt; <span class="number">0</span> || beginVertex &gt;= graph.graphVertexNum) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"beginVertex out of range!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化开始节点各数组情况</span></span><br><span class="line">        <span class="comment">// 初始顶点已访问</span></span><br><span class="line">        <span class="keyword">this</span>.beginIndex = beginVertex;</span><br><span class="line">        visited[beginVertex] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 初始化距离数组的数值</span></span><br><span class="line">        Arrays.fill(distance, <span class="number">65535</span>);</span><br><span class="line">        distance[beginVertex] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        graph.showGraph();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dijkstra核心代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 更新开始点的距离数组等信息</span></span><br><span class="line">        updateMessage(beginIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; graph.graphVertexNum; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curIndex = getNextVertexIndex();</span><br><span class="line">            <span class="comment">// 更新开始点关联的其他点的距离数组等信息</span></span><br><span class="line">            updateMessage(curIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得下一个访问顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextVertexIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, minValue = <span class="number">65535</span>;</span><br><span class="line">        <span class="comment">// 遍历每一个顶点对应的其他顶点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.graphVertexNum; i++) &#123;</span><br><span class="line">            <span class="comment">// 若未访问且距离小于minValue</span></span><br><span class="line">            <span class="keyword">if</span> (visited[i] != <span class="number">1</span> &amp;&amp; distance[i] &lt; minValue) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                minValue = distance[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 选中访问的顶点,则标志为已经访问</span></span><br><span class="line">        visited[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新每一个顶点对应的前驱顶点数组,访问数组,距离数组的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateMessage</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.graphEdgesValues[index].length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = distance[index] + graph.graphEdgesValues[index][i];</span><br><span class="line">            <span class="keyword">if</span> (len &lt; distance[i] &amp;&amp; visited[i] != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 若当前距离可达则更新当前点到其他点的距离数组</span></span><br><span class="line">                distance[i] = len;</span><br><span class="line">                <span class="comment">// 且更新前驱顶点</span></span><br><span class="line">                preVertex[i] = index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示迪杰斯特拉算法的结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.graphVertexValues.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"顶点"</span> + graph.graphVertexValues[beginIndex] + <span class="string">"距离"</span> + graph.graphVertexValues[i] + <span class="string">"的距离为："</span></span><br><span class="line">                    + distance[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义图的属性类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 图顶点的个数</span></span><br><span class="line">    <span class="keyword">int</span> graphVertexNum;</span><br><span class="line">    <span class="comment">// 存放图顶点的数组</span></span><br><span class="line">    <span class="keyword">char</span>[] graphVertexValues;</span><br><span class="line">    <span class="comment">// 存放图中边的权值的邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span>[][] graphEdgesValues;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法初始化顶点及边的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">char</span>[] graphVertexValues, <span class="keyword">int</span>[][] graphEdgesValues)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.graphVertexNum = graphVertexValues.length;</span><br><span class="line">        <span class="keyword">this</span>.graphVertexValues = <span class="keyword">new</span> <span class="keyword">char</span>[graphVertexNum];</span><br><span class="line">        <span class="keyword">this</span>.graphEdgesValues = <span class="keyword">new</span> <span class="keyword">int</span>[graphVertexNum][graphVertexNum];</span><br><span class="line">        <span class="comment">// 初始化图顶点数组及图中边的权值的邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graphVertexNum; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.graphVertexValues[i] = graphVertexValues[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphVertexNum; j++) &#123;</span><br><span class="line">                <span class="keyword">this</span>.graphEdgesValues[i][j] = graphEdgesValues[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"**********************************GraphMatrix****************************************"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graphVertexNum; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphVertexNum; j++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%12d"</span>, graphEdgesValues[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"*************************************************************************************"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法-克鲁斯卡尔算法-最小生成树</title>
      <link>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link>
      <guid>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</guid>
      <pubDate>Tue, 28 Jul 2020 10:22:01 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;克鲁斯卡尔算法介绍&quot;&gt;&lt;a href=&quot;#克鲁斯卡尔算法介绍&quot; class=&quot;headerlink&quot; title=&quot;克鲁斯卡尔算法介绍&quot;&gt;&lt;/a&gt;克鲁斯卡尔算法介绍&lt;/h3&gt;&lt;p&gt;克鲁斯卡尔算法是求连通网的最小生成树的另一种方法。与普里姆算法不同，它的时间复杂度为O（eloge）（e为网中的边数），所以，适合于求边稀疏的网的最小生成树。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="克鲁斯卡尔算法介绍"><a href="#克鲁斯卡尔算法介绍" class="headerlink" title="克鲁斯卡尔算法介绍"></a>克鲁斯卡尔算法介绍</h3><p>克鲁斯卡尔算法是求连通网的最小生成树的另一种方法。与普里姆算法不同，它的时间复杂度为O（eloge）（e为网中的边数），所以，适合于求边稀疏的网的最小生成树。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>克鲁斯卡尔算法步骤：</p><ol><li>按照边的权值从小到大顺序排序；</li><li>从排好顺序的边从小到大选择，选择最小的边加入森林中，但前提是加入的边在森林中不构成回路，直到森林变成一棵树为止。</li></ol><p>应用场景问题：</p><ol><li>某城市有7个公交站点(A,B,C,D,E,F,G)，现在需要修路把7个站点连通，站点之间的距离表示权值；</li><li>如何修路既能保证各站点连通且修建里程最短。</li></ol><p>公交站站点示意图：</p><p><img src="/images/algorithm_img/kruskal/kruskal.jpg" alt="公交站"></p><p><strong>代码难点：</strong><br>如何判断俩个顶点的终点索引相同，即如何判断是否产生回路？</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/23</span></span><br><span class="line"><span class="comment">* @功能：利用克鲁斯卡尔算法思想解决公交站里程问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> kruskal;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalAlgorithmDemo</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义边的最大值,表示俩顶点之间不可达</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义顶点的值</span></span><br><span class="line">           <span class="keyword">char</span>[] vertexValues = &#123; <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>,  <span class="string">'G'</span> &#125;;</span><br><span class="line">           <span class="comment">// 定义顶点与顶点之间的关系</span></span><br><span class="line">           <span class="keyword">int</span>[][] edgesValueMatrix = &#123;</span><br><span class="line">                                <span class="comment">/* A */</span><span class="comment">/* B */</span><span class="comment">/* C */</span><span class="comment">/* D */</span><span class="comment">/* E  */</span><span class="comment">/* F */</span><span class="comment">/* G */</span></span><br><span class="line">                     <span class="comment">/* A */</span> &#123; <span class="number">0</span>, <span class="number">12</span>, INF, INF, INF, <span class="number">16</span>, <span class="number">14</span> &#125;,</span><br><span class="line">                     <span class="comment">/* B */</span> &#123; <span class="number">12</span>, <span class="number">0</span>, <span class="number">10</span>, INF, INF, <span class="number">7</span>, INF &#125;,</span><br><span class="line">                     <span class="comment">/* C */</span> &#123; INF, <span class="number">10</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, INF &#125;,</span><br><span class="line">                     <span class="comment">/* D */</span> &#123; INF, INF, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, INF, INF &#125;,</span><br><span class="line">                     <span class="comment">/* E */</span> &#123; INF, INF, <span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span> &#125;,</span><br><span class="line">                     <span class="comment">/* F */</span> &#123; <span class="number">16</span>, <span class="number">7</span>, <span class="number">6</span>, INF, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span> &#125;,</span><br><span class="line">                     <span class="comment">/* G */</span> &#123; <span class="number">14</span>, INF, INF, INF, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span> &#125; &#125;;</span><br><span class="line">           <span class="comment">// 初始化图的顶点及边关系</span></span><br><span class="line">           CreateGraph graph = <span class="keyword">new</span>  CreateGraph(vertexValues.length, vertexValues,edgesValueMatrix);</span><br><span class="line">           graph.showGraphMatrix();</span><br><span class="line">           <span class="comment">//将所有边存入数组</span></span><br><span class="line">           graph.setEdgesArray();</span><br><span class="line">           System.out.println(<span class="string">"********************Min  Tree*************************"</span>);</span><br><span class="line">           graph.kruskal();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateGraph</span> </span>&#123;</span><br><span class="line">     <span class="comment">//定义图类的变量</span></span><br><span class="line">     DefinitionGraph graph;</span><br><span class="line">     <span class="comment">//定义边类的变量</span></span><br><span class="line">     DefinitionEdge edge;</span><br><span class="line">     <span class="comment">// 定义边的最大值,表示俩顶点之间不可达</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line">     <span class="comment">//统计边的数量</span></span><br><span class="line">     <span class="keyword">int</span> edgesCount;</span><br><span class="line">     <span class="comment">//定义存放边的数组</span></span><br><span class="line">     DefinitionEdge[] edgesArray;</span><br><span class="line">     <span class="comment">// 在构造方法中初始化图中边及顶点的属性,同时统计边的条数</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">CreateGraph</span><span class="params">(<span class="keyword">int</span> vertexNum, <span class="keyword">char</span>[] vertexValues,  <span class="keyword">int</span>[][] edgesValueMatrix)</span> </span>&#123;</span><br><span class="line">           graph = <span class="keyword">new</span> DefinitionGraph(vertexNum);</span><br><span class="line">           <span class="comment">// 给边及顶点赋值</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.vertexNum; i++) &#123;</span><br><span class="line">                graph.vertexValues[i] = vertexValues[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph.vertexNum; j++) &#123;</span><br><span class="line">                     graph.edgesValueMatrix[i][j] =  edgesValueMatrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 统计边的条数及存放边的数组</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.vertexNum; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; graph.vertexNum; j++) &#123;</span><br><span class="line">                     <span class="keyword">if</span>(graph.edgesValueMatrix[i][j]!=INF) &#123;</span><br><span class="line">                           edgesCount++;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           graph.graphEdgeNum=edgesCount;</span><br><span class="line">           </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 显示邻接矩阵</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraphMatrix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"**********************************GraphMatrix****************************************"</span>);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.vertexNum; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph.vertexNum; j++) &#123;</span><br><span class="line">                     System.out.printf(<span class="string">"%12d"</span>,  graph.edgesValueMatrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">"*************************************************************************************"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//显示边的条数</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEdgeNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> graph.graphEdgeNum;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//定义存放边的数组,将来对这个数组进行排序</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEdgesArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//定义存放边的数组</span></span><br><span class="line">           edgesArray=<span class="keyword">new</span> DefinitionEdge[getEdgeNum()];</span><br><span class="line">           <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.vertexNum; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; graph.vertexNum; j++) &#123;</span><br><span class="line">                     <span class="keyword">if</span>(graph.edgesValueMatrix[i][j]!=INF) &#123;</span><br><span class="line">                           edgesArray[count++]=<span class="keyword">new</span>  DefinitionEdge(graph.vertexValues[i], graph.vertexValues[j],  graph.edgesValueMatrix[i][j]);</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//遍历边的数量</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showEdgesArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;getEdgeNum();i++) &#123;</span><br><span class="line">                System.out.println(edgesArray[i]);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//对边的数组进行升序排序</span></span><br><span class="line">     DefinitionEdge curEdge=<span class="keyword">null</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortEdgesArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;getEdgeNum()-<span class="number">1</span>;i++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;getEdgeNum()-<span class="number">1</span>-i;j++) &#123;</span><br><span class="line">                     <span class="keyword">if</span>(edgesArray[j].curEdgesValues&gt;edgesArray[j+<span class="number">1</span>].curEdgesValues)  &#123;</span><br><span class="line">                           curEdge=edgesArray[j];</span><br><span class="line">                           edgesArray[j]=edgesArray[j+<span class="number">1</span>];</span><br><span class="line">                           edgesArray[j+<span class="number">1</span>]=curEdge;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//获得当前顶点的下标</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurVertexIndex</span><span class="params">(<span class="keyword">char</span> v)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.vertexNum;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(graph.vertexValues[i]==v) &#123;</span><br><span class="line">                     <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//设置当前顶点的终点节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEndVertexIndex</span><span class="params">(<span class="keyword">int</span>[] end,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">while</span>(end[index]!=<span class="number">0</span>) &#123;<span class="comment">//若当前顶点的终点索引为0则返回自己的索引</span></span><br><span class="line">                index= end[index];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> index;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     <span class="comment">//克鲁斯卡尔算法核心代码</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//先对边的权值排序</span></span><br><span class="line">           sortEdgesArray();</span><br><span class="line">           <span class="comment">//定义顶点的终点索引数组</span></span><br><span class="line">           <span class="keyword">int</span>[] end=<span class="keyword">new</span> <span class="keyword">int</span>[getEdgeNum()];</span><br><span class="line">           <span class="comment">//定义构成图最小生成树所需的边数</span></span><br><span class="line">           <span class="keyword">int</span> edgesCount=<span class="number">0</span>;</span><br><span class="line">           </span><br><span class="line">           DefinitionEdge[] minTree=<span class="keyword">new</span>  DefinitionEdge[getEdgeNum()];</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;getEdgeNum();i++) &#123;</span><br><span class="line">                <span class="comment">//获得当前边一个点的下标</span></span><br><span class="line">                <span class="keyword">int</span>  startVertex=getCurVertexIndex(edgesArray[i].curVertex);</span><br><span class="line">                <span class="comment">//获得当前边的另一个顶点下标</span></span><br><span class="line">                <span class="keyword">int</span>  endVErtex=getCurVertexIndex(edgesArray[i].nextVertex);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//获得当前边俩个顶点的终点下标</span></span><br><span class="line">                <span class="keyword">int</span> v1_end=getEndVertexIndex(end, startVertex);</span><br><span class="line">                <span class="keyword">int</span> v2_end=getEndVertexIndex(end, endVErtex);</span><br><span class="line">                <span class="comment">//终点下标不相等,即不构成回路</span></span><br><span class="line">                <span class="keyword">if</span>(v1_end!=v2_end) &#123;</span><br><span class="line">                     minTree[edgesCount++]=edgesArray[i];</span><br><span class="line">                     end[v1_end]=v2_end;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//构成回路则不添加</span></span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edgesCount;i++) &#123;</span><br><span class="line">                System.out.println(minTree[i]);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义边的属性类,该类的实例化对象为一条边</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefinitionEdge</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义当前边的一个顶点</span></span><br><span class="line">     <span class="keyword">char</span> curVertex;</span><br><span class="line">     <span class="comment">// 定义当前边的下一个顶点</span></span><br><span class="line">     <span class="keyword">char</span> nextVertex;</span><br><span class="line">     <span class="comment">// 定义俩顶点之间边的权值</span></span><br><span class="line">     <span class="keyword">int</span> curEdgesValues;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">DefinitionEdge</span><span class="params">(<span class="keyword">char</span> curv, <span class="keyword">char</span> nextv, <span class="keyword">int</span> values)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.curVertex = curv;</span><br><span class="line">           <span class="keyword">this</span>.nextVertex = nextv;</span><br><span class="line">           <span class="keyword">this</span>.curEdgesValues = values;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"edge &lt;"</span> + curVertex + <span class="string">", "</span> + nextVertex + <span class="string">"&gt;  edgesValues="</span> + curEdgesValues;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义的图属性类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefinitionGraph</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义顶点个数</span></span><br><span class="line">     <span class="keyword">int</span> vertexNum;</span><br><span class="line">     <span class="comment">// 定义存储顶点值的数组</span></span><br><span class="line">     <span class="keyword">char</span>[] vertexValues;</span><br><span class="line">     <span class="comment">// 定义存储顶点与顶点之间权值的邻接矩阵</span></span><br><span class="line">     <span class="keyword">int</span>[][] edgesValueMatrix;</span><br><span class="line">     <span class="comment">// 定义图的边数</span></span><br><span class="line">     <span class="keyword">int</span> graphEdgeNum;</span><br><span class="line">     <span class="comment">// 构造方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">DefinitionGraph</span><span class="params">(<span class="keyword">int</span> vertexNums)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.vertexNum = vertexNums;</span><br><span class="line">           vertexValues = <span class="keyword">new</span> <span class="keyword">char</span>[vertexNum];</span><br><span class="line">           edgesValueMatrix = <span class="keyword">new</span> <span class="keyword">int</span>[vertexNum][vertexNum];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法-普利姆算法-最小生成树</title>
      <link>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link>
      <guid>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</guid>
      <pubDate>Tue, 28 Jul 2020 10:21:29 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;普利姆算法介绍&quot;&gt;&lt;a href=&quot;#普利姆算法介绍&quot; class=&quot;headerlink&quot; title=&quot;普利姆算法介绍&quot;&gt;&lt;/a&gt;普利姆算法介绍&lt;/h3&gt;&lt;p&gt;普里姆算法（Prim算法），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点（英语：Vertex (graph theory)），且其所有边的权值之和亦为最小。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="普利姆算法介绍"><a href="#普利姆算法介绍" class="headerlink" title="普利姆算法介绍"></a>普利姆算法介绍</h3><p>普里姆算法（Prim算法），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点（英语：Vertex (graph theory)），且其所有边的权值之和亦为最小。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>普利姆算法步骤如下：</p><ol><li>设G=(V,E)是连通图，T=(U,D)是最小生成树,V,U是顶点集合,E,D是边的集合；</li><li>若从顶点u开始构造最小生成树，则从集合V中取出顶点放入集合U中，标记顶点v的visited[u]=1;</li><li>若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边(ui，vj)加入集合D中，标记visited[vj]=1;</li><li>重复步骤2，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边；</li></ol><p>应用场景-修路问题：</p><ol><li>有7个村庄（A,B,C,D,E,F,G），现在需要修路把7个村庄连通；</li><li>各个村庄的距离用边线表示(权)，比如A-B距离5公里；</li><li>问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短？</li></ol><p><img src="/images/algorithm_img/road.png" alt="路"></p><p>修路问题本质就是最小生成树问题(Minimun Cost Spanning Tree),简称MST，给定一个带权的无向连通图，如何选取一棵生成树使得树上的所有边上权的总和为最小，这叫最小生成树。</p><ol><li>N个顶点，一定有N-1条边</li><li>包含全部顶点</li><li>N-1条边都在图中</li></ol><p>图的邻接矩阵：<br><img src="/images/algorithm_img/roadMatrix.png" alt="图的邻接矩阵"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/23</span></span><br><span class="line"><span class="comment">* @功能：利用普利姆算法思想解决修路问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> prim;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimAlgorithm</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义边的最大值,表示俩顶点之间不可达</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义顶点的值</span></span><br><span class="line">           <span class="keyword">char</span>[] vertexs = &#123; <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>  &#125;;</span><br><span class="line">           <span class="comment">// 定义顶点的个数</span></span><br><span class="line">           <span class="keyword">int</span> vertexNum = vertexs.length;</span><br><span class="line">           DefinitionGraph graph = <span class="keyword">new</span>  DefinitionGraph(vertexNum);</span><br><span class="line">          <span class="keyword">int</span>[][] graphMatrix = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123; INF, <span class="number">5</span>, <span class="number">7</span>, INF, INF, INF,  <span class="number">2</span> &#125;,</span><br><span class="line">                     &#123; <span class="number">5</span>, INF, INF, <span class="number">9</span>, INF, INF, <span class="number">3</span> &#125;, &#123; <span class="number">7</span>, INF,  INF, INF, <span class="number">8</span>, INF, INF &#125;,</span><br><span class="line">                     &#123; INF, <span class="number">9</span>, INF, INF, INF, <span class="number">4</span>, INF &#125;, &#123; INF,  INF, <span class="number">8</span>, INF, INF, <span class="number">5</span>, <span class="number">4</span> &#125;,</span><br><span class="line">                     &#123; INF, INF, INF, <span class="number">4</span>, <span class="number">5</span>, INF, <span class="number">6</span> &#125;, &#123; <span class="number">2</span>, <span class="number">3</span>,  INF, INF, <span class="number">4</span>, <span class="number">6</span>, INF &#125;, &#125;;</span><br><span class="line">           createMinimumCostSpanningTree minTree = <span class="keyword">new</span>  createMinimumCostSpanningTree();</span><br><span class="line">           <span class="comment">// 初始化图的各顶点值及边的值</span></span><br><span class="line">           minTree.createGraphMatrix(graph, vertexNum, vertexs,  graphMatrix);</span><br><span class="line">           <span class="comment">// 输出邻接矩阵</span></span><br><span class="line">           minTree.showgraphMatrix(graph);</span><br><span class="line">           <span class="comment">// 输出构造最小生成树的过程</span></span><br><span class="line">           minTree.minTree(graph, <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">createMinimumCostSpanningTree</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 生成图的邻接矩阵</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createGraphMatrix</span><span class="params">(DefinitionGraph graph, <span class="keyword">int</span>  graphVertexNum, <span class="keyword">char</span>[] vertexValue, <span class="keyword">int</span>[][] graphMatrix)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graphVertexNum; i++) &#123;</span><br><span class="line">                <span class="comment">// 给每个顶点赋值</span></span><br><span class="line">                graph.vertexValue[i] = vertexValue[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphVertexNum; j++) &#123;</span><br><span class="line">                     <span class="comment">// 给边与边之间加上权值</span></span><br><span class="line">                     graph.graphMatrix[i][j] =  graphMatrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 显示图的邻接矩阵</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showgraphMatrix</span><span class="params">(DefinitionGraph graph)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span>[] row : graph.graphMatrix) &#123;</span><br><span class="line">                System.out.println(Arrays.toString(row));</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 显示最小连同图的路径</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">minTree</span><span class="params">(DefinitionGraph graph, <span class="keyword">int</span>  beginVertex)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义当前顶点的索引</span></span><br><span class="line">           <span class="keyword">int</span> curVertexIndex = -<span class="number">1</span>;</span><br><span class="line">           <span class="comment">// 定义当前顶点的下一个连同顶点的索引</span></span><br><span class="line">           <span class="keyword">int</span> curVertexNextIndex = -<span class="number">1</span>;</span><br><span class="line">           <span class="comment">// 定义顶点被访问的标识</span></span><br><span class="line">           <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span>  <span class="keyword">boolean</span>[graph.graphVertexNum];</span><br><span class="line">           <span class="comment">// 首先先标明当前的顶点已经被访问</span></span><br><span class="line">           visited[beginVertex] = <span class="keyword">true</span>;</span><br><span class="line">           <span class="comment">// 定义边的最小权值</span></span><br><span class="line">           <span class="keyword">int</span> minEdgeValue;</span><br><span class="line">           <span class="comment">// 最外层循环输出图的最小权边的构造过程,边数为顶点数减一</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; graph.graphVertexNum; i++) &#123;</span><br><span class="line">                minEdgeValue = <span class="number">10000</span>;</span><br><span class="line">                <span class="comment">// 里面俩层循环遍历邻接矩阵得到当前点的最小权值的边</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph.graphVertexNum; j++) &#123;</span><br><span class="line">                     <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; graph.graphVertexNum;  k++) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (visited[j] == <span class="keyword">true</span> &amp;&amp; visited[k]  == <span class="keyword">false</span> &amp;&amp; graph.graphMatrix[j][k] &lt; minEdgeValue) &#123;</span><br><span class="line">                                curVertexIndex = j;</span><br><span class="line">                                curVertexNextIndex = k;</span><br><span class="line">                                minEdgeValue =  graph.graphMatrix[j][k];</span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(</span><br><span class="line">                           <span class="string">"第"</span> + i + <span class="string">"条边：&lt; "</span> +  graph.vertexValue[curVertexIndex] + <span class="string">","</span> +  graph.vertexValue[curVertexNextIndex] + <span class="string">"&gt; ,边的权值为： "</span> +  minEdgeValue);</span><br><span class="line">                visited[curVertexNextIndex] = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefinitionGraph</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义图的顶点个数</span></span><br><span class="line">     <span class="keyword">int</span> graphVertexNum;</span><br><span class="line">     <span class="comment">// 定义顶点</span></span><br><span class="line">     <span class="keyword">char</span>[] vertexValue;</span><br><span class="line">     <span class="comment">// 定义邻接矩阵</span></span><br><span class="line">     <span class="keyword">int</span>[][] graphMatrix;</span><br><span class="line">     <span class="comment">// DefinitionGraph的构造方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">DefinitionGraph</span><span class="params">(<span class="keyword">int</span> graphVertexNum)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.graphVertexNum = graphVertexNum;</span><br><span class="line">           vertexValue = <span class="keyword">new</span> <span class="keyword">char</span>[graphVertexNum];</span><br><span class="line">           graphMatrix = <span class="keyword">new</span>  <span class="keyword">int</span>[graphVertexNum][graphVertexNum];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法-贪心算法-集合覆盖问题</title>
      <link>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E9%9B%86%E5%90%88%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/</link>
      <guid>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E9%9B%86%E5%90%88%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Tue, 28 Jul 2020 10:20:55 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;贪心算法介绍&quot;&gt;&lt;a href=&quot;#贪心算法介绍&quot; class=&quot;headerlink&quot; title=&quot;贪心算法介绍&quot;&gt;&lt;/a&gt;贪心算法介绍&lt;/h3&gt;&lt;p&gt;贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="贪心算法介绍"><a href="#贪心算法介绍" class="headerlink" title="贪心算法介绍"></a>贪心算法介绍</h3><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>贪心算法一般按如下步骤进行：</p><ol><li>建立数学模型来描述问题；</li><li>把求解的问题分成若干个子问题；</li><li>对每个子问题求解，得到子问题的局部最优解，可能不是最优解；</li><li>把子问题的解局部最优解合成原来解问题的一个解。</li></ol><p>集合覆盖问题：<br>存在以下表的广播台覆盖的地区，如何让选择最少的广播台让更多的地区接收到信号？<br><img src="/images/algorithm_img/greedy/broadcastSet.png" alt="广播站覆盖地区"></p><p>步骤分析：</p><ol><li>先获取到所有广播台的所有地区序列 allAreas { 北京、上海、天津、广州、深圳、成都、杭州、大连 }；</li><li>定义最大地区匹配值maxAreaNum，循环拿到每个广播台对应覆盖地区与allAreas取交集，如果下一个广播台的areaNum&gt;maxAreaNum,则令当前广播台为最大maxAreaNum；</li><li>一个循环结束，将所有地区序列allAreas中包含maxAreaNum对应的地区清楚，同时将最大覆盖地区的广播台放入选择集合；</li><li>拿到新的地区序列，继续重复步骤2和步骤3。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/21</span></span><br><span class="line"><span class="comment">* @fuction:利用贪心算法思想完成集合覆盖问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> greedy;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreedyAlgorithm</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义广播台HashMap键值对集合,String是广播台,HashSet存放地区</span></span><br><span class="line">           HashMap&lt;String, HashSet&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span>  HashMap&lt;String, HashSet&lt;String&gt;&gt;();</span><br><span class="line">           <span class="comment">// 广播台K1</span></span><br><span class="line">           HashSet&lt;String&gt; area1 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           area1.add(<span class="string">"北京"</span>);</span><br><span class="line">           area1.add(<span class="string">"上海"</span>);</span><br><span class="line">           area1.add(<span class="string">"天津"</span>);</span><br><span class="line">           <span class="comment">// 广播台K2</span></span><br><span class="line">           HashSet&lt;String&gt; area2 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           area2.add(<span class="string">"广州"</span>);</span><br><span class="line">           area2.add(<span class="string">"北京"</span>);</span><br><span class="line">           area2.add(<span class="string">"深圳"</span>);</span><br><span class="line">           <span class="comment">// 广播台K3</span></span><br><span class="line">           HashSet&lt;String&gt; area3 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           area3.add(<span class="string">"成都"</span>);</span><br><span class="line">           area3.add(<span class="string">"上海"</span>);</span><br><span class="line">           area3.add(<span class="string">"杭州"</span>);</span><br><span class="line">           <span class="comment">// 广播台K4</span></span><br><span class="line">           HashSet&lt;String&gt; area4 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           area4.add(<span class="string">"上海"</span>);</span><br><span class="line">           area4.add(<span class="string">"天津"</span>);</span><br><span class="line">           <span class="comment">// 广播台K5</span></span><br><span class="line">           HashSet&lt;String&gt; area5 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           area5.add(<span class="string">"杭州"</span>);</span><br><span class="line">           area5.add(<span class="string">"大连"</span>);</span><br><span class="line">           broadcasts.put(<span class="string">"K1"</span>, area1);</span><br><span class="line">           broadcasts.put(<span class="string">"K2"</span>, area2);</span><br><span class="line">           broadcasts.put(<span class="string">"K3"</span>, area3);</span><br><span class="line">           broadcasts.put(<span class="string">"K4"</span>, area4);</span><br><span class="line">           broadcasts.put(<span class="string">"K5"</span>, area5);</span><br><span class="line">           <span class="comment">// 获得广播站所有城市的序列</span></span><br><span class="line">           HashSet&lt;String&gt; allAreas = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           String[] area = &#123; <span class="string">"北京"</span>, <span class="string">"上海"</span>, <span class="string">"天津"</span>, <span class="string">"广州"</span>, <span class="string">"深圳"</span>, <span class="string">"成都"</span>, <span class="string">"杭州"</span>, <span class="string">"大连"</span> &#125;;</span><br><span class="line">           <span class="keyword">for</span> (String s : area) &#123;</span><br><span class="line">                allAreas.add(s);</span><br><span class="line">           &#125;</span><br><span class="line">           Object[] result=setCoverProblem(allAreas,  broadcasts);</span><br><span class="line">           <span class="comment">// 输出最终选择结果</span></span><br><span class="line">           System.out.println(Arrays.toString(result));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Object[] setCoverProblem(HashSet&lt;String&gt;  allAreas, HashMap&lt;String, HashSet&lt;String&gt;&gt; broadcasts) &#123;</span><br><span class="line">           <span class="comment">// 选择的广播站集合</span></span><br><span class="line">           HashSet&lt;String&gt; selected = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           <span class="comment">// 展示存放城市序列的集合</span></span><br><span class="line">           HashSet&lt;String&gt; tempSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           <span class="comment">// 定义覆盖最多城市广播站</span></span><br><span class="line">           String maxBroadcast = <span class="string">""</span>;</span><br><span class="line">           <span class="comment">// allAreas不为空则继续循环</span></span><br><span class="line">           <span class="keyword">while</span> (allAreas.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                maxBroadcast = <span class="keyword">null</span>;</span><br><span class="line">                tempSet = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 遍历获得各个广播站的键</span></span><br><span class="line">                <span class="keyword">for</span> (String key : broadcasts.keySet()) &#123;</span><br><span class="line">                     <span class="comment">// 获得当前广播站键对应的城市集合</span></span><br><span class="line">                     tempSet = broadcasts.get(key);</span><br><span class="line">                     tempSet.retainAll(allAreas);</span><br><span class="line">                     <span class="comment">// 若当前遍历到的广播站的与所有城市序列交集大于0</span></span><br><span class="line">                     <span class="comment">// 且最大城市未赋值或者当前遍历到的广播站与所有城市序列的交集大于最大广播站城市序列</span></span><br><span class="line">                     <span class="keyword">if</span> (tempSet.size() &gt; <span class="number">0</span></span><br><span class="line">                                &amp;&amp; (maxBroadcast == <span class="keyword">null</span> ||  tempSet.size() &gt; broadcasts.get(maxBroadcast).size())) &#123;</span><br><span class="line">                           maxBroadcast = key;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (maxBroadcast != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// 当前循环的相对最优选择被选中</span></span><br><span class="line">                     selected.add(maxBroadcast);</span><br><span class="line">                     <span class="comment">// 删除当前所有城市序列的的被选中城市,准备进入下一次选择</span></span><br><span class="line">                     allAreas.removeAll(broadcasts.get(maxBroadcast));</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> selected.toArray();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E9%9B%86%E5%90%88%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法-KMP算法</title>
      <link>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/</link>
      <guid>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/</guid>
      <pubDate>Tue, 28 Jul 2020 10:20:24 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;KMP算法介绍&quot;&gt;&lt;a href=&quot;#KMP算法介绍&quot; class=&quot;headerlink&quot; title=&quot;KMP算法介绍&quot;&gt;&lt;/a&gt;KMP算法介绍&lt;/h3&gt;&lt;p&gt;KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作，简称KMP算法。&lt;br&gt;KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。&lt;br&gt;具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n)。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="KMP算法介绍"><a href="#KMP算法介绍" class="headerlink" title="KMP算法介绍"></a>KMP算法介绍</h3><p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作，简称KMP算法。<br>KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。<br>具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n)。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>BF(Brute Force)算法和KMP算法的对比：<br>BF算法步骤：</p><ol><li>BF算法通过暴力匹配的方式，让文本串和模式串的每一个字符匹配；</li><li>匹配成功，则同时让文本串和模式串的当前索引 i 和 j移动到下一个字符的位置；</li><li>匹配失败，则令j回到初始位置，i移动到不匹配的字符的下一个位置，即 i-j+1的位置。<br>缺点：匹配速度慢，i回溯的位置重复匹配，效率低。</li></ol><p>KMP算法步骤：<br>比较详细的一篇文章： <a href="https://www.cnblogs.com/zzuuoo666/p/9028287.html" target="_blank" rel="noopener">比较详细的KMP算法文章</a><br>相对BF算法解决的问题：</p><ol><li>主要不是让文本串的索引 i 回溯，而是让模式串的 j 依据最大长度表来改变 j 的值，让模式串移动匹配文本串。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>BF算法实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/21</span></span><br><span class="line"><span class="comment">* @function:bf算法,和kmp算法形成比对</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> kmp;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BFAlgorithm</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           String str1 = <span class="string">"BBC ABCDAB ABCDABCDABDE"</span>;</span><br><span class="line">           String str2 = <span class="string">"ABCDABD"</span>;</span><br><span class="line">           <span class="keyword">int</span> index = bf(str1, str2);</span><br><span class="line">           System.out.println(<span class="string">"index= "</span> + index);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bf</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//i为文本串索引,j为模式串索引</span></span><br><span class="line">           <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span>(i&lt;str1.length()&amp;&amp;j&lt;str2.length()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(str1.charAt(i)==str2.charAt(j)) &#123;</span><br><span class="line">                     i++;</span><br><span class="line">                     j++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                     i=i-j+<span class="number">1</span>;</span><br><span class="line">                     j=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当j等于str2的长度则返回在str1的首个字符匹配的索引</span></span><br><span class="line">                <span class="keyword">if</span>(j==str2.length()) &#123;</span><br><span class="line">                     <span class="keyword">return</span> i-j;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KMP算法实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/21</span></span><br><span class="line"><span class="comment">* @function:实现KMP算法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> kmp;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMPAlgorithm</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           String str1 = <span class="string">"BBC ABCDAB ABCDABCDABDE"</span>;</span><br><span class="line">           String str2 = <span class="string">"ABCDABD"</span>;</span><br><span class="line">           <span class="comment">//String str2 = "BBC";</span></span><br><span class="line">           <span class="keyword">int</span>[] table = matchTable(str2);</span><br><span class="line">           <span class="keyword">int</span> index = kmp(str1, str2, table);</span><br><span class="line">           System.out.println(<span class="string">"index= "</span> + index);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(String str1, String str2, <span class="keyword">int</span>[]  table)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str1.charAt(i) !=  str2.charAt(j)) &#123;</span><br><span class="line">                     <span class="comment">//若当前文本串索引的字符与模式串索引字符不匹配;</span></span><br><span class="line">                     <span class="comment">//则令j的值为最大长度表前一个匹配的最大前缀后缀长度匹配值;</span></span><br><span class="line">                     <span class="comment">//举例子：比如当前模式串最后一个字符D与文本串索引17的字符C不匹配,</span></span><br><span class="line">                     <span class="comment">//但是最大长度匹配表中字符串ABCDAB的前缀后缀最大匹配长度为2,</span></span><br><span class="line">                     <span class="comment">//则意味则模式串前俩个字符AB不必再与文本串第15,16索引匹配,直接向下移动当前j=6,j-2个位置,</span></span><br><span class="line">                     <span class="comment">//则现在模式串的前俩个字符AB刚好与文本串第15,16的索引AB对应,模式串从第2个索引C开始和文本串第17个索引开始匹配</span></span><br><span class="line">                     j = table[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">                     j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == str2.length()) &#123;</span><br><span class="line">                     <span class="comment">// j等于str2的长度则返回在str1中位置开头字符索引</span></span><br><span class="line">                     <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] matchTable(String str) &#123;</span><br><span class="line">           <span class="comment">// 定义匹配表数组</span></span><br><span class="line">           <span class="keyword">int</span>[] table = <span class="keyword">new</span> <span class="keyword">int</span>[str.length()];</span><br><span class="line">           <span class="comment">// 匹配字符串第一个字母的前缀后缀匹配为零</span></span><br><span class="line">           table[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str.charAt(i) != str.charAt(j))  &#123;</span><br><span class="line">                     j = table[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (str.charAt(i) == str.charAt(j)) &#123;</span><br><span class="line">                     j++;</span><br><span class="line">                &#125;</span><br><span class="line">                table[i] = j;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> table;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法-动态规划算法-0-1背包问题</title>
      <link>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95-0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</link>
      <guid>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95-0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Tue, 28 Jul 2020 10:19:58 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;动态规划算法介绍&quot;&gt;&lt;a href=&quot;#动态规划算法介绍&quot; class=&quot;headerlink&quot; title=&quot;动态规划算法介绍&quot;&gt;&lt;/a&gt;动态规划算法介绍&lt;/h3&gt;&lt;p&gt;将大问题划分为小问题进行解决，从而一步步获取最优解的算法，同分治算法类似，先求子问题，从子问题的解得到原问题的解；&lt;br&gt;区别：动态规划算法的子问题往往不是独立存在的，即下一个阶段的解建立于上一阶段的解的基础上&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="动态规划算法介绍"><a href="#动态规划算法介绍" class="headerlink" title="动态规划算法介绍"></a>动态规划算法介绍</h3><p>将大问题划分为小问题进行解决，从而一步步获取最优解的算法，同分治算法类似，先求子问题，从子问题的解得到原问题的解；<br>区别：动态规划算法的子问题往往不是独立存在的，即下一个阶段的解建立于上一阶段的解的基础上</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>动态规划算法解决0-1背包问题：<br>0-1背包问题的介绍：<br>给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。<br>待放入的物品重量及价值：<br><img src="/images/algorithm_img/dynamic/goods.png" alt="待放入物品"></p><p>策略数组：<br><img src="/images/algorithm_img/dynamic/strategyArray.png" alt="策略数组"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>0-1背包问题代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/21</span></span><br><span class="line"><span class="comment">* @function:动态规划算法实现0-1背包问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> dynamic;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnapsackProblem</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义各物品体积</span></span><br><span class="line">           <span class="keyword">int</span>[] itemWeight = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span> &#125;;</span><br><span class="line">           <span class="comment">// 定义各物品价值</span></span><br><span class="line">           <span class="keyword">int</span>[] itemValue = &#123; <span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span> &#125;;</span><br><span class="line">           <span class="comment">// 定义背包容量</span></span><br><span class="line">           <span class="keyword">int</span> weight = <span class="number">4</span>;</span><br><span class="line">           <span class="comment">// 定义物品数量</span></span><br><span class="line">           <span class="keyword">int</span> n = itemValue.length;</span><br><span class="line">           <span class="comment">// 定义二维数组表示当前容量或者当前物品背包拥有的物品最大价值</span></span><br><span class="line">           <span class="keyword">int</span>[][] val = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][weight + <span class="number">1</span>];</span><br><span class="line">           <span class="comment">// 定义二维数组中可放入的最大值标识</span></span><br><span class="line">           <span class="keyword">int</span>[][] sign = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][weight + <span class="number">1</span>];</span><br><span class="line">           <span class="comment">// 将二维数组第0行和二维数组第0列置为0</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; val.length; i++) &#123;</span><br><span class="line">                val[i][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">// 将第0列置零</span></span><br><span class="line">                val[<span class="number">0</span>][i] = <span class="number">0</span>;<span class="comment">// 将第0行置零</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; val.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 此循环不断在当前可放入的物品下,不断扩容体积,直到得到当前可放入物品下的背包物品价值最大</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; val[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                     <span class="comment">// 判断当前待添加的物品是否大于当前可容纳的体积</span></span><br><span class="line">                     <span class="keyword">if</span> (itemWeight[i - <span class="number">1</span>] &gt; j) &#123;</span><br><span class="line">                           <span class="comment">// 是,则取前一行同样体积的物品价值</span></span><br><span class="line">                           val[i][j] = val[i - <span class="number">1</span>][j];</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="comment">// val[i][j] = Math.max(val[i -</span></span><br><span class="line">                           <span class="comment">//  1][j],itemValue[i-1]+val[i-1][j-itemWeight[i-1]]);</span></span><br><span class="line">                           <span class="keyword">if</span> (val[i - <span class="number">1</span>][j] &gt; itemValue[i - <span class="number">1</span>]  + val[i - <span class="number">1</span>][j - itemWeight[i - <span class="number">1</span>]]) &#123;</span><br><span class="line">                                val[i][j] = val[i - <span class="number">1</span>][j];</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                val[i][j] = itemValue[i - <span class="number">1</span>] +  val[i - <span class="number">1</span>][j - itemWeight[i - <span class="number">1</span>]];</span><br><span class="line">                                <span class="comment">// 标识放入物品,标识为1</span></span><br><span class="line">                                sign[i][j] = <span class="number">1</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 显示二维数组</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span>[] row : val) &#123;</span><br><span class="line">                System.out.println(Arrays.toString(row));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span>[] row : sign) &#123;</span><br><span class="line">                System.out.println(Arrays.toString(row));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//显示放入物品的顺序</span></span><br><span class="line">           System.out.println(<span class="string">"=================放入物品的顺序===================="</span>);</span><br><span class="line">           <span class="keyword">int</span> i = val.length - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">int</span> j = weight;</span><br><span class="line">           <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(sign[i][j]==<span class="number">1</span>) &#123;</span><br><span class="line">                     System.out.println(<span class="string">"放入第"</span>+i+<span class="string">"个物品"</span>);</span><br><span class="line">                     j-=itemWeight[i-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95-0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法-分治算法-汉诺塔问题</title>
      <link>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95-%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/</link>
      <guid>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95-%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Tue, 28 Jul 2020 10:08:39 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;分治算法介绍&quot;&gt;&lt;a href=&quot;#分治算法介绍&quot; class=&quot;headerlink&quot; title=&quot;分治算法介绍&quot;&gt;&lt;/a&gt;分治算法介绍&lt;/h3&gt;&lt;p&gt;将一个规模为N的问题，分解成K个规模较小的的子问题，这些子问题相互独立且与原问题性质相同，求出子问题的解，合并即得到原问题的解。&lt;br&gt;算法思想精髓：&lt;br&gt;分 - 将问题分解为规模更小的子问题；&lt;br&gt;治 - 将这些规模更小的子问题逐个击破；&lt;br&gt;合 - 将已解决的子问题合并，最终得出原问题的解。&lt;/p&gt;
&lt;p&gt;注：分治算法分解得到的子问题是独立的，区别于动态规划算法。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="分治算法介绍"><a href="#分治算法介绍" class="headerlink" title="分治算法介绍"></a>分治算法介绍</h3><p>将一个规模为N的问题，分解成K个规模较小的的子问题，这些子问题相互独立且与原问题性质相同，求出子问题的解，合并即得到原问题的解。<br>算法思想精髓：<br>分 - 将问题分解为规模更小的子问题；<br>治 - 将这些规模更小的子问题逐个击破；<br>合 - 将已解决的子问题合并，最终得出原问题的解。</p><p>注：分治算法分解得到的子问题是独立的，区别于动态规划算法。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>分治算法实例：汉诺塔问题<br>相传在古印度圣庙中，有一种被称为汉诺塔(Hanoi)的游戏。该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置64个金盘(如下图)游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。</p><p>步骤：</p><ol><li>如果有一个盘，A-&gt;C;</li><li>如果盘数大于一个盘，先把除最下面的盘以外的盘移动到B;</li><li>接着把最底下的盘移动到C,最后再将B上面的盘移动到C</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">* <span class="meta">@author</span>:ajiany</span><br><span class="line">* <span class="meta">@date</span>:<span class="number">2020</span>/<span class="number">7</span>/<span class="number">17</span></span><br><span class="line">* @功能：分治策略解决汉诺塔问题</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">package</span> divide_and_conquer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hanota</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           hanota(<span class="number">6</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//分治算法解决汉诺塔</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanota</span><span class="params">(<span class="keyword">int</span> dishNum,<span class="keyword">char</span> a,<span class="keyword">char</span> b,<span class="keyword">char</span>  c)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(dishNum==<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"第 "</span>+dishNum+<span class="string">" 次移动位置 ："</span>+ a + <span class="string">" =&gt; "</span>+ c);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//1.先将最底下的盘子上面dishNum-1个盘子移动到b</span></span><br><span class="line">                hanota(dishNum-<span class="number">1</span>, a, c, b);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//2.再将最底下盘子移动到c盘</span></span><br><span class="line">                System.out.println(<span class="string">"第 "</span>+dishNum+<span class="string">" 次移动位置 ："</span>+ a + <span class="string">" =&gt; "</span>+ c);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//3.最后将b位置的盘子移动到c位置</span></span><br><span class="line">                hanota(dishNum-<span class="number">1</span>, b, a, c);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95-%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>数据结构-图</title>
      <link>http://yoursite.com/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/</link>
      <guid>http://yoursite.com/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/</guid>
      <pubDate>Tue, 28 Jul 2020 09:14:59 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;图的介绍&quot;&gt;&lt;a href=&quot;#图的介绍&quot; class=&quot;headerlink&quot; title=&quot;图的介绍&quot;&gt;&lt;/a&gt;图的介绍&lt;/h3&gt;&lt;p&gt;图有多个节点，且其节点可以有零个或多个相邻元素，俩个节点之间的连接称为边，节点也称为顶点。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="图的介绍"><a href="#图的介绍" class="headerlink" title="图的介绍"></a>图的介绍</h3><p>图有多个节点，且其节点可以有零个或多个相邻元素，俩个节点之间的连接称为边，节点也称为顶点。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>图的深度遍历步骤分析：</p><ol><li>访问当前节点v1,并将其节点置为已访问；</li><li>查找当前节点的下一个邻接节点v2；</li><li>若v2存在则继续第4步，若v不存在则回到第一步，将从v1的当一个节点继续；</li><li>若v2未被访问，则继续深度优先遍历递归；</li><li>查找顶点v1的v2的下一个邻接节点；</li></ol><p>图的广度遍历步骤分析：</p><ol><li>访问并输出当前节点v1，并将其置为已访问，其索引入队列，该队列记录访问顶点顺序的索引下标；</li><li>队列不为空，进入循环，弹出队列头节点，得到头节点的下一个节点的索引，并入队列；</li><li>若该索引为-1，表示为彻底广度探索完该节点，该节点已经无邻接节点，继续执行步骤2；</li><li>若该索引不为-1，进入循环，判断该节点是否已经被访问，若已经被访问，继续访问下一个邻接节点；若没被访问则输出当前索引对应的节点，并标志该顶点已经被访问，同时该索引入队列；</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>图的深度遍历及广度遍历代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/14</span></span><br><span class="line"><span class="comment">*       功能：完成图的深度遍历与广度遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphDemo</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义存放顶点的集合</span></span><br><span class="line">     <span class="keyword">private</span> ArrayList&lt;String&gt; vertexSet;</span><br><span class="line">     <span class="comment">// 定义邻接矩阵数组</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span>[][] edges;</span><br><span class="line">     <span class="comment">// 定义一个数组标明顶点被访问过的的标志</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">boolean</span>[] vertexVisited;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">GraphDemo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">           vertexSet = <span class="keyword">new</span> ArrayList&lt;String&gt;(n);</span><br><span class="line">           edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           String[] vertex = &#123; <span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span> &#125;;</span><br><span class="line">           GraphDemo graph = <span class="keyword">new</span> GraphDemo(vertex.length);</span><br><span class="line">           <span class="comment">// 添加顶点进集合</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex.length; i++) &#123;</span><br><span class="line">                graph.addVertex(vertex[i]);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 连接顶点之间的边</span></span><br><span class="line">           graph.createMatrix(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">           graph.createMatrix(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">           graph.createMatrix(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">           graph.createMatrix(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">           graph.createMatrix(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">           <span class="comment">// 输出邻接矩阵</span></span><br><span class="line">           graph.showMatrix();</span><br><span class="line">           System.out.print(<span class="string">"深度遍历："</span>);</span><br><span class="line">           graph.depthTraversal();</span><br><span class="line">           System.out.println();</span><br><span class="line">           System.out.print(<span class="string">"广度遍历："</span>);</span><br><span class="line">           graph.broadTraversal();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 遍历寻找当前行的邻接节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurVertexIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getVertexNum(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (edges[index][i] &gt; <span class="number">0</span>) &#123;<span class="comment">// 表示找到邻接节点,返回索引</span></span><br><span class="line">                     <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 获取当前邻接节点的下一个邻接节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextVertexIndex</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = v2+<span class="number">1</span>; i &lt; getVertexNum(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(edges[v1][i]&gt;<span class="number">0</span>) &#123;<span class="comment">//标明在当前邻接节点访问到了下一个邻接节点,返回索引</span></span><br><span class="line">                     <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//重载广度遍历的方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           vertexVisited=<span class="keyword">new</span> <span class="keyword">boolean</span>[getVertexNum()];</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;getVertexNum();i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!vertexVisited[i]) &#123;</span><br><span class="line">                     broadTraversal(vertexVisited, i);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//广度遍历的方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadTraversal</span><span class="params">(<span class="keyword">boolean</span>[] vertexVisited,<span class="keyword">int</span>  index)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//定义一个队列</span></span><br><span class="line">           LinkedList&lt;Integer&gt; queue=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">           <span class="comment">//定义队头顶点的索引</span></span><br><span class="line">           <span class="keyword">int</span> headIndex;</span><br><span class="line">           <span class="comment">//定义邻接节点的索引</span></span><br><span class="line">           <span class="keyword">int</span> nextIndex;</span><br><span class="line">           System.out.print(<span class="string">" =&gt; "</span>+getVertex(index));</span><br><span class="line">           vertexVisited[index]=<span class="keyword">true</span>;</span><br><span class="line">           <span class="comment">//第一个顶点入队列</span></span><br><span class="line">           queue.addLast(index);</span><br><span class="line">           <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">                headIndex=queue.removeFirst();</span><br><span class="line">                <span class="comment">//获得邻接节点</span></span><br><span class="line">                nextIndex=getCurVertexIndex(headIndex);</span><br><span class="line">                <span class="keyword">while</span> (nextIndex!=-<span class="number">1</span>) &#123;</span><br><span class="line">                     <span class="keyword">if</span>(!vertexVisited[nextIndex]) &#123;</span><br><span class="line">                           System.out.print(<span class="string">" =&gt;  "</span>+getVertex(nextIndex));</span><br><span class="line">                           vertexVisited[nextIndex]=<span class="keyword">true</span>;</span><br><span class="line">                           queue.addLast(nextIndex);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">//访问下一个邻接节点</span></span><br><span class="line">                     nextIndex=getNextVertexIndex(headIndex,  nextIndex);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 重载深度遍历方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depthTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           vertexVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[getVertexNum()];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getVertexNum(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!vertexVisited[i]) &#123;</span><br><span class="line">                     depthTraversal(vertexVisited, i);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 深度遍历方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depthTraversal</span><span class="params">(<span class="keyword">boolean</span>[] vertexVisited, <span class="keyword">int</span>  index)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//输出当前顶点</span></span><br><span class="line">           System.out.print(<span class="string">" =&gt; "</span>+getVertex(index));</span><br><span class="line">           <span class="comment">//将顶点设置为已访问标志</span></span><br><span class="line">           vertexVisited[index]=<span class="keyword">true</span>;</span><br><span class="line">           <span class="comment">//获取下一个邻接节点</span></span><br><span class="line">           <span class="keyword">int</span> i=getCurVertexIndex(index);</span><br><span class="line">           <span class="keyword">while</span>(i!=-<span class="number">1</span>) &#123;<span class="comment">//i不等于-1表示仍然可以当前顶点未试探完</span></span><br><span class="line">                <span class="keyword">if</span>(!vertexVisited[i]) &#123;<span class="comment">//表示未访问过</span></span><br><span class="line">                     depthTraversal(vertexVisited, i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//访问下一个邻接节点</span></span><br><span class="line">                i=getNextVertexIndex(index, i);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 构建邻接矩阵</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createMatrix</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 邻接矩阵右上角与左下角对称,故矩阵值对称存在</span></span><br><span class="line">           edges[v1][v2] = <span class="number">1</span>;</span><br><span class="line">           edges[v2][v1] = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 往集合添加节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addVertex</span><span class="params">(String v)</span> </span>&#123;</span><br><span class="line">           vertexSet.add(v);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//获得集合中的某个顶点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getVertex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> vertexSet.get(index);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 输出邻接矩阵</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMatrix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span>[] row : edges) &#123;</span><br><span class="line">                System.out.println(Arrays.toString(row));</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 获得顶点的个数</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVertexNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> vertexSet.size();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
