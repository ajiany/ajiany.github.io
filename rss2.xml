<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>我是ajian</title>
    <link>http://yoursite.com/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>选择的方向优胜于谋略的策略，方法比努力更有价值</description>
    <pubDate>Tue, 04 Aug 2020 04:30:19 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>leetCode-no-81</title>
      <link>http://yoursite.com/2020/08/04/leetCode-no-81/</link>
      <guid>http://yoursite.com/2020/08/04/leetCode-no-81/</guid>
      <pubDate>Tue, 04 Aug 2020 04:20:31 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;搜索旋转排序数组-II&quot;&gt;&lt;a href=&quot;#搜索旋转排序数组-II&quot; class=&quot;headerlink&quot; title=&quot;搜索旋转排序数组 II&quot;&gt;&lt;/a&gt;搜索旋转排序数组 II&lt;/h3&gt;&lt;p&gt;题目描述：&lt;br&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;br&gt;( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。&lt;br&gt;编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。&lt;br&gt;输入: nums = [2,5,6,0,0,1,2], target = 0&lt;br&gt;输出: true&lt;br&gt;输入: nums = [1,1,1,1,1,1,1,3,1], target = 3&lt;br&gt;输出: true&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="搜索旋转排序数组-II"><a href="#搜索旋转排序数组-II" class="headerlink" title="搜索旋转排序数组 II"></a>搜索旋转排序数组 II</h3><p>题目描述：<br>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。<br>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。<br>输入: nums = [2,5,6,0,0,1,2], target = 0<br>输出: true<br>输入: nums = [1,1,1,1,1,1,1,3,1], target = 3<br>输出: true</p><a id="more"></a><p>思路:</p><ol><li>数组中存在重复元素，影响判断target在哪一边，故需要在判断nums[0]和nums[middle]的关系前，先判断nums[left]和nums[right]与nums[middle]的关系，因为俩边可能存在多个重复元素；</li><li>判断完之后，再继续判断target在前半段还是后半点的判断。</li></ol><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：1 ms, 在所有 Java 提交中击败了64.08%的用户</span></span><br><span class="line"><span class="comment">内存消耗：39.8 MB, 在所有 Java 提交中击败了23.42%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//排除特殊情况</span></span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> target==nums[<span class="number">0</span>]?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>,middle=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        middle=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==nums[middle]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//若nums[left]==nums[middle]，left++,再判断</span></span><br><span class="line">        <span class="keyword">if</span>(nums[left]==nums[middle])&#123;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[right]==nums[middle])&#123;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//nums[0]&lt;nums[middle]前半部分有序</span></span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]&lt;nums[middle])&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>]&lt;=target&amp;&amp;target&lt;nums[middle]) right=middle-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left=middle+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//nums[middle]&gt;nums[nums.length-1]后部分有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[middle]&lt;target&amp;&amp;target&lt;=nums[nums.length-<span class="number">1</span>]) left=middle+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right=middle-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行用时：20 ms, 在所有 Python 提交中击败了88.35%的用户</span></span><br><span class="line"><span class="string">内存消耗：12.8 MB, 在所有 Python 提交中击败了91.67%的用户</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">1</span> <span class="keyword">and</span> target==nums[<span class="number">0</span>]: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> len(nums)==<span class="number">1</span> <span class="keyword">and</span> target!=nums[<span class="number">0</span>]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        left,right,middle=<span class="number">0</span>,len(nums)<span class="number">-1</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;=right:</span><br><span class="line">            middle=left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target==nums[middle]: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> nums[left]==nums[middle]:</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> nums[right]==nums[middle]:</span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[<span class="number">0</span>]&lt;nums[middle]:</span><br><span class="line">                <span class="keyword">if</span> nums[<span class="number">0</span>]&lt;=target <span class="keyword">and</span> target&lt;nums[middle]: right=middle<span class="number">-1</span></span><br><span class="line">                <span class="keyword">else</span>: left=middle+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[middle]&lt;target <span class="keyword">and</span> target&lt;=nums[len(nums)<span class="number">-1</span>]: left=middle+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: right=middle<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/08/04/leetCode-no-81/#disqus_thread</comments>
    </item>
    
    <item>
      <title>leetCode-no-33</title>
      <link>http://yoursite.com/2020/08/02/leetCode-no-33/</link>
      <guid>http://yoursite.com/2020/08/02/leetCode-no-33/</guid>
      <pubDate>Sun, 02 Aug 2020 11:05:45 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;搜索旋转排序数组&quot;&gt;&lt;a href=&quot;#搜索旋转排序数组&quot; class=&quot;headerlink&quot; title=&quot;搜索旋转排序数组&quot;&gt;&lt;/a&gt;搜索旋转排序数组&lt;/h3&gt;&lt;p&gt;题目描述&lt;br&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;br&gt;( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。&lt;br&gt;搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。&lt;br&gt;你可以假设数组中不存在重复的元素。&lt;br&gt;你的算法时间复杂度必须是 O(log n) 级别。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h3><p>题目描述<br>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。<br>你可以假设数组中不存在重复的元素。<br>你的算法时间复杂度必须是 O(log n) 级别。</p><a id="more"></a><p>思路：</p><ol><li>比较数组的第一个位置与中间点的大小，若第一个位置的值比中间的大，则继续判断target的值是否在[ nums[middle],nums[nums.length-1] ]这个区间，若是则令左边界向右移动，即left=middle+1;反之right=middle-1;</li><li>若第一个位置的值比中间的小，则继续判断target是否位于[ 0，nums[middle] ]这个区间，若是的话则令右边界左移，即right=middle-1;反之left=middle+1。</li></ol><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：39.5 MB, 在所有 Java 提交中击败了39.44%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode_no_33</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//排除特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]==target?<span class="number">0</span>:-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>,middle=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            middle=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target==nums[middle]) <span class="keyword">return</span> middle;</span><br><span class="line">            <span class="comment">//选择搜索区域</span></span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>]&lt;=nums[middle])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target&lt;nums[middle]&amp;&amp;target&gt;=nums[<span class="number">0</span>])  right=middle-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> left=middle+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(target&gt;nums[middle]&amp;&amp;target&lt;=nums[nums.length-<span class="number">1</span>])  left=middle+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right=middle-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums=&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target=<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> result=search(nums, target);</span><br><span class="line">        System.out.println(<span class="string">"The running result of Java is "</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行用时：20 ms, 在所有 Python 提交中击败了76.20%的用户</span></span><br><span class="line"><span class="string">内存消耗：13.1 MB, 在所有 Python 提交中击败了5.43%的用户</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">1</span> <span class="keyword">and</span> target==nums[<span class="number">0</span>]: <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">        <span class="keyword">elif</span> len(nums)==<span class="number">1</span> <span class="keyword">and</span> target!=nums[<span class="number">0</span>]: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        left,right,middle=<span class="number">0</span>,len(nums)<span class="number">-1</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;=right:</span><br><span class="line">            middle=left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target==nums[middle]: <span class="keyword">return</span> middle</span><br><span class="line">            <span class="keyword">if</span> nums[<span class="number">0</span>]&lt;=nums[middle]:</span><br><span class="line">                <span class="keyword">if</span> target&lt;nums[middle] <span class="keyword">and</span> target&gt;=nums[<span class="number">0</span>]: right=middle<span class="number">-1</span></span><br><span class="line">                <span class="keyword">else</span>: left=middle+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> target&gt;nums[middle] <span class="keyword">and</span> target&lt;=nums[len(nums)<span class="number">-1</span>]: left=middle+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: right=middle<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">s=Solution()</span><br><span class="line">nums=[<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">target=<span class="number">1</span></span><br><span class="line">result=s.search(nums,target)</span><br><span class="line">print(<span class="string">"The running result of Python is &#123;&#125;"</span>.format(result))</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/08/02/leetCode-no-33/#disqus_thread</comments>
    </item>
    
    <item>
      <title>leetCode-no-34</title>
      <link>http://yoursite.com/2020/08/02/leetCode-no-34/</link>
      <guid>http://yoursite.com/2020/08/02/leetCode-no-34/</guid>
      <pubDate>Sun, 02 Aug 2020 04:44:08 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;在排序数组中查找元素的第一个和最后一个位置&quot;&gt;&lt;a href=&quot;#在排序数组中查找元素的第一个和最后一个位置&quot; class=&quot;headerlink&quot; title=&quot;在排序数组中查找元素的第一个和最后一个位置&quot;&gt;&lt;/a&gt;在排序数组中查找元素的第一个和最后一个位置&lt;/h3&gt;&lt;p&gt;题目描述&lt;br&gt;给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。&lt;br&gt;你的算法时间复杂度必须是 O(log n) 级别。&lt;br&gt;如果数组中不存在目标值，返回 [-1, -1]。&lt;br&gt;输入: nums = [5,7,7,8,8,10], target = 8&lt;br&gt;输出: [3,4]&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h3><p>题目描述<br>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。<br>你的算法时间复杂度必须是 O(log n) 级别。<br>如果数组中不存在目标值，返回 [-1, -1]。<br>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: [3,4]</p><a id="more"></a><p>思路：</p><ol><li>查询得到target==nums[middle]暂时不返回，不断向左边界靠近，直到left&gt;right,退出循环得到第一个leftIndex;</li><li>判断leftIndex的有效性，若leftIndex==nums.length或者target!=nums[leftIndex]则返回[-1,-1];3.<br>继续得到target的结束位置leftNextIndex,因为开始位置已经得到，则不必再次向左边界靠近，当循环结束，返回的值减1即结束位置的下标值。</li></ol><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：42.9 MB, 在所有 Java 提交中击败了74.17%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode_no_34</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取指定target的左边界下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target,<span class="keyword">boolean</span> le)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>,middle=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            middle=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;nums[middle]||le&amp;&amp;target==nums[middle]) right=middle-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left=middle+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> leftIndex=getIndex(nums, target, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span>(leftIndex==nums.length||target!=nums[leftIndex])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时leftNextIndex已经为数组长度，超出索引的值，故减1</span></span><br><span class="line">        <span class="keyword">int</span> leftNextIndex=getIndex(nums, target, <span class="keyword">false</span>)-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;leftIndex,leftNextIndex&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int[] nums=&#123;5,7,7,8,8,10&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] nums=&#123;<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result=searchRange(nums, target);</span><br><span class="line">        System.out.println(<span class="string">"The Java run result is: "</span>+Arrays.toString(result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行用时：20 ms, 在所有 Python 提交中击败了77.30%的用户</span></span><br><span class="line"><span class="string">内存消耗：13.1 MB, 在所有 Python 提交中击败了80.23%的用户</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        leftIndex=self.getIndex(nums,target,<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> leftIndex==len(nums) <span class="keyword">or</span> target!=nums[leftIndex]: <span class="keyword">return</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">        leftNextIndex=self.getIndex(nums,target,<span class="literal">False</span>)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> [leftIndex,leftNextIndex]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIndex</span><span class="params">(self,nums,target,sign)</span>:</span></span><br><span class="line">        left,right,middle=<span class="number">0</span>,len(nums)<span class="number">-1</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;=right:</span><br><span class="line">            middle=left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target&lt;nums[middle] <span class="keyword">or</span> (sign <span class="keyword">and</span> target==nums[middle]): right=middle<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span> : left=middle+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s=Solution()</span><br><span class="line">    nums=[<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br><span class="line">    target=<span class="number">8</span></span><br><span class="line">    result=s.searchRange(nums,target)</span><br><span class="line">    print(<span class="string">"The running result of Python is :&#123;&#125;"</span>.format(result))</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/08/02/leetCode-no-34/#disqus_thread</comments>
    </item>
    
    <item>
      <title>leetCode-no-35</title>
      <link>http://yoursite.com/2020/08/01/leetCode-no-35/</link>
      <guid>http://yoursite.com/2020/08/01/leetCode-no-35/</guid>
      <pubDate>Sat, 01 Aug 2020 15:16:04 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;搜索插入位置&quot;&gt;&lt;a href=&quot;#搜索插入位置&quot; class=&quot;headerlink&quot; title=&quot;搜索插入位置&quot;&gt;&lt;/a&gt;搜索插入位置&lt;/h3&gt;&lt;p&gt;题目描述&lt;br&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;br&gt;你可以假设数组中无重复元素。&lt;/p&gt;
&lt;p&gt;输入: [1,3,5,6], 5&lt;br&gt;输出: 2&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h3><p>题目描述<br>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>你可以假设数组中无重复元素。</p><p>输入: [1,3,5,6], 5<br>输出: 2</p><a id="more"></a><p>思路：</p><ol><li>先判断数组是否为空；</li><li>判断数组特殊情况，target值比数组的所有值都大，则返回数组的长度；</li><li>若数组中有该值则返回该值在数组的索引否则返回在数组中可以插入位置的索引下标，实际上即求返回一个大于等于target值的下标</li></ol><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：39.4 MB, 在所有 Java 提交中击败了68.25%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//暴力解</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert2</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;=target) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.length;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> middle;</span><br><span class="line">    <span class="comment">//数组为零的情况</span></span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//目标值为数组中最大的情况</span></span><br><span class="line">    <span class="keyword">if</span>(nums[nums.length-<span class="number">1</span>]&lt;target) <span class="keyword">return</span> nums.length;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        middle=(right-left)/<span class="number">2</span>+left;</span><br><span class="line">        <span class="keyword">if</span>(target&gt;nums[middle])&#123;</span><br><span class="line">            left=middle+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right=middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行用时：16 ms, 在所有 Python 提交中击败了87.97%的用户</span></span><br><span class="line"><span class="string">内存消耗：13 MB, 在所有 Python 提交中击败了41.46%的用户</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        left,right=<span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">        middle=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> nums[len(nums)<span class="number">-1</span>]&lt;target: <span class="keyword">return</span> len(nums)</span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            middle=left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target&gt;nums[middle]:</span><br><span class="line">                left=middle+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: right=middle</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/08/01/leetCode-no-35/#disqus_thread</comments>
    </item>
    
    <item>
      <title>leetCode-no-88</title>
      <link>http://yoursite.com/2020/07/31/leetCode-no-88/</link>
      <guid>http://yoursite.com/2020/07/31/leetCode-no-88/</guid>
      <pubDate>Fri, 31 Jul 2020 07:21:47 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;合并两个有序数组&quot;&gt;&lt;a href=&quot;#合并两个有序数组&quot; class=&quot;headerlink&quot; title=&quot;合并两个有序数组&quot;&gt;&lt;/a&gt;合并两个有序数组&lt;/h3&gt;&lt;p&gt;题目描述&lt;br&gt;给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化 nums1 和 nums2 的元素数量分别为 m 和 n&lt;/li&gt;
&lt;li&gt;你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h3><p>题目描述<br>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p><p>说明：</p><ul><li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n</li><li>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<a id="more"></a></li></ul><p>示例：<br>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6], n = 3<br>输出:<br>[1,2,2,3,5,6]</p><p>思路：</p><ol><li>利用插入排序的思想，将nums1看成有序序列，nums2看成无序序列；</li><li>逐个将nums2中的元素插入nums1数组中；</li></ol><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：1 ms, 在所有 Java 提交中击败了23.39%的用户</span></span><br><span class="line"><span class="comment">内存消耗：39.7 MB, 在所有 Java 提交中击败了80.87%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode_no_88</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//insertIndex插入位置下标；insertValue待插入元素</span></span><br><span class="line">        <span class="keyword">int</span> insertIndex,insertValue;</span><br><span class="line">        <span class="comment">//遍历待插入数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//顺序获得待插入insertValue</span></span><br><span class="line">            insertValue=nums2[i];</span><br><span class="line">            <span class="comment">//有序数组nums1不断增大，故待插入下标开始的值也要递增</span></span><br><span class="line">            insertIndex=m+i-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//寻找待插入位置</span></span><br><span class="line">            <span class="keyword">while</span>(insertIndex&gt;=<span class="number">0</span>&amp;&amp;insertValue&lt;nums1[insertIndex]) insertIndex--;</span><br><span class="line">            <span class="comment">//给待插入位置元素腾开位置，即后移待插入位置后面的元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m+i;j&gt;insertIndex+<span class="number">1</span>;j--) nums1[j]=nums1[j-<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//插入元素</span></span><br><span class="line">            nums1[insertIndex+<span class="number">1</span>]=insertValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=<span class="number">3</span>,n=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span>[] nums1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] nums2=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        merge4(nums1, m, nums2, n);</span><br><span class="line">        System.out.println(Arrays.toString(nums1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：<br>时间复杂度较大，效率不高<br>时间复杂度 : O(n * m)。<br>空间复杂度 : O(m + n)。</p><h4 id="官方Java代码实现一"><a href="#官方Java代码实现一" class="headerlink" title="官方Java代码实现一"></a>官方Java代码实现一</h4><p><strong>双指针 / 从前往后</strong><br>一般而言，对于有序数组可以通过 双指针法 达到O(n + m)的时间复杂度。<br>最直接的算法实现是将指针p1 置为 nums1的开头， p2为 nums2的开头，在每一步将最小值放入输出数组中。<br>由于 nums1 是用于输出的数组，需要将nums1中的前m个元素放在其他地方，也就需要 O(m)的空间复杂度。<br><img data-src="/images/leetcode_img/leetCode_No_88/method1.png" alt="解答一图例"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge3</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将nums1数组复制到一个新的数组空间nums1Copy</span></span><br><span class="line">    <span class="keyword">int</span>[] nums1Copy=<span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    System.arraycopy(nums1, <span class="number">0</span>, nums1Copy, <span class="number">0</span>,m);</span><br><span class="line">    <span class="comment">//定义分别指向三个数组的指针p1指向nums1Copy,p2指向nums2,p指向nums1</span></span><br><span class="line">    <span class="keyword">int</span> p1=<span class="number">0</span>,p2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1&lt;m&amp;&amp;p2&lt;n) nums1[p++]=nums1Copy[p1]&lt;nums2[p2]?nums1Copy[p1++]:nums2[p2++];</span><br><span class="line">    <span class="comment">//排除一个数组全部数值比另外一个数组的全部数值小的情况</span></span><br><span class="line">    <span class="keyword">if</span>(p1&lt;m) System.arraycopy(nums1Copy, p1, nums1, p1+p2, m+n-p1-p2);</span><br><span class="line">    <span class="keyword">if</span>(p2&lt;n) System.arraycopy(nums2, p2,nums1, p1+p2, m+n-p1-p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetcode/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>时间复杂度 : O(n + m)。<br>空间复杂度 : O(m)</p><h4 id="官方Java代码实现二"><a href="#官方Java代码实现二" class="headerlink" title="官方Java代码实现二"></a>官方Java代码实现二</h4><p><strong>双指针 / 从后往前</strong><br>已经取得了最优的时间复杂度O(n + m)，但需要使用额外空间。这是由于在从头改变nums1的值时，需要把nums1中的元素存放在其他位置<br>如果我们从结尾开始改写 nums1 的值又会如何呢？这里没有信息，因此不需要额外空间。<br><img data-src="/images/leetcode_img/leetCode_No_88/method2.png" alt="解答二图例"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge4</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1=m-<span class="number">1</span>,p2=n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p=nums1.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1&gt;=<span class="number">0</span>&amp;&amp;p2&gt;=<span class="number">0</span>) nums1[p--]=nums1[p1]&gt;nums2[p2]?nums1[p1--]:nums2[p2--];</span><br><span class="line">    System.arraycopy(nums2, <span class="number">0</span>, nums1, <span class="number">0</span>, p2+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetcode/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>时间复杂度 : O(n + m)<br>空间复杂度 : O(1)</p><h3 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行用时：20 ms, 在所有 Python 提交中击败了73.83%的用户</span></span><br><span class="line"><span class="string">内存消耗：12.6 MB, 在所有 Python 提交中击败了82.05%的用户</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">:type nums1: List[int]</span></span><br><span class="line"><span class="string">:type m: int</span></span><br><span class="line"><span class="string">:type nums2: List[int]</span></span><br><span class="line"><span class="string">:type n: int</span></span><br><span class="line"><span class="string">:rtype: None Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        insertIndex,insertValue=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums2)):</span><br><span class="line">            insertValue=nums2[i]</span><br><span class="line">            insertIndex=m<span class="number">-1</span>+i</span><br><span class="line">            <span class="keyword">while</span> insertIndex&gt;=<span class="number">0</span> <span class="keyword">and</span> insertValue&lt;nums1[insertIndex]:</span><br><span class="line">                insertIndex-=<span class="number">1</span></span><br><span class="line">            j=m+i</span><br><span class="line">            <span class="keyword">while</span> j&gt;insertIndex+<span class="number">1</span>:</span><br><span class="line">                nums1[j]=nums1[j<span class="number">-1</span>]</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            nums1[insertIndex+<span class="number">1</span>]=insertValue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s=Solution()</span><br><span class="line">nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">m = <span class="number">3</span></span><br><span class="line">nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">s.merge(nums1,m,nums2,n)</span><br><span class="line">print(nums1)</span><br></pre></td></tr></table></figure><h4 id="官方Python代码实现"><a href="#官方Python代码实现" class="headerlink" title="官方Python代码实现"></a>官方Python代码实现</h4><p><strong>双指针 / 从后往前</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># two get pointers for nums1 and nums2</span></span><br><span class="line">        p1 = m - <span class="number">1</span></span><br><span class="line">        p2 = n - <span class="number">1</span></span><br><span class="line">        <span class="comment"># set pointer for nums1</span></span><br><span class="line">        p = m + n - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># while there are still elements to compare</span></span><br><span class="line">        <span class="keyword">while</span> p1 &gt;= <span class="number">0</span> <span class="keyword">and</span> p2 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[p1] &lt; nums2[p2]:</span><br><span class="line">                nums1[p] = nums2[p2]</span><br><span class="line">                p2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[p] =  nums1[p1]</span><br><span class="line">                p1 -= <span class="number">1</span></span><br><span class="line">            p -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># add missing elements from nums2</span></span><br><span class="line">        nums1[:p2 + <span class="number">1</span>] = nums2[:p2 + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">作者：LeetCode</span></span><br><span class="line"><span class="string">链接：https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetcode/</span></span><br><span class="line"><span class="string">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="string">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/31/leetCode-no-88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>leetCode-no-26</title>
      <link>http://yoursite.com/2020/07/31/leetCode-no-26/</link>
      <guid>http://yoursite.com/2020/07/31/leetCode-no-26/</guid>
      <pubDate>Thu, 30 Jul 2020 17:29:54 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;删除排序数组中的重复项&quot;&gt;&lt;a href=&quot;#删除排序数组中的重复项&quot; class=&quot;headerlink&quot; title=&quot;删除排序数组中的重复项&quot;&gt;&lt;/a&gt;删除排序数组中的重复项&lt;/h3&gt;&lt;p&gt;题目描述&lt;br&gt;给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&lt;br&gt;不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h3><p>题目描述<br>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><a id="more"></a><p>给定数组 nums = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。</p><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素。</p><p>思路：</p><ol><li>首先判断数组长度等于1或者等于0的情况</li><li>从数组第1位开始遍历数组，如果数组当前索引的前一位与当前数值不相等，则nums[++newArrayIndex]=nums[i];</li><li>不断重复步骤2，最后返回newArrayIndex+1即新数组的长度。</li></ol><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：1 ms, 在所有 Java 提交中击败了98.21%的用户</span></span><br><span class="line"><span class="comment">内存消耗：41.8 MB, 在所有 Java 提交中击败了22.09%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">leetcode_no_26</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//newArrayLen表示新数组长度</span></span><br><span class="line">        <span class="comment">//newArrayIndex表示新数组下标</span></span><br><span class="line">        <span class="keyword">int</span> newArrayLen=<span class="number">1</span>,newArrayIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断数组小于或等于0的情况</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//筛除重复数据，得到不重复数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i-<span class="number">1</span>]!=nums[i])&#123;</span><br><span class="line">                nums[++newArrayIndex]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newArrayLen=newArrayIndex+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> newArrayLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> result=removeDuplicates(nums);</span><br><span class="line">        System.out.println(<span class="string">"The new array's length is :"</span>+result);</span><br><span class="line">        System.out.println(<span class="string">"The new array is :"</span>+Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行用时：32 ms, 在所有 Python 提交中击败了61.68%的用户</span></span><br><span class="line"><span class="string">内存消耗：14.6 MB, 在所有 Python 提交中击败了5.88%的用户</span></span><br><span class="line"><span class="string">:type nums: List[int]</span></span><br><span class="line"><span class="string">:rtype: int</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        newArrayLen,newArrayIndex=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i<span class="number">-1</span>]!=nums[i]:</span><br><span class="line">                newArrayIndex+=<span class="number">1</span></span><br><span class="line">                nums[newArrayIndex]=nums[i]</span><br><span class="line">        newArrayLen=newArrayIndex+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> newArrayLen</span><br><span class="line">nums=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">s=Solution()</span><br><span class="line">result=s.removeDuplicates(nums)</span><br><span class="line">print(<span class="string">"The new Array's length is :&#123;&#125; and the new Array is : &#123;&#125;"</span>.format(result,nums))</span><br></pre></td></tr></table></figure><h3 id="官方Java代码解答"><a href="#官方Java代码解答" class="headerlink" title="官方Java代码解答"></a>官方Java代码解答</h3><p>方法：<strong>双指针法</strong></p><ol><li>数组完成排序后，我们可以放置两个指针 i和 j，其中 i是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，我们就增加 j以跳过重复项；</li><li>当我们遇到 nums[i] !=nums[j] 时，跳过重复项的运行已经结束，因此我们必须把它 nums[j] 的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程，直到 j到达数组的末尾为止。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-xiang-by-/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/31/leetCode-no-26/#disqus_thread</comments>
    </item>
    
    <item>
      <title>leetCode-no-674</title>
      <link>http://yoursite.com/2020/07/30/leetCode-no-674/</link>
      <guid>http://yoursite.com/2020/07/30/leetCode-no-674/</guid>
      <pubDate>Thu, 30 Jul 2020 15:51:50 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;最长连续递增序列&quot;&gt;&lt;a href=&quot;#最长连续递增序列&quot; class=&quot;headerlink&quot; title=&quot;最长连续递增序列&quot;&gt;&lt;/a&gt;最长连续递增序列&lt;/h3&gt;&lt;p&gt;题目描述&lt;br&gt;给定一个未经排序的整数数组，找到最长且连续的的递增序列，并返回该序列的长度&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="最长连续递增序列"><a href="#最长连续递增序列" class="headerlink" title="最长连续递增序列"></a>最长连续递增序列</h3><p>题目描述<br>给定一个未经排序的整数数组，找到最长且连续的的递增序列，并返回该序列的长度</p><a id="more"></a><p>输入: [1,3,5,4,7]<br>输出: 3<br>解释: 最长连续递增序列是 [1,3,5], 长度为3。<br>尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。</p><p>输入: [2,2,2,2,2]<br>输出: 1<br>解释: 最长连续递增序列是 [2], 长度为1</p><p>思路：</p><ol><li>如果数组长度为1或者0的情况，返回该数组长度；</li><li>从数组索引为1的位置开始遍历数组，如果当前位置的前一位置数值比当前位置数值大，则判断 result和当前连续递增子序列的长度谁更大，数值大的保存到result，同时maxLength重置为1开始计数新的连续递增子序列；</li><li>不断重复步骤2，最后在返回最大连续递增数组长度前，需判断result&gt;maxLength?result:maxLength，为了防止整个数组都是连续递增的情况。</li></ol><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：1 ms, 在所有 Java 提交中击败了99.79%的用户</span></span><br><span class="line"><span class="comment">内存消耗：40.5 MB, 在所有 Java 提交中击败了48.15%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">leetcode_no_674</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义最终结果result及当前数组的连续递增序列的最大长度maxLength</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>,maxLength=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//判断数组长度等于或者为0的情况</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i-<span class="number">1</span>]&gt;=nums[i])&#123;</span><br><span class="line">                result=result&gt;maxLength?result:maxLength;</span><br><span class="line">                maxLength=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                maxLength++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排除整个数组都是递增的情况</span></span><br><span class="line">        result=result&gt;maxLength?result:maxLength;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> result=findLengthOfLCIS(nums);</span><br><span class="line">        System.out.println(<span class="string">"The result is:"</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="官方Java代码解释"><a href="#官方Java代码解释" class="headerlink" title="官方Java代码解释"></a>官方Java代码解释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ans是返回的最终结果；anchor是连续递增的子序列的分界点</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, anchor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="comment">//如果到达分界点，即遍历到了一个使原先连续递增的序列不再连续的数，则令anchor=i</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i-<span class="number">1</span>] &gt;= nums[i]) anchor = i;          </span><br><span class="line">            <span class="comment">//（i + 1- anchor） 记录的连续递增的子序列的连续数量</span></span><br><span class="line">            ans = Math.max(ans, i - anchor + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/solution/zui-chang-lian-xu-di-zeng-xu-lie-by-leetcode/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="官方代码的理解"><a href="#官方代码的理解" class="headerlink" title="官方代码的理解"></a>官方代码的理解</h4><p>每次循环都更新结果的值，当碰到分界点时，i - anchor + 1重新记录新的连续递增子序列的连续数量，而ans则代表前一连续递增子序列的连续数量，当再次碰到下一个分界点，ans = Math.max(ans, i - anchor + 1);会拿当前连续递增子序列的连续数量和上一次的比较，这样不断循环遍历，ans保存的是最大的连续递增子序列连续数量；<br>优点：<br>无需判断数组长度为0或者为1的情况；无需在整个数组都是连续递增的情况下做判断，代码简洁；</p><h3 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行用时：64 ms, 在所有 Python 提交中击败了76.75%的用户</span></span><br><span class="line"><span class="string">内存消耗：13.8 MB, 在所有 Python 提交中击败了10.00%的用户</span></span><br><span class="line"><span class="string">:type nums: List[int]</span></span><br><span class="line"><span class="string">:rtype: int</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLengthOfLCIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        result,maxLength=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i<span class="number">-1</span>]&gt;=nums[i]:</span><br><span class="line">                result=max(result,maxLength)</span><br><span class="line">                maxLength=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                maxLength+=<span class="number">1</span></span><br><span class="line">        result=max(result,maxLength)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>]</span><br><span class="line">s=Solution()</span><br><span class="line">result=s.findLengthOfLCIS(nums)</span><br><span class="line">print(<span class="string">"This result is :&#123;&#125;"</span>.format(result))</span><br></pre></td></tr></table></figure><h3 id="官方Python代码解释"><a href="#官方Python代码解释" class="headerlink" title="官方Python代码解释"></a>官方Python代码解释</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLengthOfLCIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        ans = anchor = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">and</span> nums[i<span class="number">-1</span>] &gt;= nums[i]: anchor = i</span><br><span class="line">            ans = max(ans, i - anchor + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">作者：LeetCode</span></span><br><span class="line"><span class="string">链接：https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/solution/zui-chang-lian-xu-di-zeng-xu-lie-by-leetcode/</span></span><br><span class="line"><span class="string">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="string">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/30/leetCode-no-674/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法-马踏棋盘问题-贪心算法优化</title>
      <link>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/</link>
      <guid>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/</guid>
      <pubDate>Tue, 28 Jul 2020 10:24:13 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;马踏棋盘问题介绍&quot;&gt;&lt;a href=&quot;#马踏棋盘问题介绍&quot; class=&quot;headerlink&quot; title=&quot;马踏棋盘问题介绍&quot;&gt;&lt;/a&gt;马踏棋盘问题介绍&lt;/h3&gt;&lt;p&gt;在 8×8 的国际象棋棋盘上，用一个马按照马步(马走日字)跳遍整个棋盘，要求每个格子都只跳到一次，最后回到出发点。&lt;br&gt;马踏棋盘问题同时也是图的深度优先搜索的应用&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="马踏棋盘问题介绍"><a href="#马踏棋盘问题介绍" class="headerlink" title="马踏棋盘问题介绍"></a>马踏棋盘问题介绍</h3><p>在 8×8 的国际象棋棋盘上，用一个马按照马步(马走日字)跳遍整个棋盘，要求每个格子都只跳到一次，最后回到出发点。<br>马踏棋盘问题同时也是图的深度优先搜索的应用</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>策略选择：</p><ol><li>暴力搜索</li><li>贪心算法优化</li></ol><p>策略分析：<br>暴力搜索耗费时间长，使用贪心算法每次选择当前位置的所有可选位置中最少的进行前进，即对当前位置的所有位置的下一个落脚点的可选序列数量进行非递减顺序排序，从其中选择最少的前进。这样回溯速度快，总体运行时间少。</p><p>马踏棋盘问题图例：<br><img src="/images/algorithm_img/horseCheck/horseCheck.png" alt="棋盘"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>马踏棋盘问题代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/25</span></span><br><span class="line"><span class="comment">* @功能：运用贪心算法对马踏棋盘问题进行优化,比原先暴力搜索的策略效率大大增强</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> tsp;</span><br><span class="line"><span class="keyword">import</span> java.awt.Point;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HorseStepCheckBoard</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义棋盘的行数</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> X;</span><br><span class="line">     <span class="comment">// 定义棋盘的列数</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> Y;</span><br><span class="line">     <span class="comment">// 定义棋盘,每个棋位表示棋子下的第几步</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span>[][] checkBoard;</span><br><span class="line">     <span class="comment">// 定义与棋盘同样大小的二维数组,每个位置表示棋子是否走过</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">boolean</span>[][] stepVisited;</span><br><span class="line">     <span class="comment">// 定义标识马踏棋盘任务完成的标识</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">boolean</span> finished;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 初始化值</span></span><br><span class="line">           X = <span class="number">8</span>;</span><br><span class="line">           Y = <span class="number">8</span>;</span><br><span class="line">           checkBoard = <span class="keyword">new</span> <span class="keyword">int</span>[X][Y];</span><br><span class="line">           stepVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[X][Y];</span><br><span class="line">           <span class="comment">// 定义起始位置</span></span><br><span class="line">           <span class="keyword">int</span> row = <span class="number">1</span>, column = <span class="number">1</span>;</span><br><span class="line">           <span class="comment">// 开始时间</span></span><br><span class="line">           <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">           traverseCheckBoard(row - <span class="number">1</span>, column - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">           <span class="comment">// 结束时间</span></span><br><span class="line">           <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">           System.out.println(<span class="string">"完成马踏棋盘游戏花费： "</span> + (endTime -  startTime)+<span class="string">"毫秒"</span>);</span><br><span class="line">           showCheckBoard();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 输出棋盘的结果</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showCheckBoard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"***********************checkBoard***********************"</span>);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; checkBoard.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; checkBoard[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                     System.out.print(checkBoard[i][j] + <span class="string">"\t"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">"***********************checkBoard***********************"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseCheckBoard</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>  step)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 将当前位置置为已访问</span></span><br><span class="line">           checkBoard[x][y] = step;</span><br><span class="line">           stepVisited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">           <span class="comment">// 获得下一个可访问的位置</span></span><br><span class="line">           ArrayList&lt;Point&gt; next = nextPoint(<span class="keyword">new</span> Point(y, x));</span><br><span class="line">           <span class="comment">//贪心算法优化</span></span><br><span class="line">           sortPoint(next);</span><br><span class="line">           <span class="keyword">while</span> (!next.isEmpty()) &#123;</span><br><span class="line">                Point p = next.remove(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 该位置未访问才能作为下一步的棋子位置</span></span><br><span class="line">                <span class="keyword">if</span> (!stepVisited[p.x][p.y]) &#123;</span><br><span class="line">                     traverseCheckBoard(p.x, p.y, step + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 未完成则当前位置置为0且标志未访问</span></span><br><span class="line">           <span class="keyword">if</span> (!finished &amp;&amp; step &lt; X * Y) &#123;</span><br><span class="line">                checkBoard[x][y] = <span class="number">0</span>;</span><br><span class="line">                stepVisited[x][y] = <span class="keyword">false</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                finished = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 判断当前位置的下一步位置</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Point&gt; <span class="title">nextPoint</span><span class="params">(Point curPoint)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义存放可走位置的容器</span></span><br><span class="line">           ArrayList&lt;Point&gt; pointSet = <span class="keyword">new</span> ArrayList&lt;Point&gt;();</span><br><span class="line">           <span class="comment">// 定义暂存点</span></span><br><span class="line">           Point p1 = <span class="keyword">new</span> Point();</span><br><span class="line">           <span class="comment">// 左上角平日字,5号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y =  curPoint.y - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 左上角竖日字,6号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y =  curPoint.y - <span class="number">2</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 右上角竖日字,7号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y  - <span class="number">2</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 右上角平日字,0号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y  - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 右下角平日字,1号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y  + <span class="number">1</span>) &lt; Y) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 右下角竖日字,2号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y  + <span class="number">2</span>) &lt; Y) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 左下角竖日字,3号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y =  curPoint.y + <span class="number">2</span>) &lt; Y) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 左下角平日字,4号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y =  curPoint.y + <span class="number">1</span>) &lt; Y) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> pointSet;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 对当前位置的下一步按照非递减排序后选择合适的位置以致减少回溯的次数</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortPoint</span><span class="params">(ArrayList&lt;Point&gt; pointSet)</span> </span>&#123;</span><br><span class="line">           pointSet.sort(<span class="keyword">new</span> Comparator&lt;Point&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">                     <span class="comment">// 获取p1的下一步所有位置个数</span></span><br><span class="line">                     <span class="keyword">int</span> count1 = nextPoint(p1).size();</span><br><span class="line">                     <span class="comment">// 获取p2的下一步所有位置个数</span></span><br><span class="line">                     <span class="keyword">int</span> count2 = nextPoint(p2).size();</span><br><span class="line">                     <span class="keyword">if</span> (count1 &lt; count2) &#123;</span><br><span class="line">                           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                     &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count1==count2) &#123;</span><br><span class="line">                           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法-弗洛伊德算法-最短路径问题</title>
      <link>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</link>
      <guid>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Tue, 28 Jul 2020 10:23:14 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;弗洛伊德算法介绍&quot;&gt;&lt;a href=&quot;#弗洛伊德算法介绍&quot; class=&quot;headerlink&quot; title=&quot;弗洛伊德算法介绍&quot;&gt;&lt;/a&gt;弗洛伊德算法介绍&lt;/h3&gt;&lt;p&gt;是用于寻找给定加权图中顶点间的最短路径的算法。&lt;/p&gt;
&lt;p&gt;弗洛伊德算法与迪杰斯特拉算法的区别：&lt;br&gt;弗洛伊德算法是求解每个顶点(每一个顶点都是出发顶点)到其他各顶点的最短路径问题，而迪杰斯特拉算法是求其中一个顶点(出发顶点)到其他顶点的最短路径问题。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="弗洛伊德算法介绍"><a href="#弗洛伊德算法介绍" class="headerlink" title="弗洛伊德算法介绍"></a>弗洛伊德算法介绍</h3><p>是用于寻找给定加权图中顶点间的最短路径的算法。</p><p>弗洛伊德算法与迪杰斯特拉算法的区别：<br>弗洛伊德算法是求解每个顶点(每一个顶点都是出发顶点)到其他各顶点的最短路径问题，而迪杰斯特拉算法是求其中一个顶点(出发顶点)到其他顶点的最短路径问题。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>算法步骤：</p><ol><li>设置顶点vi到顶点vk的最短路径已知为Lik,顶点vk到vj的最短路径已知为Lkj,顶点vi到vj的路径为Lij，则vi到vj的最短路径为：min((Lik+Lkj),Lij)，vk的取值为图中所有的顶点，则可获得vi到vj的最短路径；</li><li>vi到vk的最短路径Lik或者vk到vj的最短路径Lkj以上述同样方式获得。</li></ol><p>算法应用案例：</p><ol><li>有7个村庄（A,B,C,D,E,F,G），现在需要求每个村庄到其他村庄路径最短距离？</li><li>比如A到其他所有村庄的最短距离，B到其他所有村庄的最短距离？</li></ol><p><img src="/images/algorithm_img/road.png" alt="村庄"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>弗洛伊德应用案例代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/25</span></span><br><span class="line"><span class="comment">* @功能：使用弗洛伊德算法求解各顶点到其他顶点最短路径问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> floyd;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FloydAlgorithm</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = <span class="number">65535</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">char</span>[] vertexArray = &#123; <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>,  <span class="string">'G'</span> &#125;;</span><br><span class="line">           <span class="keyword">int</span>[][] graphEdgesValues = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123; INF, <span class="number">5</span>, <span class="number">7</span>,  INF, INF, INF, <span class="number">2</span> &#125;, &#123; <span class="number">5</span>, INF, INF, <span class="number">9</span>, INF, INF, <span class="number">3</span> &#125;,</span><br><span class="line">                     &#123; <span class="number">7</span>, INF, INF, INF, <span class="number">8</span>, INF, INF &#125;, &#123; INF,  <span class="number">9</span>, INF, INF, INF, <span class="number">4</span>, INF &#125;, &#123; INF, INF, <span class="number">8</span>, INF, INF, <span class="number">5</span>, <span class="number">4</span> &#125;,</span><br><span class="line">                     &#123; INF, INF, INF, <span class="number">4</span>, <span class="number">5</span>, INF, <span class="number">6</span> &#125;, &#123; <span class="number">2</span>, <span class="number">3</span>,  INF, INF, <span class="number">4</span>, <span class="number">6</span>, INF &#125;, &#125;;</span><br><span class="line">           Graph graph = <span class="keyword">new</span> Graph(vertexArray.length,  vertexArray, graphEdgesValues);</span><br><span class="line">           graph.floyd();</span><br><span class="line">           graph.showGraph();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 图的顶点数</span></span><br><span class="line">     <span class="keyword">int</span> graphVertexNum;</span><br><span class="line">     <span class="comment">// 图的顶点数组</span></span><br><span class="line">     <span class="keyword">char</span>[] graphVertexValues;</span><br><span class="line">     <span class="comment">// 图的顶点之间的距离二维数组</span></span><br><span class="line">     <span class="keyword">int</span>[][] graphVertexDistance;</span><br><span class="line">     <span class="comment">// 图的前驱顶点的二维数组</span></span><br><span class="line">     <span class="keyword">int</span>[][] graphVertexPreNode;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> vNum, <span class="keyword">char</span>[] vertexArray, <span class="keyword">int</span>[][] Matrix)</span>  </span>&#123;</span><br><span class="line">           <span class="comment">// 初始化数组的长度</span></span><br><span class="line">           <span class="keyword">this</span>.graphVertexNum = vNum;</span><br><span class="line">           <span class="keyword">this</span>.graphVertexValues = <span class="keyword">new</span> <span class="keyword">char</span>[graphVertexNum];</span><br><span class="line">           <span class="keyword">this</span>.graphVertexDistance = <span class="keyword">new</span>  <span class="keyword">int</span>[graphVertexNum][graphVertexNum];</span><br><span class="line">           <span class="keyword">this</span>.graphVertexPreNode = <span class="keyword">new</span>  <span class="keyword">int</span>[graphVertexNum][graphVertexNum];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graphVertexNum; i++) &#123;</span><br><span class="line">                <span class="keyword">this</span>.graphVertexValues[i] = vertexArray[i];</span><br><span class="line">                <span class="comment">//给每一个起始点对应其他顶点的前驱顶点赋值</span></span><br><span class="line">                Arrays.fill(graphVertexPreNode[i], i);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphVertexNum; j++) &#123;</span><br><span class="line">                     graphVertexDistance[i][j] = Matrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 显示图的效果</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graphVertexNum; i++) &#123;</span><br><span class="line">                <span class="comment">// 显示起始顶点到达的终点顶点的前驱顶点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphVertexNum; j++) &#123;</span><br><span class="line">                     System.out.print(graphVertexValues[graphVertexPreNode[i][j]]+<span class="string">"\t"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="comment">// 显示起始点到达其他顶点的最短路径长度</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; graphVertexNum; k++) &#123;</span><br><span class="line">                     System.out.print(graphVertexValues[i] +  <span class="string">"-&gt;"</span> + graphVertexValues[k] + <span class="string">" :"</span> + graphVertexDistance[i][k]+<span class="string">"  | "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"\n"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//弗洛伊德算法核心代码</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//第一层循环,遍历中间顶点</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;graphVertexNum;k++) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//第二层循环,遍历起始顶点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graphVertexNum;i++) &#123;</span><br><span class="line">                     <span class="comment">//第三层循环,遍历终点顶点</span></span><br><span class="line">                     <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;graphVertexNum;j++) &#123;</span><br><span class="line">                           <span class="comment">//记录从起始顶点经中间顶点到终点顶点的路径长度</span></span><br><span class="line">                           <span class="keyword">int</span>  len=graphVertexDistance[i][k]+graphVertexDistance[k][j];</span><br><span class="line">                           <span class="keyword">if</span>(len&lt;graphVertexDistance[i][j]) &#123;</span><br><span class="line">                                graphVertexDistance[i][j]=len;</span><br><span class="line">                                <span class="comment">//更新前驱顶点</span></span><br><span class="line">                                graphVertexPreNode[i][j]=graphVertexPreNode[k][j];</span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法-迪杰斯特拉算法-最短路径问题</title>
      <link>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</link>
      <guid>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Tue, 28 Jul 2020 10:22:36 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;迪杰斯特拉算法介绍&quot;&gt;&lt;a href=&quot;#迪杰斯特拉算法介绍&quot; class=&quot;headerlink&quot; title=&quot;迪杰斯特拉算法介绍&quot;&gt;&lt;/a&gt;迪杰斯特拉算法介绍&lt;/h3&gt;&lt;p&gt;迪杰斯特拉算法是典型的最短路径算法，用于计算一个节点到其他节点的最短路径，它的主要特点是以起始点为中心向外层以广度优先搜索思想扩展，直到扩展到终点为止。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="迪杰斯特拉算法介绍"><a href="#迪杰斯特拉算法介绍" class="headerlink" title="迪杰斯特拉算法介绍"></a>迪杰斯特拉算法介绍</h3><p>迪杰斯特拉算法是典型的最短路径算法，用于计算一个节点到其他节点的最短路径，它的主要特点是以起始点为中心向外层以广度优先搜索思想扩展，直到扩展到终点为止。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>迪杰斯特拉算法步骤：</p><ol><li>设置出发顶点为v，顶点集合V{v1,v2,vi…},v到V中各顶点的距离构成距离集合Dis,Dis{d1,d2,di…},Dis集合记录着v到途中各顶点的距离(到自身看作0，v到vi距离对应为di)；</li><li>从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi，此时的v到vi即为最短路径；</li><li>更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值比较小的一个，同时更新顶点的前驱节点为vi，表明是通过vi到达的；</li><li>重复执行步骤2和步骤3，直到最短路径顶点为目标顶点即可结束。</li></ol><p>问题实例：</p><ol><li>有7个村庄（A,B,C,D,E,F,G），现在需要求村庄G到其他村庄路径最短距离？</li></ol><p><img src="/images/algorithm_img/road.png" alt="村庄"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/24</span></span><br><span class="line"><span class="comment">* @功能：使用迪杰斯特拉算法解决顶点到各个点最短路径的求法问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> dijkstra;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DijkstraAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = <span class="number">65535</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] graphVertexValues = &#123; <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] graphEdgesValues = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123; INF, <span class="number">5</span>, <span class="number">7</span>, INF, INF, INF, <span class="number">2</span> &#125;, &#123; <span class="number">5</span>, INF, INF, <span class="number">9</span>, INF, INF, <span class="number">3</span> &#125;,</span><br><span class="line">                &#123; <span class="number">7</span>, INF, INF, INF, <span class="number">8</span>, INF, INF &#125;, &#123; INF, <span class="number">9</span>, INF, INF, INF, <span class="number">4</span>, INF &#125;, &#123; INF, INF, <span class="number">8</span>, INF, INF, <span class="number">5</span>, <span class="number">4</span> &#125;,</span><br><span class="line">                &#123; INF, INF, INF, <span class="number">4</span>, <span class="number">5</span>, INF, <span class="number">6</span> &#125;, &#123; <span class="number">2</span>, <span class="number">3</span>, INF, INF, <span class="number">4</span>, <span class="number">6</span>, INF &#125;, &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        DijkstraMethod dij = <span class="keyword">new</span> DijkstraMethod(graphVertexValues, graphEdgesValues, <span class="number">0</span>);</span><br><span class="line">        dij.showGraph();</span><br><span class="line">        <span class="comment">// 调用迪杰斯特拉算法求得顶点到各点的最短路径</span></span><br><span class="line">        dij.dijkstra();</span><br><span class="line">        <span class="comment">// 显示结果</span></span><br><span class="line">        dij.result();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义类封装迪杰斯特拉相关方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DijkstraMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    Graph graph;</span><br><span class="line">    <span class="comment">// 定义顶点访问数组</span></span><br><span class="line">    <span class="keyword">int</span>[] visited;</span><br><span class="line">    <span class="comment">// 定义初始点到各点距离数组</span></span><br><span class="line">    <span class="keyword">int</span>[] distance;</span><br><span class="line">    <span class="comment">// 定义各顶点的前驱顶点</span></span><br><span class="line">    <span class="keyword">int</span>[] preVertex;</span><br><span class="line">    <span class="comment">// 开始顶点</span></span><br><span class="line">    <span class="keyword">int</span> beginIndex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DijkstraMethod</span><span class="params">(<span class="keyword">char</span>[] graphVertexValues, <span class="keyword">int</span>[][] graphEdgesValues, <span class="keyword">int</span> beginVertex)</span> </span>&#123;</span><br><span class="line">        graph = <span class="keyword">new</span> Graph(graphVertexValues, graphEdgesValues);</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">int</span>[graph.graphVertexNum];</span><br><span class="line">        distance = <span class="keyword">new</span> <span class="keyword">int</span>[graph.graphVertexNum];</span><br><span class="line">        preVertex = <span class="keyword">new</span> <span class="keyword">int</span>[graph.graphVertexNum];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (beginVertex &lt; <span class="number">0</span> || beginVertex &gt;= graph.graphVertexNum) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"beginVertex out of range!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化开始节点各数组情况</span></span><br><span class="line">        <span class="comment">// 初始顶点已访问</span></span><br><span class="line">        <span class="keyword">this</span>.beginIndex = beginVertex;</span><br><span class="line">        visited[beginVertex] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 初始化距离数组的数值</span></span><br><span class="line">        Arrays.fill(distance, <span class="number">65535</span>);</span><br><span class="line">        distance[beginVertex] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        graph.showGraph();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dijkstra核心代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 更新开始点的距离数组等信息</span></span><br><span class="line">        updateMessage(beginIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; graph.graphVertexNum; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curIndex = getNextVertexIndex();</span><br><span class="line">            <span class="comment">// 更新开始点关联的其他点的距离数组等信息</span></span><br><span class="line">            updateMessage(curIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得下一个访问顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextVertexIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, minValue = <span class="number">65535</span>;</span><br><span class="line">        <span class="comment">// 遍历每一个顶点对应的其他顶点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.graphVertexNum; i++) &#123;</span><br><span class="line">            <span class="comment">// 若未访问且距离小于minValue</span></span><br><span class="line">            <span class="keyword">if</span> (visited[i] != <span class="number">1</span> &amp;&amp; distance[i] &lt; minValue) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                minValue = distance[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 选中访问的顶点,则标志为已经访问</span></span><br><span class="line">        visited[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新每一个顶点对应的前驱顶点数组,访问数组,距离数组的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateMessage</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.graphEdgesValues[index].length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = distance[index] + graph.graphEdgesValues[index][i];</span><br><span class="line">            <span class="keyword">if</span> (len &lt; distance[i] &amp;&amp; visited[i] != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 若当前距离可达则更新当前点到其他点的距离数组</span></span><br><span class="line">                distance[i] = len;</span><br><span class="line">                <span class="comment">// 且更新前驱顶点</span></span><br><span class="line">                preVertex[i] = index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示迪杰斯特拉算法的结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.graphVertexValues.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"顶点"</span> + graph.graphVertexValues[beginIndex] + <span class="string">"距离"</span> + graph.graphVertexValues[i] + <span class="string">"的距离为："</span></span><br><span class="line">                    + distance[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义图的属性类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 图顶点的个数</span></span><br><span class="line">    <span class="keyword">int</span> graphVertexNum;</span><br><span class="line">    <span class="comment">// 存放图顶点的数组</span></span><br><span class="line">    <span class="keyword">char</span>[] graphVertexValues;</span><br><span class="line">    <span class="comment">// 存放图中边的权值的邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span>[][] graphEdgesValues;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法初始化顶点及边的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">char</span>[] graphVertexValues, <span class="keyword">int</span>[][] graphEdgesValues)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.graphVertexNum = graphVertexValues.length;</span><br><span class="line">        <span class="keyword">this</span>.graphVertexValues = <span class="keyword">new</span> <span class="keyword">char</span>[graphVertexNum];</span><br><span class="line">        <span class="keyword">this</span>.graphEdgesValues = <span class="keyword">new</span> <span class="keyword">int</span>[graphVertexNum][graphVertexNum];</span><br><span class="line">        <span class="comment">// 初始化图顶点数组及图中边的权值的邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graphVertexNum; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.graphVertexValues[i] = graphVertexValues[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphVertexNum; j++) &#123;</span><br><span class="line">                <span class="keyword">this</span>.graphEdgesValues[i][j] = graphEdgesValues[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"**********************************GraphMatrix****************************************"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graphVertexNum; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphVertexNum; j++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%12d"</span>, graphEdgesValues[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"*************************************************************************************"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/28/%E7%AE%97%E6%B3%95-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
