<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法-马踏棋盘问题-贪心算法优化</title>
      <link href="/2020/07/28/%E7%AE%97%E6%B3%95-%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/"/>
      <url>/2020/07/28/%E7%AE%97%E6%B3%95-%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="马踏棋盘问题介绍"><a href="#马踏棋盘问题介绍" class="headerlink" title="马踏棋盘问题介绍"></a>马踏棋盘问题介绍</h3><p>在 8×8 的国际象棋棋盘上，用一个马按照马步(马走日字)跳遍整个棋盘，要求每个格子都只跳到一次，最后回到出发点。<br>马踏棋盘问题同时也是图的深度优先搜索的应用</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>策略选择：</p><ol><li>暴力搜索</li><li>贪心算法优化</li></ol><p>策略分析：<br>暴力搜索耗费时间长，使用贪心算法每次选择当前位置的所有可选位置中最少的进行前进，即对当前位置的所有位置的下一个落脚点的可选序列数量进行非递减顺序排序，从其中选择最少的前进。这样回溯速度快，总体运行时间少。</p><p>马踏棋盘问题图例：<br><img src="/images/algorithm_img/horseCheck/horseCheck.png" alt="棋盘"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>马踏棋盘问题代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/25</span></span><br><span class="line"><span class="comment">* @功能：运用贪心算法对马踏棋盘问题进行优化,比原先暴力搜索的策略效率大大增强</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> tsp;</span><br><span class="line"><span class="keyword">import</span> java.awt.Point;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HorseStepCheckBoard</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义棋盘的行数</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> X;</span><br><span class="line">     <span class="comment">// 定义棋盘的列数</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> Y;</span><br><span class="line">     <span class="comment">// 定义棋盘,每个棋位表示棋子下的第几步</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span>[][] checkBoard;</span><br><span class="line">     <span class="comment">// 定义与棋盘同样大小的二维数组,每个位置表示棋子是否走过</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">boolean</span>[][] stepVisited;</span><br><span class="line">     <span class="comment">// 定义标识马踏棋盘任务完成的标识</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">boolean</span> finished;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 初始化值</span></span><br><span class="line">           X = <span class="number">8</span>;</span><br><span class="line">           Y = <span class="number">8</span>;</span><br><span class="line">           checkBoard = <span class="keyword">new</span> <span class="keyword">int</span>[X][Y];</span><br><span class="line">           stepVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[X][Y];</span><br><span class="line">           <span class="comment">// 定义起始位置</span></span><br><span class="line">           <span class="keyword">int</span> row = <span class="number">1</span>, column = <span class="number">1</span>;</span><br><span class="line">           <span class="comment">// 开始时间</span></span><br><span class="line">           <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">           traverseCheckBoard(row - <span class="number">1</span>, column - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">           <span class="comment">// 结束时间</span></span><br><span class="line">           <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">           System.out.println(<span class="string">"完成马踏棋盘游戏花费： "</span> + (endTime -  startTime)+<span class="string">"毫秒"</span>);</span><br><span class="line">           showCheckBoard();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 输出棋盘的结果</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showCheckBoard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"***********************checkBoard***********************"</span>);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; checkBoard.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; checkBoard[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                     System.out.print(checkBoard[i][j] + <span class="string">"\t"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">"***********************checkBoard***********************"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseCheckBoard</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>  step)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 将当前位置置为已访问</span></span><br><span class="line">           checkBoard[x][y] = step;</span><br><span class="line">           stepVisited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">           <span class="comment">// 获得下一个可访问的位置</span></span><br><span class="line">           ArrayList&lt;Point&gt; next = nextPoint(<span class="keyword">new</span> Point(y, x));</span><br><span class="line">           <span class="comment">//贪心算法优化</span></span><br><span class="line">           sortPoint(next);</span><br><span class="line">           <span class="keyword">while</span> (!next.isEmpty()) &#123;</span><br><span class="line">                Point p = next.remove(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 该位置未访问才能作为下一步的棋子位置</span></span><br><span class="line">                <span class="keyword">if</span> (!stepVisited[p.x][p.y]) &#123;</span><br><span class="line">                     traverseCheckBoard(p.x, p.y, step + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 未完成则当前位置置为0且标志未访问</span></span><br><span class="line">           <span class="keyword">if</span> (!finished &amp;&amp; step &lt; X * Y) &#123;</span><br><span class="line">                checkBoard[x][y] = <span class="number">0</span>;</span><br><span class="line">                stepVisited[x][y] = <span class="keyword">false</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                finished = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 判断当前位置的下一步位置</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Point&gt; <span class="title">nextPoint</span><span class="params">(Point curPoint)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义存放可走位置的容器</span></span><br><span class="line">           ArrayList&lt;Point&gt; pointSet = <span class="keyword">new</span> ArrayList&lt;Point&gt;();</span><br><span class="line">           <span class="comment">// 定义暂存点</span></span><br><span class="line">           Point p1 = <span class="keyword">new</span> Point();</span><br><span class="line">           <span class="comment">// 左上角平日字,5号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y =  curPoint.y - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 左上角竖日字,6号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y =  curPoint.y - <span class="number">2</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 右上角竖日字,7号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y  - <span class="number">2</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 右上角平日字,0号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y  - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 右下角平日字,1号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y  + <span class="number">1</span>) &lt; Y) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 右下角竖日字,2号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y  + <span class="number">2</span>) &lt; Y) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 左下角竖日字,3号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y =  curPoint.y + <span class="number">2</span>) &lt; Y) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 左下角平日字,4号位</span></span><br><span class="line">           <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y =  curPoint.y + <span class="number">1</span>) &lt; Y) &#123;</span><br><span class="line">                pointSet.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> pointSet;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 对当前位置的下一步按照非递减排序后选择合适的位置以致减少回溯的次数</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortPoint</span><span class="params">(ArrayList&lt;Point&gt; pointSet)</span> </span>&#123;</span><br><span class="line">           pointSet.sort(<span class="keyword">new</span> Comparator&lt;Point&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">                     <span class="comment">// 获取p1的下一步所有位置个数</span></span><br><span class="line">                     <span class="keyword">int</span> count1 = nextPoint(p1).size();</span><br><span class="line">                     <span class="comment">// 获取p2的下一步所有位置个数</span></span><br><span class="line">                     <span class="keyword">int</span> count2 = nextPoint(p2).size();</span><br><span class="line">                     <span class="keyword">if</span> (count1 &lt; count2) &#123;</span><br><span class="line">                           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                     &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count1==count2) &#123;</span><br><span class="line">                           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 马踏棋盘问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-弗洛伊德算法-最短路径问题</title>
      <link href="/2020/07/28/%E7%AE%97%E6%B3%95-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/28/%E7%AE%97%E6%B3%95-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="弗洛伊德算法介绍"><a href="#弗洛伊德算法介绍" class="headerlink" title="弗洛伊德算法介绍"></a>弗洛伊德算法介绍</h3><p>是用于寻找给定加权图中顶点间的最短路径的算法。</p><p>弗洛伊德算法与迪杰斯特拉算法的区别：<br>弗洛伊德算法是求解每个顶点(每一个顶点都是出发顶点)到其他各顶点的最短路径问题，而迪杰斯特拉算法是求其中一个顶点(出发顶点)到其他顶点的最短路径问题。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>算法步骤：</p><ol><li>设置顶点vi到顶点vk的最短路径已知为Lik,顶点vk到vj的最短路径已知为Lkj,顶点vi到vj的路径为Lij，则vi到vj的最短路径为：min((Lik+Lkj),Lij)，vk的取值为图中所有的顶点，则可获得vi到vj的最短路径；</li><li>vi到vk的最短路径Lik或者vk到vj的最短路径Lkj以上述同样方式获得。</li></ol><p>算法应用案例：</p><ol><li>有7个村庄（A,B,C,D,E,F,G），现在需要求每个村庄到其他村庄路径最短距离？</li><li>比如A到其他所有村庄的最短距离，B到其他所有村庄的最短距离？</li></ol><p><img src="/images/algorithm_img/road.png" alt="村庄"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>弗洛伊德应用案例代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/25</span></span><br><span class="line"><span class="comment">* @功能：使用弗洛伊德算法求解各顶点到其他顶点最短路径问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> floyd;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FloydAlgorithm</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = <span class="number">65535</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">char</span>[] vertexArray = &#123; <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>,  <span class="string">'G'</span> &#125;;</span><br><span class="line">           <span class="keyword">int</span>[][] graphEdgesValues = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123; INF, <span class="number">5</span>, <span class="number">7</span>,  INF, INF, INF, <span class="number">2</span> &#125;, &#123; <span class="number">5</span>, INF, INF, <span class="number">9</span>, INF, INF, <span class="number">3</span> &#125;,</span><br><span class="line">                     &#123; <span class="number">7</span>, INF, INF, INF, <span class="number">8</span>, INF, INF &#125;, &#123; INF,  <span class="number">9</span>, INF, INF, INF, <span class="number">4</span>, INF &#125;, &#123; INF, INF, <span class="number">8</span>, INF, INF, <span class="number">5</span>, <span class="number">4</span> &#125;,</span><br><span class="line">                     &#123; INF, INF, INF, <span class="number">4</span>, <span class="number">5</span>, INF, <span class="number">6</span> &#125;, &#123; <span class="number">2</span>, <span class="number">3</span>,  INF, INF, <span class="number">4</span>, <span class="number">6</span>, INF &#125;, &#125;;</span><br><span class="line">           Graph graph = <span class="keyword">new</span> Graph(vertexArray.length,  vertexArray, graphEdgesValues);</span><br><span class="line">           graph.floyd();</span><br><span class="line">           graph.showGraph();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 图的顶点数</span></span><br><span class="line">     <span class="keyword">int</span> graphVertexNum;</span><br><span class="line">     <span class="comment">// 图的顶点数组</span></span><br><span class="line">     <span class="keyword">char</span>[] graphVertexValues;</span><br><span class="line">     <span class="comment">// 图的顶点之间的距离二维数组</span></span><br><span class="line">     <span class="keyword">int</span>[][] graphVertexDistance;</span><br><span class="line">     <span class="comment">// 图的前驱顶点的二维数组</span></span><br><span class="line">     <span class="keyword">int</span>[][] graphVertexPreNode;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> vNum, <span class="keyword">char</span>[] vertexArray, <span class="keyword">int</span>[][] Matrix)</span>  </span>&#123;</span><br><span class="line">           <span class="comment">// 初始化数组的长度</span></span><br><span class="line">           <span class="keyword">this</span>.graphVertexNum = vNum;</span><br><span class="line">           <span class="keyword">this</span>.graphVertexValues = <span class="keyword">new</span> <span class="keyword">char</span>[graphVertexNum];</span><br><span class="line">           <span class="keyword">this</span>.graphVertexDistance = <span class="keyword">new</span>  <span class="keyword">int</span>[graphVertexNum][graphVertexNum];</span><br><span class="line">           <span class="keyword">this</span>.graphVertexPreNode = <span class="keyword">new</span>  <span class="keyword">int</span>[graphVertexNum][graphVertexNum];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graphVertexNum; i++) &#123;</span><br><span class="line">                <span class="keyword">this</span>.graphVertexValues[i] = vertexArray[i];</span><br><span class="line">                <span class="comment">//给每一个起始点对应其他顶点的前驱顶点赋值</span></span><br><span class="line">                Arrays.fill(graphVertexPreNode[i], i);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphVertexNum; j++) &#123;</span><br><span class="line">                     graphVertexDistance[i][j] = Matrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 显示图的效果</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graphVertexNum; i++) &#123;</span><br><span class="line">                <span class="comment">// 显示起始顶点到达的终点顶点的前驱顶点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphVertexNum; j++) &#123;</span><br><span class="line">                     System.out.print(graphVertexValues[graphVertexPreNode[i][j]]+<span class="string">"\t"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="comment">// 显示起始点到达其他顶点的最短路径长度</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; graphVertexNum; k++) &#123;</span><br><span class="line">                     System.out.print(graphVertexValues[i] +  <span class="string">"-&gt;"</span> + graphVertexValues[k] + <span class="string">" :"</span> + graphVertexDistance[i][k]+<span class="string">"  | "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"\n"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//弗洛伊德算法核心代码</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//第一层循环,遍历中间顶点</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;graphVertexNum;k++) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//第二层循环,遍历起始顶点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graphVertexNum;i++) &#123;</span><br><span class="line">                     <span class="comment">//第三层循环,遍历终点顶点</span></span><br><span class="line">                     <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;graphVertexNum;j++) &#123;</span><br><span class="line">                           <span class="comment">//记录从起始顶点经中间顶点到终点顶点的路径长度</span></span><br><span class="line">                           <span class="keyword">int</span>  len=graphVertexDistance[i][k]+graphVertexDistance[k][j];</span><br><span class="line">                           <span class="keyword">if</span>(len&lt;graphVertexDistance[i][j]) &#123;</span><br><span class="line">                                graphVertexDistance[i][j]=len;</span><br><span class="line">                                <span class="comment">//更新前驱顶点</span></span><br><span class="line">                                graphVertexPreNode[i][j]=graphVertexPreNode[k][j];</span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> floyd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-迪杰斯特拉算法-最短路径问题</title>
      <link href="/2020/07/28/%E7%AE%97%E6%B3%95-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/28/%E7%AE%97%E6%B3%95-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="迪杰斯特拉算法介绍"><a href="#迪杰斯特拉算法介绍" class="headerlink" title="迪杰斯特拉算法介绍"></a>迪杰斯特拉算法介绍</h3><p>迪杰斯特拉算法是典型的最短路径算法，用于计算一个节点到其他节点的最短路径，它的主要特点是以起始点为中心向外层以广度优先搜索思想扩展，直到扩展到终点为止。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>迪杰斯特拉算法步骤：</p><ol><li>设置出发顶点为v，顶点集合V{v1,v2,vi…},v到V中各顶点的距离构成距离集合Dis,Dis{d1,d2,di…},Dis集合记录着v到途中各顶点的距离(到自身看作0，v到vi距离对应为di)；</li><li>从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi，此时的v到vi即为最短路径；</li><li>更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值比较小的一个，同时更新顶点的前驱节点为vi，表明是通过vi到达的；</li><li>重复执行步骤2和步骤3，直到最短路径顶点为目标顶点即可结束。</li></ol><p>问题实例：</p><ol><li>有7个村庄（A,B,C,D,E,F,G），现在需要求村庄G到其他村庄路径最短距离？</li></ol><p><img src="/images/algorithm_img/road.png" alt="村庄"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/24</span></span><br><span class="line"><span class="comment">* @功能：使用迪杰斯特拉算法解决顶点到各个点最短路径的求法问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> dijkstra;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DijkstraAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = <span class="number">65535</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] graphVertexValues = &#123; <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] graphEdgesValues = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123; INF, <span class="number">5</span>, <span class="number">7</span>, INF, INF, INF, <span class="number">2</span> &#125;, &#123; <span class="number">5</span>, INF, INF, <span class="number">9</span>, INF, INF, <span class="number">3</span> &#125;,</span><br><span class="line">                &#123; <span class="number">7</span>, INF, INF, INF, <span class="number">8</span>, INF, INF &#125;, &#123; INF, <span class="number">9</span>, INF, INF, INF, <span class="number">4</span>, INF &#125;, &#123; INF, INF, <span class="number">8</span>, INF, INF, <span class="number">5</span>, <span class="number">4</span> &#125;,</span><br><span class="line">                &#123; INF, INF, INF, <span class="number">4</span>, <span class="number">5</span>, INF, <span class="number">6</span> &#125;, &#123; <span class="number">2</span>, <span class="number">3</span>, INF, INF, <span class="number">4</span>, <span class="number">6</span>, INF &#125;, &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        DijkstraMethod dij = <span class="keyword">new</span> DijkstraMethod(graphVertexValues, graphEdgesValues, <span class="number">0</span>);</span><br><span class="line">        dij.showGraph();</span><br><span class="line">        <span class="comment">// 调用迪杰斯特拉算法求得顶点到各点的最短路径</span></span><br><span class="line">        dij.dijkstra();</span><br><span class="line">        <span class="comment">// 显示结果</span></span><br><span class="line">        dij.result();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义类封装迪杰斯特拉相关方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DijkstraMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    Graph graph;</span><br><span class="line">    <span class="comment">// 定义顶点访问数组</span></span><br><span class="line">    <span class="keyword">int</span>[] visited;</span><br><span class="line">    <span class="comment">// 定义初始点到各点距离数组</span></span><br><span class="line">    <span class="keyword">int</span>[] distance;</span><br><span class="line">    <span class="comment">// 定义各顶点的前驱顶点</span></span><br><span class="line">    <span class="keyword">int</span>[] preVertex;</span><br><span class="line">    <span class="comment">// 开始顶点</span></span><br><span class="line">    <span class="keyword">int</span> beginIndex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DijkstraMethod</span><span class="params">(<span class="keyword">char</span>[] graphVertexValues, <span class="keyword">int</span>[][] graphEdgesValues, <span class="keyword">int</span> beginVertex)</span> </span>&#123;</span><br><span class="line">        graph = <span class="keyword">new</span> Graph(graphVertexValues, graphEdgesValues);</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">int</span>[graph.graphVertexNum];</span><br><span class="line">        distance = <span class="keyword">new</span> <span class="keyword">int</span>[graph.graphVertexNum];</span><br><span class="line">        preVertex = <span class="keyword">new</span> <span class="keyword">int</span>[graph.graphVertexNum];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (beginVertex &lt; <span class="number">0</span> || beginVertex &gt;= graph.graphVertexNum) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"beginVertex out of range!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化开始节点各数组情况</span></span><br><span class="line">        <span class="comment">// 初始顶点已访问</span></span><br><span class="line">        <span class="keyword">this</span>.beginIndex = beginVertex;</span><br><span class="line">        visited[beginVertex] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 初始化距离数组的数值</span></span><br><span class="line">        Arrays.fill(distance, <span class="number">65535</span>);</span><br><span class="line">        distance[beginVertex] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        graph.showGraph();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dijkstra核心代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 更新开始点的距离数组等信息</span></span><br><span class="line">        updateMessage(beginIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; graph.graphVertexNum; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curIndex = getNextVertexIndex();</span><br><span class="line">            <span class="comment">// 更新开始点关联的其他点的距离数组等信息</span></span><br><span class="line">            updateMessage(curIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得下一个访问顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextVertexIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, minValue = <span class="number">65535</span>;</span><br><span class="line">        <span class="comment">// 遍历每一个顶点对应的其他顶点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.graphVertexNum; i++) &#123;</span><br><span class="line">            <span class="comment">// 若未访问且距离小于minValue</span></span><br><span class="line">            <span class="keyword">if</span> (visited[i] != <span class="number">1</span> &amp;&amp; distance[i] &lt; minValue) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                minValue = distance[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 选中访问的顶点,则标志为已经访问</span></span><br><span class="line">        visited[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新每一个顶点对应的前驱顶点数组,访问数组,距离数组的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateMessage</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.graphEdgesValues[index].length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = distance[index] + graph.graphEdgesValues[index][i];</span><br><span class="line">            <span class="keyword">if</span> (len &lt; distance[i] &amp;&amp; visited[i] != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 若当前距离可达则更新当前点到其他点的距离数组</span></span><br><span class="line">                distance[i] = len;</span><br><span class="line">                <span class="comment">// 且更新前驱顶点</span></span><br><span class="line">                preVertex[i] = index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示迪杰斯特拉算法的结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.graphVertexValues.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"顶点"</span> + graph.graphVertexValues[beginIndex] + <span class="string">"距离"</span> + graph.graphVertexValues[i] + <span class="string">"的距离为："</span></span><br><span class="line">                    + distance[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义图的属性类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 图顶点的个数</span></span><br><span class="line">    <span class="keyword">int</span> graphVertexNum;</span><br><span class="line">    <span class="comment">// 存放图顶点的数组</span></span><br><span class="line">    <span class="keyword">char</span>[] graphVertexValues;</span><br><span class="line">    <span class="comment">// 存放图中边的权值的邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span>[][] graphEdgesValues;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法初始化顶点及边的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">char</span>[] graphVertexValues, <span class="keyword">int</span>[][] graphEdgesValues)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.graphVertexNum = graphVertexValues.length;</span><br><span class="line">        <span class="keyword">this</span>.graphVertexValues = <span class="keyword">new</span> <span class="keyword">char</span>[graphVertexNum];</span><br><span class="line">        <span class="keyword">this</span>.graphEdgesValues = <span class="keyword">new</span> <span class="keyword">int</span>[graphVertexNum][graphVertexNum];</span><br><span class="line">        <span class="comment">// 初始化图顶点数组及图中边的权值的邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graphVertexNum; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.graphVertexValues[i] = graphVertexValues[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphVertexNum; j++) &#123;</span><br><span class="line">                <span class="keyword">this</span>.graphEdgesValues[i][j] = graphEdgesValues[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"**********************************GraphMatrix****************************************"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graphVertexNum; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphVertexNum; j++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%12d"</span>, graphEdgesValues[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"*************************************************************************************"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> dijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-克鲁斯卡尔算法-最小生成树</title>
      <link href="/2020/07/28/%E7%AE%97%E6%B3%95-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2020/07/28/%E7%AE%97%E6%B3%95-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="克鲁斯卡尔算法介绍"><a href="#克鲁斯卡尔算法介绍" class="headerlink" title="克鲁斯卡尔算法介绍"></a>克鲁斯卡尔算法介绍</h3><p>克鲁斯卡尔算法是求连通网的最小生成树的另一种方法。与普里姆算法不同，它的时间复杂度为O（eloge）（e为网中的边数），所以，适合于求边稀疏的网的最小生成树。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>克鲁斯卡尔算法步骤：</p><ol><li>按照边的权值从小到大顺序排序；</li><li>从排好顺序的边从小到大选择，选择最小的边加入森林中，但前提是加入的边在森林中不构成回路，直到森林变成一棵树为止。</li></ol><p>应用场景问题：</p><ol><li>某城市有7个公交站点(A,B,C,D,E,F,G)，现在需要修路把7个站点连通，站点之间的距离表示权值；</li><li>如何修路既能保证各站点连通且修建里程最短。</li></ol><p>公交站站点示意图：</p><p><img src="/images/algorithm_img/kruskal/kruskal.jpg" alt="公交站"></p><p><strong>代码难点：</strong><br>如何判断俩个顶点的终点索引相同，即如何判断是否产生回路？</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/23</span></span><br><span class="line"><span class="comment">* @功能：利用克鲁斯卡尔算法思想解决公交站里程问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> kruskal;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalAlgorithmDemo</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义边的最大值,表示俩顶点之间不可达</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义顶点的值</span></span><br><span class="line">           <span class="keyword">char</span>[] vertexValues = &#123; <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>,  <span class="string">'G'</span> &#125;;</span><br><span class="line">           <span class="comment">// 定义顶点与顶点之间的关系</span></span><br><span class="line">           <span class="keyword">int</span>[][] edgesValueMatrix = &#123;</span><br><span class="line">                                <span class="comment">/* A */</span><span class="comment">/* B */</span><span class="comment">/* C */</span><span class="comment">/* D */</span><span class="comment">/* E  */</span><span class="comment">/* F */</span><span class="comment">/* G */</span></span><br><span class="line">                     <span class="comment">/* A */</span> &#123; <span class="number">0</span>, <span class="number">12</span>, INF, INF, INF, <span class="number">16</span>, <span class="number">14</span> &#125;,</span><br><span class="line">                     <span class="comment">/* B */</span> &#123; <span class="number">12</span>, <span class="number">0</span>, <span class="number">10</span>, INF, INF, <span class="number">7</span>, INF &#125;,</span><br><span class="line">                     <span class="comment">/* C */</span> &#123; INF, <span class="number">10</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, INF &#125;,</span><br><span class="line">                     <span class="comment">/* D */</span> &#123; INF, INF, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, INF, INF &#125;,</span><br><span class="line">                     <span class="comment">/* E */</span> &#123; INF, INF, <span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span> &#125;,</span><br><span class="line">                     <span class="comment">/* F */</span> &#123; <span class="number">16</span>, <span class="number">7</span>, <span class="number">6</span>, INF, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span> &#125;,</span><br><span class="line">                     <span class="comment">/* G */</span> &#123; <span class="number">14</span>, INF, INF, INF, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span> &#125; &#125;;</span><br><span class="line">           <span class="comment">// 初始化图的顶点及边关系</span></span><br><span class="line">           CreateGraph graph = <span class="keyword">new</span>  CreateGraph(vertexValues.length, vertexValues,edgesValueMatrix);</span><br><span class="line">           graph.showGraphMatrix();</span><br><span class="line">           <span class="comment">//将所有边存入数组</span></span><br><span class="line">           graph.setEdgesArray();</span><br><span class="line">           System.out.println(<span class="string">"********************Min  Tree*************************"</span>);</span><br><span class="line">           graph.kruskal();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateGraph</span> </span>&#123;</span><br><span class="line">     <span class="comment">//定义图类的变量</span></span><br><span class="line">     DefinitionGraph graph;</span><br><span class="line">     <span class="comment">//定义边类的变量</span></span><br><span class="line">     DefinitionEdge edge;</span><br><span class="line">     <span class="comment">// 定义边的最大值,表示俩顶点之间不可达</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line">     <span class="comment">//统计边的数量</span></span><br><span class="line">     <span class="keyword">int</span> edgesCount;</span><br><span class="line">     <span class="comment">//定义存放边的数组</span></span><br><span class="line">     DefinitionEdge[] edgesArray;</span><br><span class="line">     <span class="comment">// 在构造方法中初始化图中边及顶点的属性,同时统计边的条数</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">CreateGraph</span><span class="params">(<span class="keyword">int</span> vertexNum, <span class="keyword">char</span>[] vertexValues,  <span class="keyword">int</span>[][] edgesValueMatrix)</span> </span>&#123;</span><br><span class="line">           graph = <span class="keyword">new</span> DefinitionGraph(vertexNum);</span><br><span class="line">           <span class="comment">// 给边及顶点赋值</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.vertexNum; i++) &#123;</span><br><span class="line">                graph.vertexValues[i] = vertexValues[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph.vertexNum; j++) &#123;</span><br><span class="line">                     graph.edgesValueMatrix[i][j] =  edgesValueMatrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 统计边的条数及存放边的数组</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.vertexNum; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; graph.vertexNum; j++) &#123;</span><br><span class="line">                     <span class="keyword">if</span>(graph.edgesValueMatrix[i][j]!=INF) &#123;</span><br><span class="line">                           edgesCount++;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           graph.graphEdgeNum=edgesCount;</span><br><span class="line">           </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 显示邻接矩阵</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraphMatrix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"**********************************GraphMatrix****************************************"</span>);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.vertexNum; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph.vertexNum; j++) &#123;</span><br><span class="line">                     System.out.printf(<span class="string">"%12d"</span>,  graph.edgesValueMatrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">"*************************************************************************************"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//显示边的条数</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEdgeNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> graph.graphEdgeNum;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//定义存放边的数组,将来对这个数组进行排序</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEdgesArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//定义存放边的数组</span></span><br><span class="line">           edgesArray=<span class="keyword">new</span> DefinitionEdge[getEdgeNum()];</span><br><span class="line">           <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.vertexNum; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; graph.vertexNum; j++) &#123;</span><br><span class="line">                     <span class="keyword">if</span>(graph.edgesValueMatrix[i][j]!=INF) &#123;</span><br><span class="line">                           edgesArray[count++]=<span class="keyword">new</span>  DefinitionEdge(graph.vertexValues[i], graph.vertexValues[j],  graph.edgesValueMatrix[i][j]);</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//遍历边的数量</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showEdgesArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;getEdgeNum();i++) &#123;</span><br><span class="line">                System.out.println(edgesArray[i]);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//对边的数组进行升序排序</span></span><br><span class="line">     DefinitionEdge curEdge=<span class="keyword">null</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortEdgesArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;getEdgeNum()-<span class="number">1</span>;i++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;getEdgeNum()-<span class="number">1</span>-i;j++) &#123;</span><br><span class="line">                     <span class="keyword">if</span>(edgesArray[j].curEdgesValues&gt;edgesArray[j+<span class="number">1</span>].curEdgesValues)  &#123;</span><br><span class="line">                           curEdge=edgesArray[j];</span><br><span class="line">                           edgesArray[j]=edgesArray[j+<span class="number">1</span>];</span><br><span class="line">                           edgesArray[j+<span class="number">1</span>]=curEdge;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//获得当前顶点的下标</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurVertexIndex</span><span class="params">(<span class="keyword">char</span> v)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.vertexNum;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(graph.vertexValues[i]==v) &#123;</span><br><span class="line">                     <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//设置当前顶点的终点节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEndVertexIndex</span><span class="params">(<span class="keyword">int</span>[] end,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">while</span>(end[index]!=<span class="number">0</span>) &#123;<span class="comment">//若当前顶点的终点索引为0则返回自己的索引</span></span><br><span class="line">                index= end[index];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> index;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     <span class="comment">//克鲁斯卡尔算法核心代码</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//先对边的权值排序</span></span><br><span class="line">           sortEdgesArray();</span><br><span class="line">           <span class="comment">//定义顶点的终点索引数组</span></span><br><span class="line">           <span class="keyword">int</span>[] end=<span class="keyword">new</span> <span class="keyword">int</span>[getEdgeNum()];</span><br><span class="line">           <span class="comment">//定义构成图最小生成树所需的边数</span></span><br><span class="line">           <span class="keyword">int</span> edgesCount=<span class="number">0</span>;</span><br><span class="line">           </span><br><span class="line">           DefinitionEdge[] minTree=<span class="keyword">new</span>  DefinitionEdge[getEdgeNum()];</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;getEdgeNum();i++) &#123;</span><br><span class="line">                <span class="comment">//获得当前边一个点的下标</span></span><br><span class="line">                <span class="keyword">int</span>  startVertex=getCurVertexIndex(edgesArray[i].curVertex);</span><br><span class="line">                <span class="comment">//获得当前边的另一个顶点下标</span></span><br><span class="line">                <span class="keyword">int</span>  endVErtex=getCurVertexIndex(edgesArray[i].nextVertex);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//获得当前边俩个顶点的终点下标</span></span><br><span class="line">                <span class="keyword">int</span> v1_end=getEndVertexIndex(end, startVertex);</span><br><span class="line">                <span class="keyword">int</span> v2_end=getEndVertexIndex(end, endVErtex);</span><br><span class="line">                <span class="comment">//终点下标不相等,即不构成回路</span></span><br><span class="line">                <span class="keyword">if</span>(v1_end!=v2_end) &#123;</span><br><span class="line">                     minTree[edgesCount++]=edgesArray[i];</span><br><span class="line">                     end[v1_end]=v2_end;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//构成回路则不添加</span></span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edgesCount;i++) &#123;</span><br><span class="line">                System.out.println(minTree[i]);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义边的属性类,该类的实例化对象为一条边</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefinitionEdge</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义当前边的一个顶点</span></span><br><span class="line">     <span class="keyword">char</span> curVertex;</span><br><span class="line">     <span class="comment">// 定义当前边的下一个顶点</span></span><br><span class="line">     <span class="keyword">char</span> nextVertex;</span><br><span class="line">     <span class="comment">// 定义俩顶点之间边的权值</span></span><br><span class="line">     <span class="keyword">int</span> curEdgesValues;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">DefinitionEdge</span><span class="params">(<span class="keyword">char</span> curv, <span class="keyword">char</span> nextv, <span class="keyword">int</span> values)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.curVertex = curv;</span><br><span class="line">           <span class="keyword">this</span>.nextVertex = nextv;</span><br><span class="line">           <span class="keyword">this</span>.curEdgesValues = values;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"edge &lt;"</span> + curVertex + <span class="string">", "</span> + nextVertex + <span class="string">"&gt;  edgesValues="</span> + curEdgesValues;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义的图属性类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefinitionGraph</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义顶点个数</span></span><br><span class="line">     <span class="keyword">int</span> vertexNum;</span><br><span class="line">     <span class="comment">// 定义存储顶点值的数组</span></span><br><span class="line">     <span class="keyword">char</span>[] vertexValues;</span><br><span class="line">     <span class="comment">// 定义存储顶点与顶点之间权值的邻接矩阵</span></span><br><span class="line">     <span class="keyword">int</span>[][] edgesValueMatrix;</span><br><span class="line">     <span class="comment">// 定义图的边数</span></span><br><span class="line">     <span class="keyword">int</span> graphEdgeNum;</span><br><span class="line">     <span class="comment">// 构造方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">DefinitionGraph</span><span class="params">(<span class="keyword">int</span> vertexNums)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.vertexNum = vertexNums;</span><br><span class="line">           vertexValues = <span class="keyword">new</span> <span class="keyword">char</span>[vertexNum];</span><br><span class="line">           edgesValueMatrix = <span class="keyword">new</span> <span class="keyword">int</span>[vertexNum][vertexNum];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> kruskal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-普利姆算法-最小生成树</title>
      <link href="/2020/07/28/%E7%AE%97%E6%B3%95-%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2020/07/28/%E7%AE%97%E6%B3%95-%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="普利姆算法介绍"><a href="#普利姆算法介绍" class="headerlink" title="普利姆算法介绍"></a>普利姆算法介绍</h3><p>普里姆算法（Prim算法），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点（英语：Vertex (graph theory)），且其所有边的权值之和亦为最小。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>普利姆算法步骤如下：</p><ol><li>设G=(V,E)是连通图，T=(U,D)是最小生成树,V,U是顶点集合,E,D是边的集合；</li><li>若从顶点u开始构造最小生成树，则从集合V中取出顶点放入集合U中，标记顶点v的visited[u]=1;</li><li>若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边(ui，vj)加入集合D中，标记visited[vj]=1;</li><li>重复步骤2，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边；</li></ol><p>应用场景-修路问题：</p><ol><li>有7个村庄（A,B,C,D,E,F,G），现在需要修路把7个村庄连通；</li><li>各个村庄的距离用边线表示(权)，比如A-B距离5公里；</li><li>问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短？</li></ol><p><img src="/images/algorithm_img/road.png" alt="路"></p><p>修路问题本质就是最小生成树问题(Minimun Cost Spanning Tree),简称MST，给定一个带权的无向连通图，如何选取一棵生成树使得树上的所有边上权的总和为最小，这叫最小生成树。</p><ol><li>N个顶点，一定有N-1条边</li><li>包含全部顶点</li><li>N-1条边都在图中</li></ol><p>图的邻接矩阵：<br><img src="/images/algorithm_img/roadMatrix.png" alt="图的邻接矩阵"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/23</span></span><br><span class="line"><span class="comment">* @功能：利用普利姆算法思想解决修路问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> prim;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimAlgorithm</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义边的最大值,表示俩顶点之间不可达</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义顶点的值</span></span><br><span class="line">           <span class="keyword">char</span>[] vertexs = &#123; <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>  &#125;;</span><br><span class="line">           <span class="comment">// 定义顶点的个数</span></span><br><span class="line">           <span class="keyword">int</span> vertexNum = vertexs.length;</span><br><span class="line">           DefinitionGraph graph = <span class="keyword">new</span>  DefinitionGraph(vertexNum);</span><br><span class="line">          <span class="keyword">int</span>[][] graphMatrix = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123; INF, <span class="number">5</span>, <span class="number">7</span>, INF, INF, INF,  <span class="number">2</span> &#125;,</span><br><span class="line">                     &#123; <span class="number">5</span>, INF, INF, <span class="number">9</span>, INF, INF, <span class="number">3</span> &#125;, &#123; <span class="number">7</span>, INF,  INF, INF, <span class="number">8</span>, INF, INF &#125;,</span><br><span class="line">                     &#123; INF, <span class="number">9</span>, INF, INF, INF, <span class="number">4</span>, INF &#125;, &#123; INF,  INF, <span class="number">8</span>, INF, INF, <span class="number">5</span>, <span class="number">4</span> &#125;,</span><br><span class="line">                     &#123; INF, INF, INF, <span class="number">4</span>, <span class="number">5</span>, INF, <span class="number">6</span> &#125;, &#123; <span class="number">2</span>, <span class="number">3</span>,  INF, INF, <span class="number">4</span>, <span class="number">6</span>, INF &#125;, &#125;;</span><br><span class="line">           createMinimumCostSpanningTree minTree = <span class="keyword">new</span>  createMinimumCostSpanningTree();</span><br><span class="line">           <span class="comment">// 初始化图的各顶点值及边的值</span></span><br><span class="line">           minTree.createGraphMatrix(graph, vertexNum, vertexs,  graphMatrix);</span><br><span class="line">           <span class="comment">// 输出邻接矩阵</span></span><br><span class="line">           minTree.showgraphMatrix(graph);</span><br><span class="line">           <span class="comment">// 输出构造最小生成树的过程</span></span><br><span class="line">           minTree.minTree(graph, <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">createMinimumCostSpanningTree</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 生成图的邻接矩阵</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createGraphMatrix</span><span class="params">(DefinitionGraph graph, <span class="keyword">int</span>  graphVertexNum, <span class="keyword">char</span>[] vertexValue, <span class="keyword">int</span>[][] graphMatrix)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graphVertexNum; i++) &#123;</span><br><span class="line">                <span class="comment">// 给每个顶点赋值</span></span><br><span class="line">                graph.vertexValue[i] = vertexValue[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graphVertexNum; j++) &#123;</span><br><span class="line">                     <span class="comment">// 给边与边之间加上权值</span></span><br><span class="line">                     graph.graphMatrix[i][j] =  graphMatrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 显示图的邻接矩阵</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showgraphMatrix</span><span class="params">(DefinitionGraph graph)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span>[] row : graph.graphMatrix) &#123;</span><br><span class="line">                System.out.println(Arrays.toString(row));</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 显示最小连同图的路径</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">minTree</span><span class="params">(DefinitionGraph graph, <span class="keyword">int</span>  beginVertex)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义当前顶点的索引</span></span><br><span class="line">           <span class="keyword">int</span> curVertexIndex = -<span class="number">1</span>;</span><br><span class="line">           <span class="comment">// 定义当前顶点的下一个连同顶点的索引</span></span><br><span class="line">           <span class="keyword">int</span> curVertexNextIndex = -<span class="number">1</span>;</span><br><span class="line">           <span class="comment">// 定义顶点被访问的标识</span></span><br><span class="line">           <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span>  <span class="keyword">boolean</span>[graph.graphVertexNum];</span><br><span class="line">           <span class="comment">// 首先先标明当前的顶点已经被访问</span></span><br><span class="line">           visited[beginVertex] = <span class="keyword">true</span>;</span><br><span class="line">           <span class="comment">// 定义边的最小权值</span></span><br><span class="line">           <span class="keyword">int</span> minEdgeValue;</span><br><span class="line">           <span class="comment">// 最外层循环输出图的最小权边的构造过程,边数为顶点数减一</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; graph.graphVertexNum; i++) &#123;</span><br><span class="line">                minEdgeValue = <span class="number">10000</span>;</span><br><span class="line">                <span class="comment">// 里面俩层循环遍历邻接矩阵得到当前点的最小权值的边</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph.graphVertexNum; j++) &#123;</span><br><span class="line">                     <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; graph.graphVertexNum;  k++) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (visited[j] == <span class="keyword">true</span> &amp;&amp; visited[k]  == <span class="keyword">false</span> &amp;&amp; graph.graphMatrix[j][k] &lt; minEdgeValue) &#123;</span><br><span class="line">                                curVertexIndex = j;</span><br><span class="line">                                curVertexNextIndex = k;</span><br><span class="line">                                minEdgeValue =  graph.graphMatrix[j][k];</span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(</span><br><span class="line">                           <span class="string">"第"</span> + i + <span class="string">"条边：&lt; "</span> +  graph.vertexValue[curVertexIndex] + <span class="string">","</span> +  graph.vertexValue[curVertexNextIndex] + <span class="string">"&gt; ,边的权值为： "</span> +  minEdgeValue);</span><br><span class="line">                visited[curVertexNextIndex] = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefinitionGraph</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义图的顶点个数</span></span><br><span class="line">     <span class="keyword">int</span> graphVertexNum;</span><br><span class="line">     <span class="comment">// 定义顶点</span></span><br><span class="line">     <span class="keyword">char</span>[] vertexValue;</span><br><span class="line">     <span class="comment">// 定义邻接矩阵</span></span><br><span class="line">     <span class="keyword">int</span>[][] graphMatrix;</span><br><span class="line">     <span class="comment">// DefinitionGraph的构造方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">DefinitionGraph</span><span class="params">(<span class="keyword">int</span> graphVertexNum)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.graphVertexNum = graphVertexNum;</span><br><span class="line">           vertexValue = <span class="keyword">new</span> <span class="keyword">char</span>[graphVertexNum];</span><br><span class="line">           graphMatrix = <span class="keyword">new</span>  <span class="keyword">int</span>[graphVertexNum][graphVertexNum];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> prim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-贪心算法-集合覆盖问题</title>
      <link href="/2020/07/28/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E9%9B%86%E5%90%88%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/28/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E9%9B%86%E5%90%88%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="贪心算法介绍"><a href="#贪心算法介绍" class="headerlink" title="贪心算法介绍"></a>贪心算法介绍</h3><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>贪心算法一般按如下步骤进行：</p><ol><li>建立数学模型来描述问题；</li><li>把求解的问题分成若干个子问题；</li><li>对每个子问题求解，得到子问题的局部最优解，可能不是最优解；</li><li>把子问题的解局部最优解合成原来解问题的一个解。</li></ol><p>集合覆盖问题：<br>存在以下表的广播台覆盖的地区，如何让选择最少的广播台让更多的地区接收到信号？<br><img src="/images/algorithm_img/greedy/broadcastSet.png" alt="广播站覆盖地区"></p><p>步骤分析：</p><ol><li>先获取到所有广播台的所有地区序列 allAreas { 北京、上海、天津、广州、深圳、成都、杭州、大连 }；</li><li>定义最大地区匹配值maxAreaNum，循环拿到每个广播台对应覆盖地区与allAreas取交集，如果下一个广播台的areaNum&gt;maxAreaNum,则令当前广播台为最大maxAreaNum；</li><li>一个循环结束，将所有地区序列allAreas中包含maxAreaNum对应的地区清楚，同时将最大覆盖地区的广播台放入选择集合；</li><li>拿到新的地区序列，继续重复步骤2和步骤3。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/21</span></span><br><span class="line"><span class="comment">* @fuction:利用贪心算法思想完成集合覆盖问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> greedy;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreedyAlgorithm</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义广播台HashMap键值对集合,String是广播台,HashSet存放地区</span></span><br><span class="line">           HashMap&lt;String, HashSet&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span>  HashMap&lt;String, HashSet&lt;String&gt;&gt;();</span><br><span class="line">           <span class="comment">// 广播台K1</span></span><br><span class="line">           HashSet&lt;String&gt; area1 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           area1.add(<span class="string">"北京"</span>);</span><br><span class="line">           area1.add(<span class="string">"上海"</span>);</span><br><span class="line">           area1.add(<span class="string">"天津"</span>);</span><br><span class="line">           <span class="comment">// 广播台K2</span></span><br><span class="line">           HashSet&lt;String&gt; area2 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           area2.add(<span class="string">"广州"</span>);</span><br><span class="line">           area2.add(<span class="string">"北京"</span>);</span><br><span class="line">           area2.add(<span class="string">"深圳"</span>);</span><br><span class="line">           <span class="comment">// 广播台K3</span></span><br><span class="line">           HashSet&lt;String&gt; area3 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           area3.add(<span class="string">"成都"</span>);</span><br><span class="line">           area3.add(<span class="string">"上海"</span>);</span><br><span class="line">           area3.add(<span class="string">"杭州"</span>);</span><br><span class="line">           <span class="comment">// 广播台K4</span></span><br><span class="line">           HashSet&lt;String&gt; area4 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           area4.add(<span class="string">"上海"</span>);</span><br><span class="line">           area4.add(<span class="string">"天津"</span>);</span><br><span class="line">           <span class="comment">// 广播台K5</span></span><br><span class="line">           HashSet&lt;String&gt; area5 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           area5.add(<span class="string">"杭州"</span>);</span><br><span class="line">           area5.add(<span class="string">"大连"</span>);</span><br><span class="line">           broadcasts.put(<span class="string">"K1"</span>, area1);</span><br><span class="line">           broadcasts.put(<span class="string">"K2"</span>, area2);</span><br><span class="line">           broadcasts.put(<span class="string">"K3"</span>, area3);</span><br><span class="line">           broadcasts.put(<span class="string">"K4"</span>, area4);</span><br><span class="line">           broadcasts.put(<span class="string">"K5"</span>, area5);</span><br><span class="line">           <span class="comment">// 获得广播站所有城市的序列</span></span><br><span class="line">           HashSet&lt;String&gt; allAreas = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           String[] area = &#123; <span class="string">"北京"</span>, <span class="string">"上海"</span>, <span class="string">"天津"</span>, <span class="string">"广州"</span>, <span class="string">"深圳"</span>, <span class="string">"成都"</span>, <span class="string">"杭州"</span>, <span class="string">"大连"</span> &#125;;</span><br><span class="line">           <span class="keyword">for</span> (String s : area) &#123;</span><br><span class="line">                allAreas.add(s);</span><br><span class="line">           &#125;</span><br><span class="line">           Object[] result=setCoverProblem(allAreas,  broadcasts);</span><br><span class="line">           <span class="comment">// 输出最终选择结果</span></span><br><span class="line">           System.out.println(Arrays.toString(result));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Object[] setCoverProblem(HashSet&lt;String&gt;  allAreas, HashMap&lt;String, HashSet&lt;String&gt;&gt; broadcasts) &#123;</span><br><span class="line">           <span class="comment">// 选择的广播站集合</span></span><br><span class="line">           HashSet&lt;String&gt; selected = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           <span class="comment">// 展示存放城市序列的集合</span></span><br><span class="line">           HashSet&lt;String&gt; tempSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">           <span class="comment">// 定义覆盖最多城市广播站</span></span><br><span class="line">           String maxBroadcast = <span class="string">""</span>;</span><br><span class="line">           <span class="comment">// allAreas不为空则继续循环</span></span><br><span class="line">           <span class="keyword">while</span> (allAreas.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                maxBroadcast = <span class="keyword">null</span>;</span><br><span class="line">                tempSet = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 遍历获得各个广播站的键</span></span><br><span class="line">                <span class="keyword">for</span> (String key : broadcasts.keySet()) &#123;</span><br><span class="line">                     <span class="comment">// 获得当前广播站键对应的城市集合</span></span><br><span class="line">                     tempSet = broadcasts.get(key);</span><br><span class="line">                     tempSet.retainAll(allAreas);</span><br><span class="line">                     <span class="comment">// 若当前遍历到的广播站的与所有城市序列交集大于0</span></span><br><span class="line">                     <span class="comment">// 且最大城市未赋值或者当前遍历到的广播站与所有城市序列的交集大于最大广播站城市序列</span></span><br><span class="line">                     <span class="keyword">if</span> (tempSet.size() &gt; <span class="number">0</span></span><br><span class="line">                                &amp;&amp; (maxBroadcast == <span class="keyword">null</span> ||  tempSet.size() &gt; broadcasts.get(maxBroadcast).size())) &#123;</span><br><span class="line">                           maxBroadcast = key;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (maxBroadcast != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// 当前循环的相对最优选择被选中</span></span><br><span class="line">                     selected.add(maxBroadcast);</span><br><span class="line">                     <span class="comment">// 删除当前所有城市序列的的被选中城市,准备进入下一次选择</span></span><br><span class="line">                     allAreas.removeAll(broadcasts.get(maxBroadcast));</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> selected.toArray();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-KMP算法</title>
      <link href="/2020/07/28/%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/"/>
      <url>/2020/07/28/%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="KMP算法介绍"><a href="#KMP算法介绍" class="headerlink" title="KMP算法介绍"></a>KMP算法介绍</h3><p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作，简称KMP算法。<br>KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。<br>具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n)。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>BF(Brute Force)算法和KMP算法的对比：<br>BF算法步骤：</p><ol><li>BF算法通过暴力匹配的方式，让文本串和模式串的每一个字符匹配；</li><li>匹配成功，则同时让文本串和模式串的当前索引 i 和 j移动到下一个字符的位置；</li><li>匹配失败，则令j回到初始位置，i移动到不匹配的字符的下一个位置，即 i-j+1的位置。<br>缺点：匹配速度慢，i回溯的位置重复匹配，效率低。</li></ol><p>KMP算法步骤：<br>比较详细的一篇文章： <a href="https://www.cnblogs.com/zzuuoo666/p/9028287.html" target="_blank" rel="noopener">比较详细的KMP算法文章</a><br>相对BF算法解决的问题：</p><ol><li>主要不是让文本串的索引 i 回溯，而是让模式串的 j 依据最大长度表来改变 j 的值，让模式串移动匹配文本串。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>BF算法实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/21</span></span><br><span class="line"><span class="comment">* @function:bf算法,和kmp算法形成比对</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> kmp;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BFAlgorithm</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           String str1 = <span class="string">"BBC ABCDAB ABCDABCDABDE"</span>;</span><br><span class="line">           String str2 = <span class="string">"ABCDABD"</span>;</span><br><span class="line">           <span class="keyword">int</span> index = bf(str1, str2);</span><br><span class="line">           System.out.println(<span class="string">"index= "</span> + index);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bf</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//i为文本串索引,j为模式串索引</span></span><br><span class="line">           <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span>(i&lt;str1.length()&amp;&amp;j&lt;str2.length()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(str1.charAt(i)==str2.charAt(j)) &#123;</span><br><span class="line">                     i++;</span><br><span class="line">                     j++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                     i=i-j+<span class="number">1</span>;</span><br><span class="line">                     j=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当j等于str2的长度则返回在str1的首个字符匹配的索引</span></span><br><span class="line">                <span class="keyword">if</span>(j==str2.length()) &#123;</span><br><span class="line">                     <span class="keyword">return</span> i-j;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KMP算法实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/21</span></span><br><span class="line"><span class="comment">* @function:实现KMP算法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> kmp;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMPAlgorithm</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           String str1 = <span class="string">"BBC ABCDAB ABCDABCDABDE"</span>;</span><br><span class="line">           String str2 = <span class="string">"ABCDABD"</span>;</span><br><span class="line">           <span class="comment">//String str2 = "BBC";</span></span><br><span class="line">           <span class="keyword">int</span>[] table = matchTable(str2);</span><br><span class="line">           <span class="keyword">int</span> index = kmp(str1, str2, table);</span><br><span class="line">           System.out.println(<span class="string">"index= "</span> + index);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(String str1, String str2, <span class="keyword">int</span>[]  table)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str1.charAt(i) !=  str2.charAt(j)) &#123;</span><br><span class="line">                     <span class="comment">//若当前文本串索引的字符与模式串索引字符不匹配;</span></span><br><span class="line">                     <span class="comment">//则令j的值为最大长度表前一个匹配的最大前缀后缀长度匹配值;</span></span><br><span class="line">                     <span class="comment">//举例子：比如当前模式串最后一个字符D与文本串索引17的字符C不匹配,</span></span><br><span class="line">                     <span class="comment">//但是最大长度匹配表中字符串ABCDAB的前缀后缀最大匹配长度为2,</span></span><br><span class="line">                     <span class="comment">//则意味则模式串前俩个字符AB不必再与文本串第15,16索引匹配,直接向下移动当前j=6,j-2个位置,</span></span><br><span class="line">                     <span class="comment">//则现在模式串的前俩个字符AB刚好与文本串第15,16的索引AB对应,模式串从第2个索引C开始和文本串第17个索引开始匹配</span></span><br><span class="line">                     j = table[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">                     j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == str2.length()) &#123;</span><br><span class="line">                     <span class="comment">// j等于str2的长度则返回在str1中位置开头字符索引</span></span><br><span class="line">                     <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] matchTable(String str) &#123;</span><br><span class="line">           <span class="comment">// 定义匹配表数组</span></span><br><span class="line">           <span class="keyword">int</span>[] table = <span class="keyword">new</span> <span class="keyword">int</span>[str.length()];</span><br><span class="line">           <span class="comment">// 匹配字符串第一个字母的前缀后缀匹配为零</span></span><br><span class="line">           table[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str.charAt(i) != str.charAt(j))  &#123;</span><br><span class="line">                     j = table[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (str.charAt(i) == str.charAt(j)) &#123;</span><br><span class="line">                     j++;</span><br><span class="line">                &#125;</span><br><span class="line">                table[i] = j;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> table;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-动态规划算法-0-1背包问题</title>
      <link href="/2020/07/28/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95-0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/28/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95-0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="动态规划算法介绍"><a href="#动态规划算法介绍" class="headerlink" title="动态规划算法介绍"></a>动态规划算法介绍</h3><p>将大问题划分为小问题进行解决，从而一步步获取最优解的算法，同分治算法类似，先求子问题，从子问题的解得到原问题的解；<br>区别：动态规划算法的子问题往往不是独立存在的，即下一个阶段的解建立于上一阶段的解的基础上</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>动态规划算法解决0-1背包问题：<br>0-1背包问题的介绍：<br>给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。<br>待放入的物品重量及价值：<br><img src="/images/algorithm_img/dynamic/goods.png" alt="待放入物品"></p><p>策略数组：<br><img src="/images/algorithm_img/dynamic/strategyArray.png" alt="策略数组"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>0-1背包问题代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/21</span></span><br><span class="line"><span class="comment">* @function:动态规划算法实现0-1背包问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> dynamic;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnapsackProblem</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义各物品体积</span></span><br><span class="line">           <span class="keyword">int</span>[] itemWeight = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span> &#125;;</span><br><span class="line">           <span class="comment">// 定义各物品价值</span></span><br><span class="line">           <span class="keyword">int</span>[] itemValue = &#123; <span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span> &#125;;</span><br><span class="line">           <span class="comment">// 定义背包容量</span></span><br><span class="line">           <span class="keyword">int</span> weight = <span class="number">4</span>;</span><br><span class="line">           <span class="comment">// 定义物品数量</span></span><br><span class="line">           <span class="keyword">int</span> n = itemValue.length;</span><br><span class="line">           <span class="comment">// 定义二维数组表示当前容量或者当前物品背包拥有的物品最大价值</span></span><br><span class="line">           <span class="keyword">int</span>[][] val = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][weight + <span class="number">1</span>];</span><br><span class="line">           <span class="comment">// 定义二维数组中可放入的最大值标识</span></span><br><span class="line">           <span class="keyword">int</span>[][] sign = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][weight + <span class="number">1</span>];</span><br><span class="line">           <span class="comment">// 将二维数组第0行和二维数组第0列置为0</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; val.length; i++) &#123;</span><br><span class="line">                val[i][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">// 将第0列置零</span></span><br><span class="line">                val[<span class="number">0</span>][i] = <span class="number">0</span>;<span class="comment">// 将第0行置零</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; val.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 此循环不断在当前可放入的物品下,不断扩容体积,直到得到当前可放入物品下的背包物品价值最大</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; val[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                     <span class="comment">// 判断当前待添加的物品是否大于当前可容纳的体积</span></span><br><span class="line">                     <span class="keyword">if</span> (itemWeight[i - <span class="number">1</span>] &gt; j) &#123;</span><br><span class="line">                           <span class="comment">// 是,则取前一行同样体积的物品价值</span></span><br><span class="line">                           val[i][j] = val[i - <span class="number">1</span>][j];</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="comment">// val[i][j] = Math.max(val[i -</span></span><br><span class="line">                           <span class="comment">//  1][j],itemValue[i-1]+val[i-1][j-itemWeight[i-1]]);</span></span><br><span class="line">                           <span class="keyword">if</span> (val[i - <span class="number">1</span>][j] &gt; itemValue[i - <span class="number">1</span>]  + val[i - <span class="number">1</span>][j - itemWeight[i - <span class="number">1</span>]]) &#123;</span><br><span class="line">                                val[i][j] = val[i - <span class="number">1</span>][j];</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                val[i][j] = itemValue[i - <span class="number">1</span>] +  val[i - <span class="number">1</span>][j - itemWeight[i - <span class="number">1</span>]];</span><br><span class="line">                                <span class="comment">// 标识放入物品,标识为1</span></span><br><span class="line">                                sign[i][j] = <span class="number">1</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 显示二维数组</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span>[] row : val) &#123;</span><br><span class="line">                System.out.println(Arrays.toString(row));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span>[] row : sign) &#123;</span><br><span class="line">                System.out.println(Arrays.toString(row));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//显示放入物品的顺序</span></span><br><span class="line">           System.out.println(<span class="string">"=================放入物品的顺序===================="</span>);</span><br><span class="line">           <span class="keyword">int</span> i = val.length - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">int</span> j = weight;</span><br><span class="line">           <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(sign[i][j]==<span class="number">1</span>) &#123;</span><br><span class="line">                     System.out.println(<span class="string">"放入第"</span>+i+<span class="string">"个物品"</span>);</span><br><span class="line">                     j-=itemWeight[i-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-分治算法-汉诺塔问题</title>
      <link href="/2020/07/28/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95-%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/28/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95-%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="分治算法介绍"><a href="#分治算法介绍" class="headerlink" title="分治算法介绍"></a>分治算法介绍</h3><p>将一个规模为N的问题，分解成K个规模较小的的子问题，这些子问题相互独立且与原问题性质相同，求出子问题的解，合并即得到原问题的解。<br>算法思想精髓：<br>分 - 将问题分解为规模更小的子问题；<br>治 - 将这些规模更小的子问题逐个击破；<br>合 - 将已解决的子问题合并，最终得出原问题的解。</p><p>注：分治算法分解得到的子问题是独立的，区别于动态规划算法。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>分治算法实例：汉诺塔问题<br>相传在古印度圣庙中，有一种被称为汉诺塔(Hanoi)的游戏。该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置64个金盘(如下图)游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。</p><p>步骤：</p><ol><li>如果有一个盘，A-&gt;C;</li><li>如果盘数大于一个盘，先把除最下面的盘以外的盘移动到B;</li><li>接着把最底下的盘移动到C,最后再将B上面的盘移动到C</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/17</span></span><br><span class="line"><span class="comment">* @功能：分治策略解决汉诺塔问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> divide_and_conquer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hanota</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           hanota(<span class="number">6</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//分治算法解决汉诺塔</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanota</span><span class="params">(<span class="keyword">int</span> dishNum,<span class="keyword">char</span> a,<span class="keyword">char</span> b,<span class="keyword">char</span>  c)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(dishNum==<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"第 "</span>+dishNum+<span class="string">" 次移动位置 ："</span>+ a + <span class="string">" =&gt; "</span>+ c);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//1.先将最底下的盘子上面dishNum-1个盘子移动到b</span></span><br><span class="line">                hanota(dishNum-<span class="number">1</span>, a, c, b);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//2.再将最底下盘子移动到c盘</span></span><br><span class="line">                System.out.println(<span class="string">"第 "</span>+dishNum+<span class="string">" 次移动位置 ："</span>+ a + <span class="string">" =&gt; "</span>+ c);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//3.最后将b位置的盘子移动到c位置</span></span><br><span class="line">                hanota(dishNum-<span class="number">1</span>, b, a, c);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 分治策略 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-图</title>
      <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
      <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="图的介绍"><a href="#图的介绍" class="headerlink" title="图的介绍"></a>图的介绍</h3><p>图有多个节点，且其节点可以有零个或多个相邻元素，俩个节点之间的连接称为边，节点也称为顶点。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>图的深度遍历步骤分析：</p><ol><li>访问当前节点v1,并将其节点置为已访问；</li><li>查找当前节点的下一个邻接节点v2；</li><li>若v2存在则继续第4步，若v不存在则回到第一步，将从v1的当一个节点继续；</li><li>若v2未被访问，则继续深度优先遍历递归；</li><li>查找顶点v1的v2的下一个邻接节点；</li></ol><p>图的广度遍历步骤分析：</p><ol><li>访问并输出当前节点v1，并将其置为已访问，其索引入队列，该队列记录访问顶点顺序的索引下标；</li><li>队列不为空，进入循环，弹出队列头节点，得到头节点的下一个节点的索引，并入队列；</li><li>若该索引为-1，表示为彻底广度探索完该节点，该节点已经无邻接节点，继续执行步骤2；</li><li>若该索引不为-1，进入循环，判断该节点是否已经被访问，若已经被访问，继续访问下一个邻接节点；若没被访问则输出当前索引对应的节点，并标志该顶点已经被访问，同时该索引入队列；</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>图的深度遍历及广度遍历代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/14</span></span><br><span class="line"><span class="comment">*       功能：完成图的深度遍历与广度遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphDemo</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义存放顶点的集合</span></span><br><span class="line">     <span class="keyword">private</span> ArrayList&lt;String&gt; vertexSet;</span><br><span class="line">     <span class="comment">// 定义邻接矩阵数组</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span>[][] edges;</span><br><span class="line">     <span class="comment">// 定义一个数组标明顶点被访问过的的标志</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">boolean</span>[] vertexVisited;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">GraphDemo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">           vertexSet = <span class="keyword">new</span> ArrayList&lt;String&gt;(n);</span><br><span class="line">           edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           String[] vertex = &#123; <span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span> &#125;;</span><br><span class="line">           GraphDemo graph = <span class="keyword">new</span> GraphDemo(vertex.length);</span><br><span class="line">           <span class="comment">// 添加顶点进集合</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex.length; i++) &#123;</span><br><span class="line">                graph.addVertex(vertex[i]);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 连接顶点之间的边</span></span><br><span class="line">           graph.createMatrix(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">           graph.createMatrix(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">           graph.createMatrix(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">           graph.createMatrix(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">           graph.createMatrix(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">           <span class="comment">// 输出邻接矩阵</span></span><br><span class="line">           graph.showMatrix();</span><br><span class="line">           System.out.print(<span class="string">"深度遍历："</span>);</span><br><span class="line">           graph.depthTraversal();</span><br><span class="line">           System.out.println();</span><br><span class="line">           System.out.print(<span class="string">"广度遍历："</span>);</span><br><span class="line">           graph.broadTraversal();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 遍历寻找当前行的邻接节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurVertexIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getVertexNum(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (edges[index][i] &gt; <span class="number">0</span>) &#123;<span class="comment">// 表示找到邻接节点,返回索引</span></span><br><span class="line">                     <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 获取当前邻接节点的下一个邻接节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextVertexIndex</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = v2+<span class="number">1</span>; i &lt; getVertexNum(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(edges[v1][i]&gt;<span class="number">0</span>) &#123;<span class="comment">//标明在当前邻接节点访问到了下一个邻接节点,返回索引</span></span><br><span class="line">                     <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//重载广度遍历的方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           vertexVisited=<span class="keyword">new</span> <span class="keyword">boolean</span>[getVertexNum()];</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;getVertexNum();i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!vertexVisited[i]) &#123;</span><br><span class="line">                     broadTraversal(vertexVisited, i);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//广度遍历的方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadTraversal</span><span class="params">(<span class="keyword">boolean</span>[] vertexVisited,<span class="keyword">int</span>  index)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//定义一个队列</span></span><br><span class="line">           LinkedList&lt;Integer&gt; queue=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">           <span class="comment">//定义队头顶点的索引</span></span><br><span class="line">           <span class="keyword">int</span> headIndex;</span><br><span class="line">           <span class="comment">//定义邻接节点的索引</span></span><br><span class="line">           <span class="keyword">int</span> nextIndex;</span><br><span class="line">           System.out.print(<span class="string">" =&gt; "</span>+getVertex(index));</span><br><span class="line">           vertexVisited[index]=<span class="keyword">true</span>;</span><br><span class="line">           <span class="comment">//第一个顶点入队列</span></span><br><span class="line">           queue.addLast(index);</span><br><span class="line">           <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">                headIndex=queue.removeFirst();</span><br><span class="line">                <span class="comment">//获得邻接节点</span></span><br><span class="line">                nextIndex=getCurVertexIndex(headIndex);</span><br><span class="line">                <span class="keyword">while</span> (nextIndex!=-<span class="number">1</span>) &#123;</span><br><span class="line">                     <span class="keyword">if</span>(!vertexVisited[nextIndex]) &#123;</span><br><span class="line">                           System.out.print(<span class="string">" =&gt;  "</span>+getVertex(nextIndex));</span><br><span class="line">                           vertexVisited[nextIndex]=<span class="keyword">true</span>;</span><br><span class="line">                           queue.addLast(nextIndex);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">//访问下一个邻接节点</span></span><br><span class="line">                     nextIndex=getNextVertexIndex(headIndex,  nextIndex);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 重载深度遍历方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depthTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           vertexVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[getVertexNum()];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getVertexNum(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!vertexVisited[i]) &#123;</span><br><span class="line">                     depthTraversal(vertexVisited, i);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 深度遍历方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depthTraversal</span><span class="params">(<span class="keyword">boolean</span>[] vertexVisited, <span class="keyword">int</span>  index)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//输出当前顶点</span></span><br><span class="line">           System.out.print(<span class="string">" =&gt; "</span>+getVertex(index));</span><br><span class="line">           <span class="comment">//将顶点设置为已访问标志</span></span><br><span class="line">           vertexVisited[index]=<span class="keyword">true</span>;</span><br><span class="line">           <span class="comment">//获取下一个邻接节点</span></span><br><span class="line">           <span class="keyword">int</span> i=getCurVertexIndex(index);</span><br><span class="line">           <span class="keyword">while</span>(i!=-<span class="number">1</span>) &#123;<span class="comment">//i不等于-1表示仍然可以当前顶点未试探完</span></span><br><span class="line">                <span class="keyword">if</span>(!vertexVisited[i]) &#123;<span class="comment">//表示未访问过</span></span><br><span class="line">                     depthTraversal(vertexVisited, i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//访问下一个邻接节点</span></span><br><span class="line">                i=getNextVertexIndex(index, i);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 构建邻接矩阵</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createMatrix</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 邻接矩阵右上角与左下角对称,故矩阵值对称存在</span></span><br><span class="line">           edges[v1][v2] = <span class="number">1</span>;</span><br><span class="line">           edges[v2][v1] = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 往集合添加节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addVertex</span><span class="params">(String v)</span> </span>&#123;</span><br><span class="line">           vertexSet.add(v);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//获得集合中的某个顶点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getVertex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> vertexSet.get(index);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 输出邻接矩阵</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMatrix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span>[] row : edges) &#123;</span><br><span class="line">                System.out.println(Arrays.toString(row));</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 获得顶点的个数</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVertexNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> vertexSet.size();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-AVL树</title>
      <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AVL%E6%A0%91/"/>
      <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AVL%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p>AVL树也称为平衡二叉树和二叉搜索树，本身也是一棵二叉排序树；<br>具有如下特点：AVL树的左右子树的高度差绝对值不超过1，且左右子树都是平衡二叉树，AVL树解决了原先二叉排序树极端情况下查找速率慢的问题，故AVL树可以保证查询效率较高。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>功能实现：</p><ol><li>对不平衡的二叉排序树进行左旋转达到平衡；</li><li>对不平衡的二叉排序树进行右旋转达到平衡；</li><li>对不平衡的二叉排序树进行双旋转达到平衡；</li></ol><p>AVL树建立动态演示：<br><img data-src="/images/dataStructure_img/binaryTree/AVLTree.gif" alt="AVL树构建"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> lenovo</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2020/7/12</span></span><br><span class="line"><span class="comment">* 功能：AVL树的建立</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> tree.avltree;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//         int[] array = &#123; 4, 3, 6, 5, 7, 9 &#125;;//用来测试左旋转得数组</span></span><br><span class="line"><span class="comment">//         int[] array = &#123; 10,12,8,9,7,6 &#125;;//用来测试右旋转得数组</span></span><br><span class="line">           <span class="keyword">int</span>[] array = &#123; <span class="number">10</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;<span class="comment">//用来测试双旋转的数组</span></span><br><span class="line">           SelfBalanceedBinarySearchTree tree = <span class="keyword">new</span>  SelfBalanceedBinarySearchTree();</span><br><span class="line">           <span class="comment">// 构建AVL树</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                tree.binarySortTreeAddNode(<span class="keyword">new</span>  TreeNode(array[i]));</span><br><span class="line">           &#125;</span><br><span class="line">           tree.judgeTreeHeightDifference();</span><br><span class="line">           <span class="comment">// 中序遍历</span></span><br><span class="line">           tree.binarySortTreeInfixOrder();</span><br><span class="line">           System.out.println(<span class="string">"树的高度是： "</span> +  tree.getTreeHeight(tree.getRoot()));</span><br><span class="line">           System.out.println(<span class="string">"根节点的左子树高度为："</span> +  tree.getRootLeftHeight(tree.getRoot()));</span><br><span class="line">           System.out.println(<span class="string">"根节点的右子树高度为："</span> +  tree.getRootRightHeight(tree.getRoot()));</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自平衡二叉搜索树(AVL树)类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBalanceedBinarySearchTree</span> </span>&#123;</span><br><span class="line">     TreeNode root;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> root;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 添加节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binarySortTreeAddNode</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 不为null则调用添加方法</span></span><br><span class="line">                root.addNode(node);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 若root等于null则将当前要添加的节点赋值给root</span></span><br><span class="line">                root = node;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 中序遍历</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binarySortTreeInfixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                root.infixOrder();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"无法遍历,数为空"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 判断二叉排序树是否符合AVL树的特点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">judgeTreeHeightDifference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 若根节点的右子树的层数比根节点的左子树的层数大于1,则左旋转</span></span><br><span class="line">           <span class="keyword">if</span> (getRootRightHeight(getRoot()) -  getRootLeftHeight(getRoot()) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 若根节点的右子树的左子树比根节点的右子树的右子树的层数大于1,则进行右旋转</span></span><br><span class="line">                <span class="keyword">if</span> (getRoot().getRightNode() != <span class="keyword">null</span></span><br><span class="line">                           &amp;&amp;  getRootLeftHeight(getRoot().getRightNode()) &gt;  getRootRightHeight(getRoot().getRightNode())) &#123;</span><br><span class="line">                     rightRotate(root.getRightNode());</span><br><span class="line">                     leftRotate(root);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     leftRotate(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 若左子树比右子树的层数差距大于1,则右旋转</span></span><br><span class="line">           <span class="keyword">if</span> (getRootLeftHeight(getRoot()) -  getRootRightHeight(getRoot()) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 对根节点的左子树的进行判断，如果其左子树的右子树的层数比左子树的左子树层数大于1,则需先左旋转</span></span><br><span class="line">                <span class="keyword">if</span> (getRoot().getLeftNode() != <span class="keyword">null</span></span><br><span class="line">                           &amp;&amp;  getRootRightHeight(getRoot().getLeftNode()) &gt;  getRootLeftHeight(getRoot().getLeftNode())) &#123;</span><br><span class="line">                     leftRotate(root.getLeftNode());</span><br><span class="line">                     rightRotate(root);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     rightRotate(root);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 获得子树的高度</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTreeHeight</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> Math.max((node.getLeftNode() == <span class="keyword">null</span> ? <span class="number">0</span> :  getTreeHeight(node.getLeftNode())),</span><br><span class="line">                     node.getRightNode() == <span class="keyword">null</span> ? <span class="number">0</span> :  getTreeHeight(node.getRightNode())) + <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 获得根节点左子树的高度</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRootLeftHeight</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> getTreeHeight(node.getLeftNode());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 获得根节点右子树的高度</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRootRightHeight</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> getTreeHeight(node.getRightNode());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 对不平衡二叉排序树左旋转</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">(TreeNode curNode)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 1.定义一个新节点，为当前根节点的值</span></span><br><span class="line">           TreeNode newNode = <span class="keyword">new</span> TreeNode(curNode.getNo());</span><br><span class="line">           <span class="comment">// 2.将新节点的左指针指向当前节点的左子树</span></span><br><span class="line">           newNode.setLeftNode(curNode.getLeftNode());</span><br><span class="line">           <span class="comment">// 3.将新节点的右指针指向当前节点右子树的左子树</span></span><br><span class="line">           newNode.setRightNode(curNode.getRightNode().getLeftNode());</span><br><span class="line">           <span class="comment">// 4.将当前节点的右节点的值赋值给当前节点</span></span><br><span class="line">           curNode.setNo(curNode.getRightNode().getNo());</span><br><span class="line">           <span class="comment">// 5.将当前节点的右指针指向当前节点的右子树的右子树</span></span><br><span class="line">           curNode.setRightNode(curNode.getRightNode().getRightNode());</span><br><span class="line">           <span class="comment">// 6.将当前节点的左指针指向新节点</span></span><br><span class="line">           curNode.setLeftNode(newNode);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 对不平衡二叉排序树右旋转</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">(TreeNode curNode)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 1.定义一个新节点，为当前根节点的值</span></span><br><span class="line">           TreeNode newNode = <span class="keyword">new</span> TreeNode(curNode.getNo());</span><br><span class="line">           <span class="comment">// 2.将新节点的右指针指向当前节点的右子树</span></span><br><span class="line">           newNode.setRightNode(curNode.getRightNode());</span><br><span class="line">           <span class="comment">// 3.将新节点的左指针指向当前节点的左子树的右子树</span></span><br><span class="line">           newNode.setLeftNode(curNode.getLeftNode().getRightNode());</span><br><span class="line">           <span class="comment">// 4.将当前节点的左节点的值赋值给当前节点</span></span><br><span class="line">           curNode.setNo(curNode.getLeftNode().getNo());</span><br><span class="line">           <span class="comment">// 5.将当前节点的左指针指向当前节点的左指针的左指针</span></span><br><span class="line">           curNode.setLeftNode(curNode.getLeftNode().getLeftNode());</span><br><span class="line">           <span class="comment">// 6.将当前节点的右指针指向新节点</span></span><br><span class="line">           curNode.setRightNode(newNode);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 对不平衡二叉排序树双选择</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doubleRotation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AVL树节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">     <span class="keyword">private</span> TreeNode leftNode;</span><br><span class="line">     <span class="keyword">private</span> TreeNode rightNode;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.no = no;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> no;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.no = no;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getLeftNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> leftNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftNode</span><span class="params">(TreeNode leftNode)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.leftNode = leftNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getRightNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> rightNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightNode</span><span class="params">(TreeNode rightNode)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.rightNode = rightNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 重写toString方法</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"TreeNode [no="</span> + no + <span class="string">"]"</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 添加节点的方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (node.getNo() &lt; <span class="keyword">this</span>.getNo()) &#123;</span><br><span class="line">                <span class="comment">// 左递归</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.getLeftNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">this</span>.getLeftNode().addNode(node);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">// 若左指针为空则添加节点</span></span><br><span class="line">                     <span class="keyword">this</span>.setLeftNode(node);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 右递归</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.getRightNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">this</span>.getRightNode().addNode(node);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">// 若右指针为空则添加节点</span></span><br><span class="line">                     <span class="keyword">this</span>.setRightNode(node);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 中序遍历</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 左递归</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.getLeftNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getLeftNode().infixOrder();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 打印当前节点</span></span><br><span class="line">           System.out.println(<span class="keyword">this</span>);</span><br><span class="line">           <span class="comment">// 右递归</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.getRightNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getRightNode().infixOrder();</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> AVL树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-二叉排序树</title>
      <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
      <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="二叉排序树介绍"><a href="#二叉排序树介绍" class="headerlink" title="二叉排序树介绍"></a>二叉排序树介绍</h3><p>对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，且右节点的值比当前节点的大。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>功能实现： </p><ul><li>完成二叉排序树的建立</li><li>对二叉排序树的节点进行删除</li></ul><p>对二叉排序树的节点进行删除的步骤分析：</p><h4 id="情况一，删除叶子节点"><a href="#情况一，删除叶子节点" class="headerlink" title="情况一，删除叶子节点"></a>情况一，删除叶子节点</h4><ol><li>找到待删除的节点的位置；</li><li>找到待删除的节点的父节点的位置；</li><li>判断待删除节点位于父节点的左指针还是右指针指向的方向，然后将父节点指针指向的待删除节点的指针置为null，即删除成功；</li></ol><h4 id="情况二，删除非叶子节点，且该非叶子节点有一个子节点"><a href="#情况二，删除非叶子节点，且该非叶子节点有一个子节点" class="headerlink" title="情况二，删除非叶子节点，且该非叶子节点有一个子节点"></a>情况二，删除非叶子节点，且该非叶子节点有一个子节点</h4><ol><li>找到待删除的节点的位置；</li><li>找到待删除的节点的父节点的位置；</li><li>判断待删除节点位于父节点的左节点位置还是右节点位置：<ul><li>若待删除节点位于父节点的左节点位置：<ul><li>若待删除节点的子节点位于左节点位置：parent.leftNode=this.leftNode;</li><li>若待删除节点的子节点位于右节点位置：parent.leftNode=this.rightNode;</li></ul></li><li>若待删除节点位于父节点的右节点位置：<ul><li>若待删除节点的子节点位于左节点位置：parent.rightNode=this.leftNode;</li><li>若待删除节点的子节点位于右节点位置：parent.rightNode=this.rightNode;</li></ul></li></ul></li></ol><h4 id="情况三，删除非叶子节点，且该非叶子节点有俩个子节点"><a href="#情况三，删除非叶子节点，且该非叶子节点有俩个子节点" class="headerlink" title="情况三，删除非叶子节点，且该非叶子节点有俩个子节点"></a>情况三，删除非叶子节点，且该非叶子节点有俩个子节点</h4><ol><li>找到待删除的节点的位置；</li><li>找到待删除的节点的父节点的位置；</li><li>在待删除节点的右子树中找到最小的值，将其赋值给待删除节点，然后将该最小值删除；</li><li>或者在待删除节点的左子树中找到最大的值，将其赋值给待删除节点，然后将该最大值删除；</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> ajiany</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2020/7/12</span></span><br><span class="line"><span class="comment">* 功能：1.二叉排序树的建立及节点的添加</span></span><br><span class="line"><span class="comment">*      2.二叉排序树节点的删除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> tree.binarysorttree;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeDemo</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span>[] array = &#123; <span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span> &#125;;</span><br><span class="line">           BinarySortTree tree = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line">           <span class="comment">// 添加节点</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                tree.binarySortTreeAddNode(<span class="keyword">new</span>  TreeNode(array[i]));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 中序遍历</span></span><br><span class="line">           System.out.println(<span class="string">"删除前-----------------------------"</span>);</span><br><span class="line">           tree.binarySortTreeInfixOrder();</span><br><span class="line">           tree.binarySortTreeDeleteNode(<span class="number">1</span>);</span><br><span class="line">           tree.binarySortTreeDeleteNode(<span class="number">9</span>);</span><br><span class="line">           tree.binarySortTreeDeleteNode(<span class="number">5</span>);</span><br><span class="line">           tree.binarySortTreeDeleteNode(<span class="number">3</span>);</span><br><span class="line">           tree.binarySortTreeDeleteNode(<span class="number">12</span>);</span><br><span class="line">           tree.binarySortTreeDeleteNode(<span class="number">10</span>);</span><br><span class="line">           tree.binarySortTreeDeleteNode(<span class="number">7</span>);</span><br><span class="line">           tree.binarySortTreeDeleteNode(<span class="number">2</span>);</span><br><span class="line">           System.out.println(<span class="string">"删除后-----------------------------"</span>);</span><br><span class="line">           tree.binarySortTreeInfixOrder();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span> </span>&#123;</span><br><span class="line">     TreeNode root;</span><br><span class="line">     <span class="comment">// 添加节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binarySortTreeAddNode</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 不为null则调用添加方法</span></span><br><span class="line">                root.addNode(node);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 若root等于null则将当前要添加的节点赋值给root</span></span><br><span class="line">                root = node;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 中序遍历</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binarySortTreeInfixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                root.infixOrder();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"无法遍历,数为空"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 删除节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binarySortTreeDeleteNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(root.getLeftNode()==<span class="keyword">null</span>&amp;&amp;root.getRightNode()==<span class="keyword">null</span>) &#123;</span><br><span class="line">                     root=<span class="keyword">null</span>;</span><br><span class="line">                     <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获得要删除的节点</span></span><br><span class="line">                TreeNode dlNode = root.searchNode(no);</span><br><span class="line">                <span class="comment">// 获得待删除节点的父节点</span></span><br><span class="line">                TreeNode dlParentNode =  root.searchParentNode(no);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (dlNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (dlNode.getLeftNode() == <span class="keyword">null</span> &amp;&amp;  dlNode.getRightNode() == <span class="keyword">null</span>) &#123;<span class="comment">// 待删除节点为叶子节点</span></span><br><span class="line">                           <span class="comment">// 判断待删除节点位于父节点的左右位置</span></span><br><span class="line">                           <span class="keyword">if</span> (dlParentNode.getLeftNode() !=  <span class="keyword">null</span> &amp;&amp; dlParentNode.getLeftNode().getNo() == no) &#123;<span class="comment">// 待删除节点位于父节点的左子树位置</span></span><br><span class="line">                                dlParentNode.setLeftNode(<span class="keyword">null</span>);</span><br><span class="line">                           &#125; <span class="keyword">else</span> <span class="keyword">if</span>  (dlParentNode.getRightNode() != <span class="keyword">null</span> &amp;&amp;  dlParentNode.getRightNode().getNo() == no) &#123;<span class="comment">// 待删除节点位于父节点的右子树位置</span></span><br><span class="line">                                dlParentNode.setRightNode(<span class="keyword">null</span>);</span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dlNode.getLeftNode() != <span class="keyword">null</span> &amp;&amp;  dlNode.getRightNode() != <span class="keyword">null</span>) &#123;<span class="comment">// 待删除节点有左右子树</span></span><br><span class="line">                           <span class="keyword">int</span> minVal =  dlNode.findMinValueInRightTree(dlNode.getRightNode());</span><br><span class="line">                           binarySortTreeDeleteNode(minVal);</span><br><span class="line">                           dlNode.setNo(minVal);</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;<span class="comment">// 待删除节点只有一棵子树</span></span><br><span class="line">                           <span class="keyword">if</span> (dlNode.getLeftNode() != <span class="keyword">null</span>) &#123;<span class="comment">//  若待删除右节点不为null,说明待删除节点的子树在左边</span></span><br><span class="line">                                <span class="keyword">if</span> (dlParentNode != <span class="keyword">null</span>) &#123;<span class="comment">// 判断父节点是否为null</span></span><br><span class="line">                                     <span class="keyword">if</span>  (dlParentNode.getLeftNode().equals(dlNode)) &#123;<span class="comment">// 若待删除节点为父节点的左节点</span></span><br><span class="line">                                           <span class="comment">// 将待删除节点的父节点的左指针指向待删除节点的左子树</span></span><br><span class="line">                                           dlParentNode.setLeftNode(dlNode.getLeftNode());</span><br><span class="line">                                     &#125; <span class="keyword">else</span> <span class="keyword">if</span>  (dlParentNode.getRightNode().equals(dlNode)) &#123;<span class="comment">// 若待删除节点为父节点的右节点</span></span><br><span class="line">                                           <span class="comment">// 将待删除节点的父节点的右指针指向待删除节点的左子树</span></span><br><span class="line">                                           dlParentNode.setRightNode(dlNode.getLeftNode());</span><br><span class="line">                                     &#125;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                     root =  dlNode.getLeftNode();</span><br><span class="line">                                &#125;</span><br><span class="line">                           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dlNode.getRightNode() !=  <span class="keyword">null</span>) &#123;<span class="comment">// 若待删除右节点不为null,说明待删除节点的子树在右边</span></span><br><span class="line">                                <span class="keyword">if</span> (dlParentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                     <span class="keyword">if</span>  (dlParentNode.getLeftNode().equals(dlNode)) &#123;<span class="comment">// 若待删除节点为父节点的左节点</span></span><br><span class="line">                                           dlParentNode.setLeftNode(dlNode.getRightNode());</span><br><span class="line">                                     &#125; <span class="keyword">else</span> <span class="keyword">if</span>  (dlParentNode.getRightNode().equals(dlNode)) &#123;<span class="comment">// 若待删除节点为父节点的右节点</span></span><br><span class="line">                                           dlParentNode.setRightNode(dlNode.getRightNode());</span><br><span class="line">                                     &#125;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                     root =  dlNode.getRightNode();</span><br><span class="line">                                &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     System.out.println(<span class="string">"无该节点"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">     <span class="keyword">private</span> TreeNode leftNode;</span><br><span class="line">     <span class="keyword">private</span> TreeNode rightNode;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.no = no;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> no;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.no = no;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getLeftNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> leftNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftNode</span><span class="params">(TreeNode leftNode)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.leftNode = leftNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getRightNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> rightNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightNode</span><span class="params">(TreeNode rightNode)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.rightNode = rightNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 重写toString方法</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"TreeNode [no="</span> + no + <span class="string">"]"</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 添加节点的方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (node.getNo() &lt; <span class="keyword">this</span>.getNo()) &#123;</span><br><span class="line">                <span class="comment">// 左递归</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.getLeftNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">this</span>.getLeftNode().addNode(node);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">// 若左指针为空则添加节点</span></span><br><span class="line">                     <span class="keyword">this</span>.setLeftNode(node);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 右递归</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.getRightNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">this</span>.getRightNode().addNode(node);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">// 若右指针为空则添加节点</span></span><br><span class="line">                     <span class="keyword">this</span>.setRightNode(node);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 中序遍历</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 左递归</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.getLeftNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getLeftNode().infixOrder();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 打印当前节点</span></span><br><span class="line">           System.out.println(<span class="keyword">this</span>);</span><br><span class="line">           <span class="comment">// 右递归</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.getRightNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getRightNode().infixOrder();</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 找到待删除节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.getNo() == no) &#123;<span class="comment">// 当前节点即为要删除的节点</span></span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (no &lt; <span class="keyword">this</span>.getNo()) &#123;<span class="comment">// 往左边查找</span></span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">this</span>.getLeftNode().searchNode(no);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (no &gt;= <span class="keyword">this</span>.getNo()) &#123;<span class="comment">// 往右边查找</span></span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">this</span>.getRightNode().searchNode(no);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 找到待删除节点的父节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchParentNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">this</span>.getLeftNode() != <span class="keyword">null</span> &amp;&amp;  <span class="keyword">this</span>.getLeftNode().getNo() == no)</span><br><span class="line">                           || (<span class="keyword">this</span>.getRightNode() != <span class="keyword">null</span> &amp;&amp;  <span class="keyword">this</span>.getRightNode().getNo() == no)) &#123;<span class="comment">// 左子节点或者右节点为待删除的值</span></span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">// 返回父节点</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> (no &lt; <span class="keyword">this</span>.getNo() &amp;&amp;  <span class="keyword">this</span>.getLeftNode() != <span class="keyword">null</span>) &#123;<span class="comment">// 往左子树继续查找</span></span><br><span class="line">                           <span class="keyword">return</span>  <span class="keyword">this</span>.getLeftNode().searchParentNode(no);</span><br><span class="line">                     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (no &gt;= <span class="keyword">this</span>.getNo() &amp;&amp;  <span class="keyword">this</span>.getRightNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">return</span>  <span class="keyword">this</span>.getRightNode().searchParentNode(no);<span class="comment">// 往右子树继续查找</span></span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 找到右子树中最小的节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinValueInRightTree</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (node.getLeftNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                findMinValueInRightTree(node.getLeftNode());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> node.getNo();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉排序树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>赫夫曼编码</title>
      <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
      <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>赫夫曼编码是一种编码方式，是一种可变字长编码的一种。赫夫曼编码广泛用于数据文件的压缩，压缩率通常在20%~90%之间，也称最佳编码。</p><a id="more"></a><h3 id="赫夫曼编码压缩案例实践："><a href="#赫夫曼编码压缩案例实践：" class="headerlink" title="赫夫曼编码压缩案例实践："></a>赫夫曼编码压缩案例实践：</h3><p>假设有一段字符串“i like like like java do you like a java”;完成该字符串的赫夫曼编码压缩；</p><h4 id="压缩案例主要步骤"><a href="#压缩案例主要步骤" class="headerlink" title="压缩案例主要步骤"></a>压缩案例主要步骤</h4><ol><li>统计该字符串中每个字符出现的次频，包括空格，将每个字符出现的次频放入数组，对该数组进行排序，得到一个由小到大的有序数组；</li><li>针对该有序数组构建赫夫曼树，向左的路径为0，向右的路径为1；该赫夫曼树对应的每个叶子节点所在位置，即其每个字符对应的编码；</li><li>由步骤二得到字符对应的编码表，依据编码表，把字符对应的编码顺序连接成字符串；</li><li>最后把这个二进制字符串按八位压缩成一个新的字节数组，该字节数组即压缩后的序列。</li></ol><h3 id="赫夫曼编码解压案例实践，依据上述压缩的字节数组，完成解压："><a href="#赫夫曼编码解压案例实践，依据上述压缩的字节数组，完成解压：" class="headerlink" title="赫夫曼编码解压案例实践，依据上述压缩的字节数组，完成解压："></a>赫夫曼编码解压案例实践，依据上述压缩的字节数组，完成解压：</h3><h4 id="解压案例主要步骤"><a href="#解压案例主要步骤" class="headerlink" title="解压案例主要步骤"></a>解压案例主要步骤</h4><ol><li>将字节数组中每一个元素还原成二进制数；</li><li>依据编码表把编码表中字符对应的编码在二进制字符串中抽取出来，按照反序的编码表将每一个编码对应的ASCII数值放入字节数组，该字节数组即还原的字节数组。</li></ol><h3 id="其他实践"><a href="#其他实践" class="headerlink" title="其他实践"></a>其他实践</h3><ul><li>完成对文件的压缩及解压</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> ajiany</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span>:2020/7/10</span></span><br><span class="line"><span class="comment">* 功能：1.完成对字符串的赫夫曼编码压缩及解压</span></span><br><span class="line"><span class="comment">*      2.文件的压缩与解压</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> tree.huffmancode;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanCode</span> </span>&#123;</span><br><span class="line">     <span class="comment">// key为字符的ASCII值,value为字符编码</span></span><br><span class="line">     <span class="keyword">static</span> Map&lt;Byte, String&gt; singleByteCode = <span class="keyword">new</span>  HashMap&lt;Byte, String&gt;();</span><br><span class="line">     <span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//         // 压缩的字符串</span></span><br><span class="line"><span class="comment">//         String huffmanStr = "i like like like java do you  like a java";</span></span><br><span class="line"><span class="comment">//         // 将字符串对应的字符转换成对应的字节码,即ACSII码值,形成数组</span></span><br><span class="line"><span class="comment">//         byte[] strBytes = huffmanStr.getBytes();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//         // 调用压缩字符串的代码</span></span><br><span class="line"><span class="comment">//         byte[] zipCode = CompressedCharacters(strBytes);</span></span><br><span class="line"><span class="comment">//         // System.out.println(Arrays.toString(zipCode));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//         // 解码</span></span><br><span class="line"><span class="comment">//         byte[] sourceStr=deCoding(singleByteCode, zipCode);</span></span><br><span class="line"><span class="comment">//         //new String(SourceStr)将[105, 32, 108, 105,  107......]转化成字符</span></span><br><span class="line"><span class="comment">//         System.out.println(new String(sourceStr));</span></span><br><span class="line">           </span><br><span class="line">           <span class="comment">//压缩文件</span></span><br><span class="line"><span class="comment">//         String zipSrcPath="F:\\GoogleDownLoad\\ajian.txt";</span></span><br><span class="line"><span class="comment">//         String savePath="F:\\GoogleDownLoad\\ajian.zip";</span></span><br><span class="line"><span class="comment">//         zipFile(zipSrcPath, savePath);</span></span><br><span class="line">           </span><br><span class="line">           <span class="comment">//解压文件</span></span><br><span class="line"><span class="comment">//         String zipSrcPath="F:\\GoogleDownLoad\\ajian.zip";</span></span><br><span class="line"><span class="comment">//         String savePath="F:\\GoogleDownLoad\\ajian1.txt";</span></span><br><span class="line"><span class="comment">//         unZipFile(zipSrcPath, savePath);</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//解压文件</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unZipFile</span><span class="params">(String srcPath,String  savePath)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//定义输入流</span></span><br><span class="line">           InputStream is=<span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">//定义输出流</span></span><br><span class="line">           OutputStream os=<span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">//定义对象输入流</span></span><br><span class="line">           ObjectInputStream ois=<span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">                is=<span class="keyword">new</span> FileInputStream(srcPath);</span><br><span class="line">                ois=<span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line">                <span class="comment">//读取压缩的字节对象</span></span><br><span class="line">                <span class="keyword">byte</span>[] zipCodes= (<span class="keyword">byte</span>[]) ois.readObject();</span><br><span class="line">                <span class="comment">//读取编码表</span></span><br><span class="line">                Map&lt;Byte,String&gt; codeTable=(Map&lt;Byte,String&gt;)  ois.readObject();</span><br><span class="line">                <span class="comment">//解码</span></span><br><span class="line">                <span class="keyword">byte</span>[] deCodeStr=deCoding(codeTable, zipCodes);</span><br><span class="line">                <span class="comment">//保存解码后的文件路径</span></span><br><span class="line">                os=<span class="keyword">new</span> FileOutputStream(savePath);</span><br><span class="line">                os.write(deCodeStr);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">           &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                     is.close();</span><br><span class="line">                     os.close();</span><br><span class="line">                     ois.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//压缩文件</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zipFile</span><span class="params">(String srcPath,String savePath)</span>  </span>&#123;</span><br><span class="line">           <span class="comment">//定义输入流</span></span><br><span class="line">           InputStream is=<span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">//定义输出流</span></span><br><span class="line">           OutputStream os=<span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">//定义对象输出流</span></span><br><span class="line">           ObjectOutputStream oos=<span class="keyword">null</span>;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">                is=<span class="keyword">new</span> FileInputStream(srcPath);</span><br><span class="line">                <span class="keyword">byte</span>[] fileBytes=<span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">                is.read(fileBytes);</span><br><span class="line">                <span class="keyword">byte</span>[] zipCodes=CompressedCharacters(fileBytes);</span><br><span class="line">                os=<span class="keyword">new</span> FileOutputStream(savePath);</span><br><span class="line">                oos=<span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line">                <span class="comment">//将字节数组对象写入对象流</span></span><br><span class="line">                oos.writeObject(zipCodes);</span><br><span class="line">                <span class="comment">//将编码表写入对象流</span></span><br><span class="line">                oos.writeObject(singleByteCode);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">           &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                     is.close();</span><br><span class="line">                     os.close();</span><br><span class="line">                     oos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 对压缩后的二进制零一编码进行解码</span></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> newCodeContainer 编码表</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> deCode 压缩后的字节数组</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span> 返回值为解压后的字节数组</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] deCoding(Map&lt;Byte, String&gt;  newCodeContainer, <span class="keyword">byte</span>[] deCode) &#123;</span><br><span class="line">           <span class="comment">// 定义用于拼接的二进制字符串</span></span><br><span class="line">           StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">           <span class="comment">// 1.解压压缩后的字节码为二进制码</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deCode.length; i++) &#123;</span><br><span class="line">                <span class="keyword">byte</span> b = deCode[i];</span><br><span class="line">                <span class="comment">// 如果是最后一位,不补齐高位</span></span><br><span class="line">                <span class="keyword">boolean</span> flag = (i == deCode.length - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 将字节转成二进制字符串</span></span><br><span class="line">                stringBuilder.append(byteToBinaryCode(!flag,  b));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 2.按照编码表得到对应的字符的ASCII码</span></span><br><span class="line">           Map&lt;String, Byte&gt; reverBinaryCode = <span class="keyword">new</span>  HashMap&lt;String, Byte&gt;();</span><br><span class="line">           <span class="keyword">for</span> (Entry&lt;Byte, String&gt; entry :  newCodeContainer.entrySet()) &#123;</span><br><span class="line">                <span class="comment">// 将key和value值倒转</span></span><br><span class="line">                reverBinaryCode.put(entry.getValue(),  entry.getKey());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 3.根绝ASCII码得到的字符</span></span><br><span class="line">           <span class="comment">// 定义集合存放每个字符对应的ASCII码</span></span><br><span class="line">           List&lt;Byte&gt; list = <span class="keyword">new</span> ArrayList&lt;Byte&gt;();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length();) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                Byte bytes = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 遍历stringBuilder二进制字符串</span></span><br><span class="line">                <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                     String key = stringBuilder.substring(i, i  + count);</span><br><span class="line">                     bytes = reverBinaryCode.get(key);</span><br><span class="line">                     <span class="keyword">if</span> (bytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="comment">// 没有匹配到则继续向下匹配</span></span><br><span class="line">                           count++;</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           flag = <span class="keyword">false</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将ASCII码添加到集合</span></span><br><span class="line">                list.add(bytes);</span><br><span class="line">                i += count;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 4.返回byte数组</span></span><br><span class="line">           <span class="keyword">byte</span>[] sourceByte = <span class="keyword">new</span> <span class="keyword">byte</span>[list.size()];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sourceByte.length; i++) &#123;</span><br><span class="line">                sourceByte[i] = list.get(i);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> sourceByte;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 将一个byte转化位对应的二进制字符串</span></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> flag 表示是否需要补高位</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> b    要转的byte字节</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span> 返回值为8位的二进制字符串 注意：正数需要补位,负数需要取取后八位</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">byteToBinaryCode</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">byte</span>  b)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> temp = b;</span><br><span class="line">           <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                temp |= <span class="number">256</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           String str = Integer.toBinaryString(temp);</span><br><span class="line">           <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);<span class="comment">// 返回从字符串长度第倒数第八位后的反码</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> str;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 将压缩字符串的代码封装</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] CompressedCharacters(<span class="keyword">byte</span>[] strBytes)  &#123;</span><br><span class="line">           <span class="comment">// 将Map&lt;Byte,Integer&gt;每个字符及对应出现次频的节点放入List集合</span></span><br><span class="line">           List&lt;HuffmanCodeNode&gt; codeContainer =  countNumber(strBytes);</span><br><span class="line">           <span class="comment">// 构建赫夫曼树</span></span><br><span class="line">           HuffmanCodeNode root =  createHuffmanTree(codeContainer);</span><br><span class="line">           <span class="comment">// 获得存放每个字符编码的编码表</span></span><br><span class="line">           Map&lt;Byte, String&gt; newCodeContainer =  getBytesCode(root);</span><br><span class="line">           <span class="comment">// 压缩字符ASCII码对应编码</span></span><br><span class="line">           <span class="keyword">byte</span>[] zipCode = zip(strBytes, newCodeContainer);</span><br><span class="line">           <span class="keyword">return</span> zipCode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 按照编码表将字符对应的编码拼接</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] zip(<span class="keyword">byte</span>[] strBytes, Map&lt;Byte,  String&gt; newCodeContainer) &#123;</span><br><span class="line">           <span class="comment">// 压缩后的字节数组长度</span></span><br><span class="line">           <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">           <span class="comment">// 定义该字节数组的索引</span></span><br><span class="line">           <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">           <span class="comment">// 存放拼接后的零一编码字符串</span></span><br><span class="line">           StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">           <span class="comment">// 遍历strBytes数组得到每个字符对应的ASCII编码,从编码表里找到字符ASCII值对应编码并连接</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">byte</span> b : strBytes) &#123;</span><br><span class="line">                stringBuilder.append(newCodeContainer.get(b));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 计算stringBuilder按8位得到的字节数组长度</span></span><br><span class="line">           <span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 定义存放压缩后的字节数组</span></span><br><span class="line">           <span class="keyword">byte</span>[] zipHuffmanCode = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">           <span class="comment">// 将8位的零一二进制补码转换成原码</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">// 如果最后不足8位则取到最后一位即可</span></span><br><span class="line">                     zipHuffmanCode[index++] = (<span class="keyword">byte</span>)  Integer.parseInt(stringBuilder.substring(i), <span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     zipHuffmanCode[index++] = (<span class="keyword">byte</span>)  Integer.parseInt(stringBuilder.substring(i, i + <span class="number">8</span>), <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> zipHuffmanCode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 重载getBytesCode方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Byte, String&gt;  <span class="title">getBytesCode</span><span class="params">(HuffmanCodeNode root)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 向左递归</span></span><br><span class="line">           getBytesCode(root.getLeftNode(), <span class="string">"0"</span>, stringBuilder);</span><br><span class="line">           <span class="comment">// 向右递归</span></span><br><span class="line">           getBytesCode(root.getRightNode(), <span class="string">"1"</span>,  stringBuilder);</span><br><span class="line">           <span class="comment">//返回编码表</span></span><br><span class="line">           <span class="keyword">return</span> singleByteCode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 功能：得到每个字符对应的编码表</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> node          每个节点</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> code          生成的字符编码</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> stringBuilder 用来拼接的字符串编码</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getBytesCode</span><span class="params">(HuffmanCodeNode node,  String code, StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">           StringBuilder strBuilder = <span class="keyword">new</span>  StringBuilder(stringBuilder);</span><br><span class="line">           <span class="comment">// 将来自根节点的首个字符添加到字符串中</span></span><br><span class="line">           strBuilder.append(code);</span><br><span class="line">           <span class="comment">// 到达叶子节点</span></span><br><span class="line">           <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.getData() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// 已经到达叶子节点</span></span><br><span class="line">                     singleByteCode.put(node.getData(),  strBuilder.toString());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">// 向左递归</span></span><br><span class="line">                     getBytesCode(node.getLeftNode(), <span class="string">"0"</span>,  strBuilder);</span><br><span class="line">                     <span class="comment">// 向右递归</span></span><br><span class="line">                     getBytesCode(node.getRightNode(), <span class="string">"1"</span>,  strBuilder);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 功能：统计字节码数组中的字符出现的次数</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> 接收字节码数组</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span> 返回存放节点的List&lt;HuffmanCodeNode&gt;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;HuffmanCodeNode&gt; <span class="title">countNumber</span><span class="params">(<span class="keyword">byte</span>[]  strByte)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义存放每一个字符对应次频的叶子节点的集合</span></span><br><span class="line">           ArrayList&lt;HuffmanCodeNode&gt; nodesContainer = <span class="keyword">new</span>  ArrayList&lt;HuffmanCodeNode&gt;();</span><br><span class="line">           <span class="comment">// 定义HashMap容器</span></span><br><span class="line">           Map&lt;Byte, Integer&gt; node = <span class="keyword">new</span> HashMap&lt;Byte,  Integer&gt;();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">byte</span> b : strByte) &#123;</span><br><span class="line">                Integer count = node.get(b);</span><br><span class="line">                <span class="comment">// 判断字符是否已经存在</span></span><br><span class="line">                <span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// 不存在则首次添加</span></span><br><span class="line">                     node.put(b, <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">// 继续添加</span></span><br><span class="line">                     node.put(b, ++count);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 将每一个字符对应的键和值转成HuffmanCodeNode对象,并添加进List集合</span></span><br><span class="line">           <span class="keyword">for</span> (Entry&lt;Byte, Integer&gt; i : node.entrySet()) &#123;</span><br><span class="line">                nodesContainer.add(<span class="keyword">new</span>  HuffmanCodeNode(i.getKey(), i.getValue()));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> nodesContainer;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 前序遍历二叉树</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(HuffmanCodeNode root)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                root.preOrder();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"赫夫曼树为空"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 构造赫夫曼树</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HuffmanCodeNode  <span class="title">createHuffmanTree</span><span class="params">(List&lt;HuffmanCodeNode&gt; nodes)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义左右节点即父节点</span></span><br><span class="line">           HuffmanCodeNode left, right, parent;</span><br><span class="line">           <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 1.对容器中的数值进行排序</span></span><br><span class="line">                Collections.sort(nodes);</span><br><span class="line">                <span class="comment">// 2.取出前俩个最小的数值,构造新二叉树</span></span><br><span class="line">                left = nodes.get(<span class="number">0</span>);</span><br><span class="line">                right = nodes.get(<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 构造父节点</span></span><br><span class="line">                parent = <span class="keyword">new</span> HuffmanCodeNode(<span class="keyword">null</span>,  left.getTimes() + right.getTimes());</span><br><span class="line">                <span class="comment">// parent树的左右指针指向取出的俩个数值</span></span><br><span class="line">                parent.setLeftNode(left);</span><br><span class="line">                parent.setRightNode(right);</span><br><span class="line">                <span class="comment">// 3.删除原先从容器里取出的俩个最小数值,添加构造好的父节点</span></span><br><span class="line">                nodes.remove(left);</span><br><span class="line">                nodes.remove(right);</span><br><span class="line">                nodes.add(parent);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赫夫曼树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuffmanCodeNode</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">HuffmanCodeNode</span>&gt; </span>&#123;</span><br><span class="line">     <span class="comment">// 定义存放字符对应的ACSII码的变量</span></span><br><span class="line">     <span class="keyword">private</span> Byte data;</span><br><span class="line">     <span class="comment">// 定义字符出现的次数</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> times;</span><br><span class="line">     <span class="comment">// 定义左右指针</span></span><br><span class="line">     <span class="keyword">private</span> HuffmanCodeNode leftNode;</span><br><span class="line">     <span class="keyword">private</span> HuffmanCodeNode rightNode;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">HuffmanCodeNode</span><span class="params">(Byte data, <span class="keyword">int</span> times)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.data = data;</span><br><span class="line">           <span class="keyword">this</span>.times = times;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> Byte <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> data;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Byte data)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.data = data;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTimes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> times;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimes</span><span class="params">(<span class="keyword">int</span> times)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.times = times;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> HuffmanCodeNode <span class="title">getLeftNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> leftNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftNode</span><span class="params">(HuffmanCodeNode leftNode)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.leftNode = leftNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> HuffmanCodeNode <span class="title">getRightNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> rightNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightNode</span><span class="params">(HuffmanCodeNode rightNode)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.rightNode = rightNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 重写compareTo方法</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(HuffmanCodeNode o)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.times - o.times;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 重写toString方法</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"HuffmanCodeNode [data="</span> + data + <span class="string">", times="</span> +  times + <span class="string">"]"</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 前序遍历二叉树</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           System.out.println(<span class="keyword">this</span>);</span><br><span class="line">           <span class="comment">// 左子树递归</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.getLeftNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getLeftNode().preOrder();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 右子树递归</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.getRightNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getRightNode().preOrder();</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 赫夫曼编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-赫夫曼树</title>
      <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
      <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="赫夫曼树介绍"><a href="#赫夫曼树介绍" class="headerlink" title="赫夫曼树介绍"></a>赫夫曼树介绍</h3><p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度wpl(weighted path length)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>假设有一组待构建的哈夫曼树的数组如下：<br>{ 13，7，8，3，29，6，1 }</p><p>赫夫曼树的构建步骤：</p><ol><li>将数组的数组从小到大排序，每一个数据都看成最简单的二叉树；</li><li>取出排序好的数组中数值最小的俩个数值作为叶子节点构建二叉树，新的二叉树的根节点的值为俩个叶子节点的值之和；</li><li>删除数组中刚才取出的俩个数，将形成的新节点的值放入数组；</li><li>不断重复上述步骤一到步骤三的步骤，直到数组中只剩下一个值，即最终赫夫曼树的根节点。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/11</span></span><br><span class="line"><span class="comment">* 功能：赫夫曼树的建立</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> tree.huffmantree;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span>[] array = &#123; <span class="number">13</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">29</span>, <span class="number">6</span>, <span class="number">1</span> &#125;;</span><br><span class="line">           Node root = createHuffmanTree(array);</span><br><span class="line">           preOrder(root);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 前序遍历</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(node!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                node.preOrder();</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"树为空"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 构建哈夫曼树的方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义左右节点及父节点</span></span><br><span class="line">           Node nodeLeft, nodeRight, nodeParent;</span><br><span class="line">           <span class="comment">// 定义存放数组中数值的ArrayList容器,为了方便操作</span></span><br><span class="line">           List&lt;Node&gt; list = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">           <span class="comment">// 将数组中的值放入容器</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> value : array) &#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> Node(value));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 1.对容器中的数值进行排序,升序排序</span></span><br><span class="line">                Collections.sort(list);</span><br><span class="line">                <span class="comment">// 2.取出排好序的前面最小的俩个数值并得到父节点的值</span></span><br><span class="line">                nodeLeft = list.get(<span class="number">0</span>);</span><br><span class="line">                nodeRight = list.get(<span class="number">1</span>);</span><br><span class="line">                nodeParent = <span class="keyword">new</span> Node(nodeLeft.getValue() +  nodeRight.getValue());</span><br><span class="line">                <span class="comment">// 3.将parent左右指针连接刚才取出的俩个节点</span></span><br><span class="line">                nodeParent.setLeftNode(nodeLeft);</span><br><span class="line">                nodeParent.setRightNode(nodeRight);</span><br><span class="line">                <span class="comment">// 4.在原先数组中删除刚才取出的俩个数值,将父节点的值加进去</span></span><br><span class="line">                list.remove(nodeLeft);</span><br><span class="line">                list.remove(nodeRight);</span><br><span class="line">                list.add(nodeParent);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//哈夫曼树的节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> value; <span class="comment">// 节点的值</span></span><br><span class="line">     <span class="keyword">private</span> Node leftNode; <span class="comment">// 节点的左孩子节点</span></span><br><span class="line">     <span class="keyword">private</span> Node rightNode; <span class="comment">// 节点的右孩子节点</span></span><br><span class="line">     <span class="comment">// 构造方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// leftNode的getter方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Node <span class="title">getLeftNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> leftNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// rightNode的setter方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftNode</span><span class="params">(Node leftNode)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.leftNode = leftNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// rightNode的getter方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Node <span class="title">getRightNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> rightNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// rightNode的setter方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightNode</span><span class="params">(Node rightNode)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.rightNode = rightNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// value的getter方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> value;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// value的setter方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 重写toString方法</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"Node [value="</span> + value + <span class="string">"]"</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 重写compareTo方法</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.value - o.value;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 前序遍历</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//打印当前节点</span></span><br><span class="line">           System.out.print(<span class="string">" =&gt; "</span>+<span class="keyword">this</span>.value);</span><br><span class="line">           <span class="comment">// 左递归</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.getLeftNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getLeftNode().preOrder();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 右递归</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.getRightNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getRightNode().preOrder();</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 赫夫曼树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-线索化二叉树</title>
      <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h3><p>对于n个节点的二叉树，在二叉树存储结构中有n+1个空指针域，利用这些空指针域存放在某种遍历次序下该节点的前驱节点和后继节点的指针，这些指针称之为线索，即加上线索的二叉树称为线索二叉树。<br>线索二叉树有前序，中序，后序三种线索二叉树</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>优势及缺点：<br>优点：</p><ul><li>中序遍历时无需采用堆栈处理，较一般二叉树遍历速度快；且任意节点可访问前驱及后继节点；解决了之前存在叶子节点空指针域没利用上的缺点</li></ul><p>缺点：</p><ul><li>插入删除较麻烦</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/9</span></span><br><span class="line"><span class="comment">* 功能：1.实现前序中序后序线索化二叉树;</span></span><br><span class="line"><span class="comment">*      2.实现前序中序遍历线索化二叉树;</span></span><br><span class="line"><span class="comment">*      ##后序遍历线索化二叉树后序补充</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> tree;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTreeDemo</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义节点</span></span><br><span class="line">           ThreadedTreeNode root = <span class="keyword">new</span> ThreadedTreeNode(<span class="number">1</span>,  <span class="string">"ajiany"</span>);</span><br><span class="line">           ThreadedTreeNode node2 = <span class="keyword">new</span> ThreadedTreeNode(<span class="number">3</span>,  <span class="string">"Tom"</span>);</span><br><span class="line">           ThreadedTreeNode node3 = <span class="keyword">new</span> ThreadedTreeNode(<span class="number">6</span>,  <span class="string">"Jack"</span>);</span><br><span class="line">           ThreadedTreeNode node4 = <span class="keyword">new</span> ThreadedTreeNode(<span class="number">8</span>,  <span class="string">"Lisa"</span>);</span><br><span class="line">           ThreadedTreeNode node5 = <span class="keyword">new</span> ThreadedTreeNode(<span class="number">10</span>,  <span class="string">"John"</span>);</span><br><span class="line">           ThreadedTreeNode node6 = <span class="keyword">new</span> ThreadedTreeNode(<span class="number">16</span>,  <span class="string">"Asha"</span>);</span><br><span class="line">           <span class="comment">// 节点连接成二叉树</span></span><br><span class="line">           root.setLeftNode(node2);</span><br><span class="line">           root.setRightNode(node3);</span><br><span class="line">           node2.setLeftNode(node4);</span><br><span class="line">           node2.setRightNode(node5);</span><br><span class="line">           node3.setLeftNode(node6);</span><br><span class="line">           <span class="comment">// 置根节点</span></span><br><span class="line">           ThreadedBinaryTree binaryTree = <span class="keyword">new</span>  ThreadedBinaryTree(root);</span><br><span class="line">           </span><br><span class="line">           <span class="comment">/***********************************************************</span></span><br><span class="line"><span class="comment">            * 调用前序线索化二叉树的方法</span></span><br><span class="line"><span class="comment">            * binaryTree.binaryTreePreThreaded();</span></span><br><span class="line"><span class="comment">            * 遍历输出前序线索化二叉树</span></span><br><span class="line"><span class="comment">            * binaryTree.binaryTreeShowPreThreaded();</span></span><br><span class="line"><span class="comment">            *  *********************************************************</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="comment">//调用中序线索化二叉树的方法</span></span><br><span class="line">           binaryTree.binaryTreeInfixThreaded();</span><br><span class="line">           <span class="comment">//遍历输出中序线索化二叉树</span></span><br><span class="line">           binaryTree.binaryTreeShowInfixThreaded();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTree</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义根节点</span></span><br><span class="line">     ThreadedTreeNode root;</span><br><span class="line">     <span class="comment">// 构造方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ThreadedBinaryTree</span><span class="params">(ThreadedTreeNode node)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.root = node;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 前序输出线索化二叉树</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binaryTreeShowPreThreaded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.root.showPreThreadedBinaryTree(root);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 前序线索化二叉树</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binaryTreePreThreaded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.root.preThreadedBinaryTree(root);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 中序输出线索化二叉树</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binaryTreeShowInfixThreaded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.root.showInfixThreadedBinaryTree(root);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 中序线索化二叉树</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binaryTreeInfixThreaded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.root.infixThreadedBinaryTree(root);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 后序输出线索化二叉树</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binaryTreeShowPostThreaded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.root.showPostThreadedBinaryTree(root);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 后序线索化二叉树</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binaryTreePostThreaded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.root.postThreadedBinaryTree(root);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线索二叉树结点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadedTreeNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line">     <span class="keyword">private</span> ThreadedTreeNode leftNode;</span><br><span class="line">     <span class="keyword">private</span> ThreadedTreeNode rightNode;</span><br><span class="line">     <span class="comment">// 增加线索二叉树的左右节点指针类型;</span></span><br><span class="line">     <span class="comment">// 比如leftNodeType==true表示leftNode指针指向的是一个前驱节点,leftNodeType==false表示leftNode指针指向的是一个后继节点</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">boolean</span> leftNodeType;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">boolean</span> rightNodeType;</span><br><span class="line">     <span class="comment">// 定义preNode当前节点的前节点</span></span><br><span class="line">     ThreadedTreeNode preNode = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">// 构造方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ThreadedTreeNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.no = no;</span><br><span class="line">           <span class="keyword">this</span>.name = name;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// leftNodeType及rightNodeType的getter和setter方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeftNodeType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> leftNodeType;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftNodeType</span><span class="params">(<span class="keyword">boolean</span> leftNodeType)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.leftNodeType = leftNodeType;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRightNodeType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> rightNodeType;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightNodeType</span><span class="params">(<span class="keyword">boolean</span> rightNodeType)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.rightNodeType = rightNodeType;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> no;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.no = no;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> name;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.name = name;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> ThreadedTreeNode <span class="title">getLeftNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> leftNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftNode</span><span class="params">(ThreadedTreeNode leftNode)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.leftNode = leftNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> ThreadedTreeNode <span class="title">getRightNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> rightNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightNode</span><span class="params">(ThreadedTreeNode rightNode)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.rightNode = rightNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 重写toString方法</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"ThreadedTreeNode [no="</span> + no + <span class="string">", name="</span> +  name + <span class="string">"]"</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 前序输出线索化二叉树方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPreThreadedBinaryTree</span><span class="params">(ThreadedTreeNode  node)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(node);</span><br><span class="line">                <span class="comment">// 是左子树则继续下一个</span></span><br><span class="line">                <span class="keyword">while</span> (!node.isLeftNodeType()) &#123;</span><br><span class="line">                     node = node.getLeftNode();</span><br><span class="line">                     System.out.println(node);</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.getRightNode();</span><br><span class="line">                <span class="keyword">while</span> (node != <span class="keyword">null</span> &amp;&amp; !node.isRightNodeType())  &#123;</span><br><span class="line">                     node = node.getRightNode();</span><br><span class="line">                     System.out.println(node);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 前序线索化二叉树方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preThreadedBinaryTree</span><span class="params">(ThreadedTreeNode node)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 先判断根节点是否为空</span></span><br><span class="line">           <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 判断当前节点的左节点是否为空,为空则将左指针指向前一节点</span></span><br><span class="line">           <span class="keyword">if</span> (node.getLeftNode() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.setLeftNode(preNode);</span><br><span class="line">                node.setLeftNodeType(<span class="keyword">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 前一节点的右指针指向当前节点</span></span><br><span class="line">           <span class="keyword">if</span> (preNode != <span class="keyword">null</span> &amp;&amp; preNode.getRightNode() ==  <span class="keyword">null</span>) &#123;</span><br><span class="line">                preNode.setRightNode(node);</span><br><span class="line">                preNode.setRightNodeType(<span class="keyword">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           preNode = node;</span><br><span class="line">           <span class="comment">// 递归左子树,当前节点的左节点指向的是左子树才递归</span></span><br><span class="line">           <span class="keyword">if</span> (!node.isLeftNodeType()) &#123;</span><br><span class="line">                preThreadedBinaryTree(node.getLeftNode());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 递归右子树,当前节点的右节点指向的是右子树才递归</span></span><br><span class="line">           <span class="keyword">if</span> (!node.isRightNodeType()) &#123;</span><br><span class="line">                preThreadedBinaryTree(node.getRightNode());</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 中序输出线索化二叉树</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfixThreadedBinaryTree</span><span class="params">(ThreadedTreeNode  node)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// LeftNodeType == True说明node的LeftNode指针指向的是前驱节点</span></span><br><span class="line">                <span class="comment">// 找到要输出的第一个节点</span></span><br><span class="line">                <span class="keyword">while</span> (!node.isLeftNodeType()) &#123;</span><br><span class="line">                     node = node.getLeftNode();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 到达第一个节点,输出当前节点</span></span><br><span class="line">                System.out.println(node);</span><br><span class="line">                <span class="keyword">while</span> (node.isRightNodeType()) &#123;</span><br><span class="line">                     <span class="comment">// 输出后继节点</span></span><br><span class="line">                     node = node.getRightNode();</span><br><span class="line">                     System.out.println(node);</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.getRightNode();</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 中序线索化二叉树方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixThreadedBinaryTree</span><span class="params">(ThreadedTreeNode node)</span>  </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 先线索化左子树</span></span><br><span class="line">           infixThreadedBinaryTree(node.getLeftNode());</span><br><span class="line">           <span class="comment">// 线索化当前节点的左指针</span></span><br><span class="line">           <span class="keyword">if</span> (node.getLeftNode() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 若当前节点的左节点为空,则令左节点指向前驱节点preNode</span></span><br><span class="line">                node.setLeftNode(preNode);</span><br><span class="line">                <span class="comment">// 同时将左节点的连接类型置为true,即连接的是前驱节点而非左子树</span></span><br><span class="line">                node.setLeftNodeType(<span class="keyword">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 线索化当前节点的右指针</span></span><br><span class="line">           <span class="comment">// 注意：处理当前节点的右指针指向,只能待到下一个节点才能处理</span></span><br><span class="line">           <span class="comment">// 因为待到下一个节点,下一个节点的前驱节点就是当前节点，所以才能让当前节点的右指针指向下一节点</span></span><br><span class="line">           <span class="keyword">if</span> (preNode != <span class="keyword">null</span> &amp;&amp; preNode.getRightNode() ==  <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前节点的右指针指向下一节点,实际上这步操作的当前节点node为下一节点</span></span><br><span class="line">                preNode.setRightNode(node);</span><br><span class="line">                <span class="comment">// 设置状态</span></span><br><span class="line">                preNode.setRightNodeType(<span class="keyword">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 上述步骤执行结束则让当前节点成为成为前驱节点</span></span><br><span class="line">           preNode = node;</span><br><span class="line">           <span class="comment">// 递归线索化右子树</span></span><br><span class="line">           infixThreadedBinaryTree(node.getRightNode());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 后序输出线索化二叉树</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPostThreadedBinaryTree</span><span class="params">(ThreadedTreeNode  node)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 后序输出线索化二叉树情况特殊,后序补充</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 后序线索化二叉树</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postThreadedBinaryTree</span><span class="params">(ThreadedTreeNode node)</span>  </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 先线索化遍历左子树</span></span><br><span class="line">           postThreadedBinaryTree(node.getLeftNode());</span><br><span class="line">           <span class="comment">// 接着线索化右子树</span></span><br><span class="line">           postThreadedBinaryTree(node.getRightNode());</span><br><span class="line">           <span class="comment">// 当前节点的左指针指向前一节点</span></span><br><span class="line">           <span class="keyword">if</span> (node.getLeftNode() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.setLeftNode(preNode);</span><br><span class="line">                node.setLeftNodeType(<span class="keyword">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 前一节点的的右指针指向当前节点</span></span><br><span class="line">           <span class="keyword">if</span> (preNode != <span class="keyword">null</span> &amp;&amp; preNode.getRightNode() ==  <span class="keyword">null</span>) &#123;</span><br><span class="line">                preNode.setRightNode(node);</span><br><span class="line">                preNode.setRightNodeType(<span class="keyword">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           preNode = node;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线索化二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-顺序存储二叉树</title>
      <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="顺序存储二叉树"><a href="#顺序存储二叉树" class="headerlink" title="顺序存储二叉树"></a>顺序存储二叉树</h3><p>将二叉树存储在一个数组中，通过存储元素的下标反映元素之间的父子节点关系。即数组存储方式和二叉树的存储方式可以互相转换。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>功能实现：</p><ol><li>二叉树的节点以数组的方式存放；</li><li>遍历数组时以前序遍历，中序遍历，后序遍历的方式完成节点的遍历；<br>注意：该二叉树只考虑完全二叉树</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>顺序二叉树前中后序遍历代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/8</span></span><br><span class="line"><span class="comment">* 功能：以前序中序后序的方式遍历数组</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> tree;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialStorageBinaryTree</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line">           ArrayBinaryTree binaryTree = <span class="keyword">new</span>  ArrayBinaryTree(array);</span><br><span class="line">           <span class="comment">// 前序遍历数组</span></span><br><span class="line">           System.out.print(<span class="string">"前序遍历数组："</span>);</span><br><span class="line">           binaryTree.preOrder();</span><br><span class="line">           System.out.println();</span><br><span class="line">           <span class="comment">// 中序遍历数组</span></span><br><span class="line">           System.out.print(<span class="string">"中序遍历数组："</span>);</span><br><span class="line">           binaryTree.infixOrder();</span><br><span class="line">           System.out.println();</span><br><span class="line">           <span class="comment">// 后序遍历数组</span></span><br><span class="line">           System.out.print(<span class="string">"后序遍历数组："</span>);</span><br><span class="line">           binaryTree.postOrder();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayBinaryTree</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span>[] arr;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ArrayBinaryTree</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.arr = array;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// preOrder方法的重载</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.preOrder(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// infixOrder方法的重载</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.infixOrder(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// postOrder方法的重载</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.postOrder(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 前序遍历数组</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 判断数组是否为空</span></span><br><span class="line">           <span class="keyword">if</span> (arr.length == <span class="number">0</span> || arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"数组为空"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 打印根节点</span></span><br><span class="line">           System.out.print(<span class="string">" =&gt; "</span> + arr[index]);</span><br><span class="line">           <span class="comment">// 递归左子树</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; arr.length) &#123;</span><br><span class="line">                preOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 递归右子树</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">2</span> &lt; arr.length) &#123;</span><br><span class="line">                preOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 中序遍历数组</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (arr.length == <span class="number">0</span> || arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"数组为空"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 先递归左子树</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; arr.length) &#123;</span><br><span class="line">                infixOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 打印根节点</span></span><br><span class="line">           System.out.print(<span class="string">" =&gt; "</span> + arr[index]);</span><br><span class="line">           <span class="comment">// 递归右子树</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">2</span> &lt; arr.length) &#123;</span><br><span class="line">                infixOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 后序遍历数组</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (arr.length == <span class="number">0</span> || arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"数组为空"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 先遍历左子树</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; arr.length) &#123;</span><br><span class="line">                postOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 接着遍历右子树</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">2</span> &lt; arr.length) &#123;</span><br><span class="line">                postOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 最后打印根节点</span></span><br><span class="line">           System.out.print(<span class="string">" =&gt; "</span> + arr[index]);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 顺序存储二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-二叉树</title>
      <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="二叉树介绍"><a href="#二叉树介绍" class="headerlink" title="二叉树介绍"></a>二叉树介绍</h3><p>二叉树是n个有限元素的集合，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成，是有序树。当集合为空时，称该二叉树为空二叉树。在二叉树中，一个元素也称作一个结点，二叉树特点是每个结点最多只能有两棵子树，且有左右之分。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>二叉树的遍历：<br>前序遍历：首先访问根节点，接着遍历左子树，最后遍历右子树；<br>中序遍历：首先遍历左子树，接着访问根节点，最后遍历右子树；<br>后序遍历：首先遍历左子树，接着遍历右子树，最后访问根节点；<br>注意：<br>区分是哪种遍历，可以看根节点是什么时候被访问，是先访问就是前序遍历；中间访问就是中序遍历；最后访问就是后序遍历；</p><p>二叉树节点的查找：<br>功能：前序查找；中序查找；后序查找</p><p>二叉树节点的删除：<br>思路分析：</p><ol><li>先判定根节点是否为空，再判断根节点是否为删除的节点</li><li>若根节点不是要删除的节点，则判断左右节点是否存在且是否为要删除的节点</li><li>若是要删除的节点，继续判断其有无子节点，是一个子节点还是俩个子节点<ul><li>若要删除的节点只有一个子节点，则将当前节点指向要删除节点的下一个节点；</li><li>若要删除的节点为俩个节点，则将数值大的节点指向数值小的节点，再将当前节点指向删除节点子节点中小的节点；</li><li>若无子节点，则直接将当前节点置为null；</li></ul></li></ol><p>二叉树中序遍历动态图演示：<br><img src="/images/dataStructure_img/binaryTree/binaryTree.gif" alt="二叉树中序遍历"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/7</span></span><br><span class="line"><span class="comment">* 功能：1.实现二叉树的前序中序后序遍历</span></span><br><span class="line"><span class="comment">*      2.实现二叉树的前序中序后序查找</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> tree;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemo</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义节点</span></span><br><span class="line">           TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>, <span class="string">"ajiany"</span>);</span><br><span class="line">           TreeNode node2 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>, <span class="string">"lufei"</span>);</span><br><span class="line">           TreeNode node3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>, <span class="string">"suolong"</span>);</span><br><span class="line">           TreeNode node4 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>, <span class="string">"sanji"</span>);</span><br><span class="line">           TreeNode node5 = <span class="keyword">new</span> TreeNode(<span class="number">5</span>, <span class="string">"shengping"</span>);</span><br><span class="line">           root.setLeftNode(node2);</span><br><span class="line">           root.setRightNode(node3);</span><br><span class="line">           node3.setLeftNode(node5);</span><br><span class="line">           node3.setRightNode(node4);</span><br><span class="line">           <span class="comment">// 放入根节点</span></span><br><span class="line">           BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree(root);</span><br><span class="line"><span class="comment">//         // 前序遍历测试</span></span><br><span class="line"><span class="comment">//         System.out.println("PreOrder------------------------------");</span></span><br><span class="line"><span class="comment">//         binaryTree.binaryTreePreOrder();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//         // 中序遍历测试</span></span><br><span class="line"><span class="comment">//         System.out.println("InfixOrder------------------------------");</span></span><br><span class="line"><span class="comment">//         binaryTree.binaryTreeInfixOrder();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//         // 后序遍历测试</span></span><br><span class="line"><span class="comment">//         System.out.println("PostOrder------------------------------");</span></span><br><span class="line"><span class="comment">//         binaryTree.binaryTreePostOrder();</span></span><br><span class="line">           <span class="comment">// 前序遍历查找测试</span></span><br><span class="line"><span class="comment">//         System.out.println("PreOrderSearch------------------------------");</span></span><br><span class="line"><span class="comment">//         TreeNode tnode =  binaryTree.binaryTreePreOrderSearch(5);</span></span><br><span class="line"><span class="comment">//         if (tnode != null) &#123;</span></span><br><span class="line"><span class="comment">//              System.out.println("你查询的节点的信息编号为：" +  tnode.getNo() + " ,名字为： " + tnode.getName());</span></span><br><span class="line"><span class="comment">//         &#125; else &#123;</span></span><br><span class="line"><span class="comment">//              System.out.println("无该节点");</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line">           <span class="comment">// 中序遍历查找测试</span></span><br><span class="line"><span class="comment">//         System.out.println("InfixOrderSearch------------------------------");</span></span><br><span class="line"><span class="comment">//         TreeNode tnode1 =  binaryTree.binaryTreeInfixOrderSearch(5);</span></span><br><span class="line"><span class="comment">//         if (tnode1 != null) &#123;</span></span><br><span class="line"><span class="comment">//              System.out.println("你查询的节点的信息编号为：" +  tnode1.getNo() + " ,名字为： " + tnode1.getName());</span></span><br><span class="line"><span class="comment">//         &#125; else &#123;</span></span><br><span class="line"><span class="comment">//              System.out.println("无该节点");</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line">           <span class="comment">// 后序遍历查找测试</span></span><br><span class="line"><span class="comment">//         System.out.println("PostOrderSearch------------------------------");</span></span><br><span class="line"><span class="comment">//         TreeNode tnode2 =  binaryTree.binaryTreePostOrderSearch(5);</span></span><br><span class="line"><span class="comment">//         if (tnode2 != null) &#123;</span></span><br><span class="line"><span class="comment">//              System.out.println("你查询的节点的信息编号为：" +  tnode2.getNo() + " ,名字为： " + tnode2.getName());</span></span><br><span class="line"><span class="comment">//         &#125; else &#123;</span></span><br><span class="line"><span class="comment">//              System.out.println("无该节点");</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line">           <span class="comment">//删除节点测试</span></span><br><span class="line">           System.out.println(<span class="string">"删除节点前："</span>);</span><br><span class="line">           binaryTree.binaryTreePreOrder();</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//删除操作</span></span><br><span class="line">           binaryTree.binaryTreeDeleteTreeNode(<span class="number">5</span>);</span><br><span class="line">           </span><br><span class="line">           System.out.println(<span class="string">"删除节点后："</span>);</span><br><span class="line">           binaryTree.binaryTreePreOrder();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义根节点</span></span><br><span class="line">     TreeNode root;</span><br><span class="line">     <span class="comment">// 构造方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.root = node;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 前序遍历</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binaryTreePreOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.root.preOrder();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 中序遍历</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binaryTreeInfixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.root.infixOrder();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 后序遍历</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binaryTreePostOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.root.postOrder();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 前序遍历查找</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">binaryTreePreOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           TreeNode curNode = <span class="keyword">this</span>.root.preOrderSearch(no);</span><br><span class="line">           <span class="keyword">if</span> (curNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> curNode;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 中序遍历查找</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">binaryTreeInfixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           TreeNode curNode = <span class="keyword">this</span>.root.infixOrderSearch(no);</span><br><span class="line">           <span class="keyword">if</span> (curNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> curNode;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 后序遍历查找</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">binaryTreePostOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           TreeNode curNode = <span class="keyword">this</span>.root.postOrderSearch(no);</span><br><span class="line">           <span class="keyword">if</span> (curNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> curNode;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//简易版删除节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binaryTreeDeleteTreeNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//先判断根节点是否为空</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.root!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果根节点是要删除的节点则删除</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.root.getNo()==no) &#123;</span><br><span class="line">                     <span class="keyword">this</span>.root=<span class="keyword">null</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">//不是则进入其他判断操作</span></span><br><span class="line">                     <span class="keyword">this</span>.root.deleteTreeNode(no);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"无该节点"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二叉树结点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line">     <span class="keyword">private</span> TreeNode leftNode;</span><br><span class="line">     <span class="keyword">private</span> TreeNode rightNode;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.no = no;</span><br><span class="line">           <span class="keyword">this</span>.name = name;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> no;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.no = no;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> name;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.name = name;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getLeftNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> leftNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftNode</span><span class="params">(TreeNode leftNode)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.leftNode = leftNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getRightNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> rightNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightNode</span><span class="params">(TreeNode rightNode)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.rightNode = rightNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 重写toString方法</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"TreeNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 前序遍历-递归</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 打印当前父节点</span></span><br><span class="line">           System.out.println(<span class="keyword">this</span>);</span><br><span class="line">           <span class="comment">// 前序遍历递归左子树</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.leftNode.preOrder();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 前序遍历递归右子树</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.rightNode.preOrder();</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 中序遍历-递归</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 中序遍历递归左子树</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.leftNode.infixOrder();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 打印父节点</span></span><br><span class="line">           System.out.println(<span class="keyword">this</span>);</span><br><span class="line">           <span class="comment">// 中序遍历递归右子树</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.rightNode.infixOrder();</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 后序遍历-递归</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 后序遍历递归左子树</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.leftNode.postOrder();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 后序遍历递归右子树</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.rightNode.postOrder();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 打印父节点</span></span><br><span class="line">           System.out.println(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 前序遍历-查找节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义临时节点</span></span><br><span class="line">           TreeNode curNode = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;<span class="comment">// 如果在根节点找到则直接返回当前节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 左子树递归遍历查找节点</span></span><br><span class="line">                curNode = <span class="keyword">this</span>.leftNode.preOrderSearch(no);</span><br><span class="line">                <span class="keyword">if</span> (curNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">return</span> curNode;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 右子树递归遍历查找结点</span></span><br><span class="line">                curNode = <span class="keyword">this</span>.rightNode.preOrderSearch(no);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> curNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 中序遍历-查找节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           TreeNode curNode = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 先左子树递归遍历查找</span></span><br><span class="line">                curNode = <span class="keyword">this</span>.leftNode.infixOrderSearch(no);</span><br><span class="line">                <span class="keyword">if</span> (curNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">return</span> curNode;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;<span class="comment">// 如果当前位置找到则返回当前节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果右子树不为null则遍历递归查找</span></span><br><span class="line">                curNode = <span class="keyword">this</span>.rightNode.infixOrderSearch(no);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> curNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 后序遍历-查找节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           TreeNode curNode = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 先在左子树进行递归遍历查找</span></span><br><span class="line">                curNode = <span class="keyword">this</span>.leftNode.postOrderSearch(no);</span><br><span class="line">                <span class="keyword">if</span> (curNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">return</span> curNode;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 接着在右子树进行递归遍历查找</span></span><br><span class="line">                curNode = <span class="keyword">this</span>.rightNode.postOrderSearch(no);</span><br><span class="line">                <span class="keyword">if</span> (curNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">return</span> curNode;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">                <span class="comment">// 最后再在根节点查找</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> curNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 简易版删除节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteTreeNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 如果根节点的左节点为要删除的节点</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.leftNode != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.leftNode.no == no)  &#123;</span><br><span class="line">                <span class="keyword">this</span>.leftNode=<span class="keyword">null</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.rightNode != <span class="keyword">null</span> &amp;&amp;  <span class="keyword">this</span>.rightNode.no == no) &#123;</span><br><span class="line">                <span class="comment">// 如果根节点的右节点为要删除的节点</span></span><br><span class="line">                <span class="keyword">this</span>.rightNode=<span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span>(<span class="keyword">this</span>.leftNode!=<span class="keyword">null</span>) &#123;<span class="comment">//递归删除左子树</span></span><br><span class="line">                <span class="keyword">this</span>.leftNode.deleteTreeNode(no);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(<span class="keyword">this</span>.rightNode!=<span class="keyword">null</span>) &#123;<span class="comment">//递归删除右子树</span></span><br><span class="line">                <span class="keyword">this</span>.rightNode.deleteTreeNode(no);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-哈希表</title>
      <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="哈希表介绍"><a href="#哈希表介绍" class="headerlink" title="哈希表介绍"></a>哈希表介绍</h3><p>哈希表(散列表)是根据关键码值直接进行访问的数据结构，即通过把关键码值映射到表中一个位置来访问记录，以加快查找速度。该映射函数称为散列函数，存放记录的数组叫哈希表。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>功能：利用一个google上机题来讲述哈希表<br>题目：哈希表实现google面试上机题,有一个公司，当有新的员工来报道时,要求将员工的信息加入(id,性别,年龄,住址,…),当输入该员工的id时,要求查到该员工的所有信息，不使用数据库,尽量节省内存,速度越快越好。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/6</span></span><br><span class="line"><span class="comment">* 功能：哈希表实现google面试上机题,有一个公司，当有新的员工来报道时,要求将员工的信息</span></span><br><span class="line"><span class="comment">*            加入(id,性别,年龄,住址,...),当输入该员工的id时,要求查到该员工的所有信息</span></span><br><span class="line"><span class="comment">* 功能性能要求：不使用数据库,尽量节省内存,速度越快越好</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 创建哈希表</span></span><br><span class="line">           EmployeeHashTable hashTable = <span class="keyword">new</span>  EmployeeHashTable(<span class="number">7</span>);</span><br><span class="line">           <span class="comment">// 写一个简单的菜单</span></span><br><span class="line">           String key = <span class="string">""</span>;</span><br><span class="line">           Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"add:  添加雇员"</span>);</span><br><span class="line">                System.out.println(<span class="string">"delete:  删除员工信息"</span>);</span><br><span class="line">                System.out.println(<span class="string">"update:  修改雇员信息"</span>);</span><br><span class="line">                System.out.println(<span class="string">"search: 查找雇员"</span>);</span><br><span class="line">                System.out.println(<span class="string">"exit: 退出系统"</span>);</span><br><span class="line">                System.out.println(<span class="string">"show: 显示雇员"</span>);</span><br><span class="line">                key = scanner.next();</span><br><span class="line">                <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"add"</span>:</span><br><span class="line">                     System.out.println(<span class="string">"输入id"</span>);</span><br><span class="line">                     <span class="keyword">int</span> id = scanner.nextInt();</span><br><span class="line">                     System.out.println(<span class="string">"输入名字"</span>);</span><br><span class="line">                     String name = scanner.next();</span><br><span class="line">                     <span class="comment">// 创建 雇员</span></span><br><span class="line">                     Employee emp = <span class="keyword">new</span> Employee(id, name);</span><br><span class="line">                     hashTable.hashTableAdd(emp);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"delete"</span>:</span><br><span class="line">                     System.out.println(<span class="string">"请输入你要删除的员工id"</span>);</span><br><span class="line">                     id = scanner.nextInt();</span><br><span class="line">                     hashTable.hashTableDelete(id);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"update"</span>:</span><br><span class="line">                     System.out.println(<span class="string">"请输入要修改的id"</span>);</span><br><span class="line">                     id = scanner.nextInt();</span><br><span class="line">                     System.out.println(<span class="string">"请输入要修改的名字"</span>);</span><br><span class="line">                     String newName = scanner.next();</span><br><span class="line">                     hashTable.hashTableUpdate(id, newName);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"search"</span>:</span><br><span class="line">                     <span class="comment">// 查找员工的信息</span></span><br><span class="line">                     System.out.println(<span class="string">"请输入要查找的id"</span>);</span><br><span class="line">                     id = scanner.nextInt();</span><br><span class="line">                     hashTable.hashTableSearch(id);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"show"</span>:</span><br><span class="line">                     <span class="comment">// 显示员工数组所有信息</span></span><br><span class="line">                     hashTable.hashTableShowEmployeeList();</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">                     scanner.close();</span><br><span class="line">                     System.exit(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存放员工链表的数组(数组-链表)哈希表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeHashTable</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义链表数组</span></span><br><span class="line">     EmployeeList[] emplistTable;</span><br><span class="line">     <span class="comment">// 定义一个链表数量的变量</span></span><br><span class="line">     <span class="keyword">int</span> size;</span><br><span class="line">     <span class="comment">// 定义员工链表的数量</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">EmployeeHashTable</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 根据形参给当前类的size赋值</span></span><br><span class="line">           <span class="keyword">this</span>.size = size;</span><br><span class="line">           <span class="comment">// 给定数组的长度</span></span><br><span class="line">           emplistTable = <span class="keyword">new</span> EmployeeList[size];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; emplistTable.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 给表中每一个数组元素分配链表存储空间</span></span><br><span class="line">                emplistTable[i] = <span class="keyword">new</span> EmployeeList();</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 定义散列表函数-&gt;根据员工id分配到到特定的链表号</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distributionListNo</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> id % size;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 1.添加员工信息</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hashTableAdd</span><span class="params">(Employee emp)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 添加员工信息到指定的链表</span></span><br><span class="line">           emplistTable[distributionListNo(emp.id)].addEmployee(emp);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 2.删除员工信息</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hashTableDelete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 删除指定链表的指定员工的信息</span></span><br><span class="line">           emplistTable[distributionListNo(id)].deleteEmployee(id);</span><br><span class="line">           </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 3.修改员工信息</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hashTableUpdate</span><span class="params">(<span class="keyword">int</span> id, String newName)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 修改指定链表的指定员工信息</span></span><br><span class="line">           emplistTable[distributionListNo(id)].updateEmployee(id,  newName);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 4.查询员工信息</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hashTableSearch</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">           emplistTable[distributionListNo(id)].searchEmployee(id);;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 5.显示员工链表所有信息</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hashTableShowEmployeeList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; emplistTable.length; i++) &#123;</span><br><span class="line">                emplistTable[i].showEmployee(i);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存放员工的链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeList</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义员工信息类的头指针</span></span><br><span class="line">     Employee head = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">// 对员工信息的增删改查</span></span><br><span class="line">     <span class="comment">// 1.增加操作</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEmployee</span><span class="params">(Employee emp)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 如下一节点不为null则先让头节点指向下一节点,若为null则head也为null</span></span><br><span class="line">           <span class="comment">// 如果头节点为null,则直接添加到头节点后</span></span><br><span class="line">           <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                head = emp;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 定义移动指针</span></span><br><span class="line">           Employee curEmp = head;</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果找到尾节点则将员工节点添加上去</span></span><br><span class="line">                <span class="keyword">if</span> (curEmp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     curEmp.next = emp;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                curEmp = curEmp.next;</span><br><span class="line">           &#125;</span><br><span class="line">           curEmp.next = emp;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 2.删除操作</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteEmployee</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">           Employee curEmp = <span class="keyword">new</span> Employee(<span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line">           curEmp.next=head;</span><br><span class="line">           <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"删除指定id的员工链表无此员工信息"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果curEmp.next==null,则&amp;&amp;后面的一句代码判断不执行，故不会导致空指针异常</span></span><br><span class="line">                <span class="keyword">if</span> (curEmp.next== <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(curEmp.next.id==id)&#123;</span><br><span class="line">                     curEmp.next = curEmp.next.next;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 移动到下一节点</span></span><br><span class="line">                curEmp = curEmp.next;</span><br><span class="line">           &#125;</span><br><span class="line">           head=curEmp;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 3.修改操作</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateEmployee</span><span class="params">(<span class="keyword">int</span> id, String newName)</span> </span>&#123;</span><br><span class="line">           Employee curEmp = head;</span><br><span class="line">           <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curEmp == <span class="keyword">null</span>) &#123;<span class="comment">// 如果当前节点为null则跳出循环</span></span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curEmp.id == id) &#123;<span class="comment">// 找到id则修改相应的信息</span></span><br><span class="line">                     curEmp.name = newName;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                curEmp = curEmp.next;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 4.查询操作-返回值为员工id对应的所有信息</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchEmployee</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">           Employee curEmp=head;</span><br><span class="line">           <span class="keyword">if</span>(head==<span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(curEmp==<span class="keyword">null</span>) &#123;<span class="comment">//到达结尾退出</span></span><br><span class="line">                     System.out.println(<span class="string">"无该员工信息"</span>);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(curEmp.id==id) &#123;</span><br><span class="line">                     System.out.println(<span class="string">"查找id为"</span>+id+<span class="string">"的员工信息为："</span>+curEmp);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                curEmp=curEmp.next;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 5.显示链表的所有员工信息</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showEmployee</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           Employee curEmp = head;</span><br><span class="line">           <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"第"</span> + (no + <span class="number">1</span>) + <span class="string">"条链表为空"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.print(<span class="string">"第"</span> + (no + <span class="number">1</span>) + <span class="string">"条链表的信息为："</span>);</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">" =&gt; "</span> + curEmp);</span><br><span class="line">                <span class="keyword">if</span> (curEmp.next == <span class="keyword">null</span>) &#123;<span class="comment">// 最后一个节点退出</span></span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                curEmp = curEmp.next;<span class="comment">// 后移</span></span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//员工信息类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 定义员工id</span></span><br><span class="line">     <span class="keyword">int</span> id;</span><br><span class="line">     <span class="comment">// 定义员工name</span></span><br><span class="line">     String name;</span><br><span class="line">     <span class="comment">// 指向下一个员工的指针</span></span><br><span class="line">     Employee next;</span><br><span class="line">     <span class="comment">// Employee类的构造方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.id = id;</span><br><span class="line">           <span class="keyword">this</span>.name = name;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 重写toString方法</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"id="</span> + id + <span class="string">", name="</span> + name;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法-堆排序</title>
      <link href="/2020/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="堆排序介绍"><a href="#堆排序介绍" class="headerlink" title="堆排序介绍"></a>堆排序介绍</h3><p>堆排序是一种选择排序，堆具有以下性质的完全二叉树：1.若每个节点的值大于或等于其左右节点的值，则称为大顶堆；2.若每个节点的值小于或等于其左右节点的值，则成为小顶堆。注：堆不要求左右节点值之间的大小关系，且堆排序为不稳定排序。</p><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>堆排序算法步骤分析：<br>假设有一组待排序的数组如下：<br>{ 4，6，8，5，9 }<br>算法步骤：</p><ol><li>构造大顶堆；</li><li>将根节点最大值与数组最后一个值交换，下次交换最大值交换倒数第n个；</li><li>重复步骤一和步骤二；</li></ol><p>大顶堆的构建动态演示图：<br><img src="/images/dataStructure_img/searchAlgorithm/bigTopHeap.gif" alt="大顶堆构造图"></p><p>堆排序动态图演示：<br><img src="/images/dataStructure_img/searchAlgorithm/heapSort.gif" alt="堆排序"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/10</span></span><br><span class="line"><span class="comment">* 功能：堆排序</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span>[] array = &#123; <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span> &#125;;</span><br><span class="line">           heapSort(array);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 堆排序</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 临时变量</span></span><br><span class="line">           <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">           <span class="comment">// 步骤一：构造大顶堆</span></span><br><span class="line">           <span class="comment">// array.length/2-1即获得非叶子节点的下标</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                createMaxHeap(array, i, array.length);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 步骤二迭代将最大值放到数组末尾</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">// 将根节点即最大值与数组最末尾交换</span></span><br><span class="line">                temp = array[i];</span><br><span class="line">                array[i] = array[<span class="number">0</span>];</span><br><span class="line">                array[<span class="number">0</span>] = temp;</span><br><span class="line">                <span class="comment">// 重新调整为大顶堆</span></span><br><span class="line">                createMaxHeap(array, <span class="number">0</span>, i);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(Arrays.toString(array));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 构造最大堆</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createMaxHeap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> nlIndex,  <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 将要交换的非叶子节点暂存的临时变量</span></span><br><span class="line">           <span class="keyword">int</span> temp = array[nlIndex];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span> * nlIndex + <span class="number">1</span>; k &lt; length; k = <span class="number">2</span> * k +  <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断非叶子节点的左右子节点的数值大小关系</span></span><br><span class="line">                <span class="comment">//k+1&lt;length 这个判断十分重要,当只剩下俩个元素判断时,即数组长度为2,第一个k=1,如果不k+1&lt;length判断,则其会交换后面已经存在的最大值</span></span><br><span class="line">                <span class="keyword">if</span> (k + <span class="number">1</span> &lt; length &amp;&amp; array[k] &lt; array[k + <span class="number">1</span>]) &#123;</span><br><span class="line">                     k++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前非叶子节点和子节点最大值比较</span></span><br><span class="line">                <span class="keyword">if</span> (temp &lt; array[k]) &#123;</span><br><span class="line">                     <span class="comment">// 交换</span></span><br><span class="line">                     array[nlIndex] = array[k];</span><br><span class="line">                     array[k] = temp;</span><br><span class="line">                     <span class="comment">// 索引也要复制给nlIndex,否则无法把原先的值给当前的非叶子节点</span></span><br><span class="line">                     nlIndex = k;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斐波那契查找算法</title>
      <link href="/2020/07/28/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
      <url>/2020/07/28/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="斐波那契查找算法介绍"><a href="#斐波那契查找算法介绍" class="headerlink" title="斐波那契查找算法介绍"></a>斐波那契查找算法介绍</h3><p>斐波那契查找算法是基于二分查找算法依据斐波那契数列进行分割的算法。在斐波那契数列找一个等于或者略鱼鱼带查找数组中元素个数的数f[n],接着扩展原数组的长度为发f[n],扩展的元素为原数组的最后一个元素；完成后进行斐波那契分割，将f[n]个元素分割为左部分f[n-1]个元素和右部分f[n-2]个元素，找出要查找的元素并在那一部分执行同样的操作，直到找到为止；</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>假设待查询的数组为：<br>{ 1，8，10，89，1000，1234 }</p><p>算法步骤：</p><ol><li>在斐波那契数列中找到一个等于或略大于待查询数组长度的值f[n];</li><li>若找到的f[n]略大于array.length,则进行以array[array.length-1]这个末尾的值进行扩充，直到array的长度等于f[n],一般用一个temp数组拷贝扩充后的数组，原数组实际上是没有变化的；</li><li>令mid=left+f[k]-1,k为当前f[n]对应的下标，若findEleValue&gt;temp[mid]，则进行left=mid+1;k-=2; 执行右部分的查询，left=mid+1表示查询得值在[mid+1,right]这个范围内，k-=2 -&gt; 5-2=3,即说明范围[mid+1,right]内的元素个数为n-(f[k-1])=f[k]-1-f[k-1]=fk-f[k-1]-1=f[k-2]-1个; n=f[k]-1;</li><li>若findEleValue&lt;temp[mid],则进行right=mid-1;k-=1; right=mid-1表示查询的值在[left,mid-1]这个范围内，k-=1表示[left,mid-1]范围内元素个数为f[k-1]-1个。</li></ol><p>待查询数组即斐波那契数列如下：<br><img src="/images/dataStructure_img/searchAlgorithm/fibonacci.png" alt="斐波那契查找"></p><p>查询的关键变量变化：</p><ol><li>k=5；left=0；right=7；f[5]=8；mid=7;</li><li>k=4；left=0；right=6；f[4]=5；mid=4；</li><li>k=3；left=0；right=3；f[3]=2；mid=1；</li><li>k=1；left=3；right=3；f[1]=1；mid=3；查询结束</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/5</span></span><br><span class="line"><span class="comment">* FibonacciSearch</span></span><br><span class="line"><span class="comment">* 功能：斐波那契查找算法的实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> search;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciSearch2</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSize = <span class="number">20</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1234</span> &#125;;</span><br><span class="line">           <span class="comment">//输出查询结果</span></span><br><span class="line">           System.out.println(<span class="string">"index = "</span>+fibonacciSearch(array,  <span class="number">8</span>));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 生成Fibonacci数列</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fibonacci() &#123;</span><br><span class="line">           <span class="comment">// 定义斐波那契数组</span></span><br><span class="line">           <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">           <span class="comment">// 先初始化斐波那契数组前俩个元素</span></span><br><span class="line">           f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">           f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; f.length; i++) &#123;</span><br><span class="line">                f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> f;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//斐波那契查找算法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibonacciSearch</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span>  findEleValue)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//定义左边界的值</span></span><br><span class="line">           <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">           <span class="comment">//定义右边界的值</span></span><br><span class="line">           <span class="keyword">int</span> right=array.length-<span class="number">1</span>;</span><br><span class="line">           <span class="comment">//先初始化查询点</span></span><br><span class="line">           <span class="keyword">int</span> mid=<span class="number">0</span>;</span><br><span class="line">           <span class="comment">//获得斐波那契数组</span></span><br><span class="line">           <span class="keyword">int</span>[] f=fibonacci();</span><br><span class="line">           <span class="comment">//初始化带查询数组对应的斐波那契数组的索引下标</span></span><br><span class="line">           <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">           <span class="comment">//获得待查询数组对应的斐波那契数组的索引下标</span></span><br><span class="line">           <span class="keyword">while</span>(right&gt;f[k]) &#123;</span><br><span class="line">                k++;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//待查询数组的长度和f[k]对应的数值不相等,即无法构成斐波那契查询长度,故需自行填补</span></span><br><span class="line">           <span class="comment">//扩充array待查询数组为符合斐波那契查询长度的数组,并定义一个新的数组temp指向array</span></span><br><span class="line">           <span class="keyword">int</span>[] temp=Arrays.copyOf(array, f[k]);</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//由于扩充后的位置的元素默认为0,故做自行替换</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = right+<span class="number">1</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">                <span class="comment">//默认的0值全部替换为待查询数组的最后一个元素</span></span><br><span class="line">                temp[i]=array[right];</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//开始查询</span></span><br><span class="line">           <span class="keyword">while</span>(left&lt;right) &#123;</span><br><span class="line">                mid=left+f[k]-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(findEleValue&gt;temp[mid]) &#123;<span class="comment">//在右边查询</span></span><br><span class="line">                     left=mid+<span class="number">1</span>;</span><br><span class="line">                     k-=<span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(findEleValue&lt;temp[mid]) &#123;<span class="comment">//在左边查询</span></span><br><span class="line">                     right=mid-<span class="number">1</span>;</span><br><span class="line">                     k-=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;<span class="comment">//查询成功</span></span><br><span class="line">                     <span class="comment">//返回较小值即索引</span></span><br><span class="line">                     <span class="keyword">if</span>(mid&lt;=right) &#123;</span><br><span class="line">                           <span class="keyword">return</span> mid;</span><br><span class="line">                     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="keyword">return</span> right;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 斐波那契查找算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法-插值查找</title>
      <link href="/2020/07/28/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE/"/>
      <url>/2020/07/28/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="插值查找算法介绍"><a href="#插值查找算法介绍" class="headerlink" title="插值查找算法介绍"></a>插值查找算法介绍</h3><p>插值查找同二分查找一样，查找序列必须有序；插值查找基于二分查找，将查询点选择更改为自适应选择，提高效率；</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>优点：<br>假设待查询的数组为：待查找的findEleValue值为6<br>    { 1 , 2 , 3 , 4 , 5 , 6 , 7, 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 }<br>若使用二分查找的  mid=（ left+right ）/ 2 公式，查找findEleValue，需要4次，mid的值依次改变为：9，4，6，5，最终第四次才找到索引5；<br>若使用插值查找的  mid=left +（right-left）* ( (findEleValue-array[left]) / (array[right]-array[left]) )公式，查找findEleValue，需要1次，mid的值直接定位到索引5；</p><p>缺点：<br>若是数值分布不均匀，数值之间跳跃太大，则插值查找查找效率不一定比二分查找高；<br>假设待查询的数组为：{ 3，14，53，214，542，748 }；待查找的值为：53<br>若采用二分查找算法：mid=（ left+right ）/ 2 公式1次定位到索引为2的位置，即查找到数值53；<br>若采用插值查找算法：mid=left +（right-left）* ( (findEleValue-array[left]) / (array[right]-array[left]) ) 公式需要定位3次才能找到索引为2的53位置，mid的值依次改变为：0，1，2；</p><p>算法总结：若查找的数值分布较为均匀，建议采用插值查找算法；若查找的数值分布不均匀，则建议采用二分查找算法。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/5</span></span><br><span class="line"><span class="comment">* InterpolationSearch</span></span><br><span class="line"><span class="comment">* 功能：插值查找是二分查找算法的优化版，优化了查询点的设置，使其在分布均匀的查找点上查找效率更高</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> search;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterPolationSearch</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//数值分布不均匀的序列</span></span><br><span class="line">           <span class="keyword">int</span>[] array = &#123; <span class="number">3</span>, <span class="number">14</span>, <span class="number">53</span>, <span class="number">214</span>, <span class="number">542</span>, <span class="number">748</span> &#125;;</span><br><span class="line">           <span class="comment">//数值分布均匀的序列</span></span><br><span class="line"><span class="comment">//         int[] array = new int[20];</span></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; array.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//              array[i] = i;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line">           System.out.println(<span class="string">"查询的数值的索引为: "</span> +  interpolationSearch(array, <span class="number">0</span>, array.length - <span class="number">1</span>, <span class="number">53</span>));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">interpolationSearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span>  left, <span class="keyword">int</span> right, <span class="keyword">int</span> findEleValue)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义自适应查询点</span></span><br><span class="line">           <span class="keyword">int</span> mid = left + (right - left) * ((findEleValue -  array[left]) / (array[right] - array[left]));</span><br><span class="line">           <span class="comment">// 终止条件</span></span><br><span class="line">           <span class="keyword">if</span> (left &gt; right || findEleValue &gt; array[right] ||  findEleValue &lt; array[left]) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 递归查找</span></span><br><span class="line">           <span class="keyword">if</span> (findEleValue &gt; array[mid]) &#123;<span class="comment">// 右查找</span></span><br><span class="line">                <span class="keyword">return</span> interpolationSearch(array, mid + <span class="number">1</span>,  right, findEleValue);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findEleValue &lt; array[mid]) &#123;<span class="comment">// 左查找</span></span><br><span class="line">                <span class="keyword">return</span> interpolationSearch(array, mid - <span class="number">1</span>,  right, findEleValue);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;<span class="comment">// 查询结果并返回</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 插值查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法-二分查找</title>
      <link href="/2020/07/28/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2020/07/28/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="二分查找算法介绍"><a href="#二分查找算法介绍" class="headerlink" title="二分查找算法介绍"></a>二分查找算法介绍</h3><p>二分查找也称折半查找，二分查找要求待查找的序列为有序序列；</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>二分查找算法步骤分析：<br>假设有一组待查找的数组为：<br>[  3 ,  14 , 53 , 214 , 542 , 748 ] ; 带查找的数值为214；<br>算法步骤：</p><ol><li>拟定数组的左右边界left和right值，及mid=（left+right）/ 2 值；</li><li>当待查找的元素EleValue &gt; array[mid],则进行右边的查找，此时left=mid+1；</li><li>当待查找的元素EleValue &lt; array[mid],则进行左边的查找，此时right=mid-1;</li><li>不断进行步骤1~3的迭代查找操作，知道left &gt; right则跳出该操作，若有该查找的值，即EleValue==array[mid],返回该值的索引mid</li></ol><p>二分查找动态图演示：<br><img src="/images/dataStructure_img/searchAlgorithm/binarySearch.gif" alt="二分查找动态图"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="二分查找递归法的代码实现及优化"><a href="#二分查找递归法的代码实现及优化" class="headerlink" title="二分查找递归法的代码实现及优化"></a>二分查找递归法的代码实现及优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/5</span></span><br><span class="line"><span class="comment">* BinarySearch</span></span><br><span class="line"><span class="comment">* 功能：实现二分查找递归算法,即对二分查找算法优化，使其可以查询多个相同值得索引</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> search;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//int[] array = &#123; 3, 14, 53, 214, 542, 748 &#125;;</span></span><br><span class="line">           <span class="keyword">int</span>[] array = &#123; <span class="number">3</span>, <span class="number">14</span>, <span class="number">53</span>, <span class="number">214</span>, <span class="number">542</span>, <span class="number">542</span>, <span class="number">542</span>, <span class="number">748</span> &#125;;</span><br><span class="line">           <span class="comment">//System.out.println("带查询得数值的索引为：" +  binarySearch(array, 214, 0, array.length - 1));</span></span><br><span class="line">           System.out.println(<span class="string">"带查询得数值的索引为："</span> +  binarySearch2(array, <span class="number">542</span>, <span class="number">0</span>, array.length - <span class="number">1</span>));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//二分查找算法递归法</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> value,  <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义左右指针及中间指针</span></span><br><span class="line">           <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span> (left &gt; right) &#123;<span class="comment">//若left&gt;right,则说明待查询的序列无该值</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (value &lt; array[mid]) &#123;<span class="comment">//进行左查找</span></span><br><span class="line">                <span class="keyword">return</span> binarySearch(array, value, left, mid -  <span class="number">1</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; array[mid]) &#123;<span class="comment">//进行右查找</span></span><br><span class="line">                <span class="keyword">return</span> binarySearch(array, value, mid + <span class="number">1</span>,  right);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;<span class="comment">//当value==array[mid]返回查找到的值得索引</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//对二分查找方法的升级,可以查找多个相同的值的索引</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span>[]  array, <span class="keyword">int</span> value, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义左右指针及中间指针</span></span><br><span class="line">           <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (value &lt; array[mid]) &#123;</span><br><span class="line">                <span class="keyword">return</span> binarySearch2(array, value, left, mid -  <span class="number">1</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; array[mid]) &#123;</span><br><span class="line">                <span class="keyword">return</span> binarySearch2(array, value, mid + <span class="number">1</span>,  right);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;<span class="comment">// 在返回之前,检查做优是否有相同的值,也返回相同的索引</span></span><br><span class="line">                ArrayList&lt;Integer&gt; resIndexList = <span class="keyword">new</span>  ArrayList&lt;Integer&gt;();</span><br><span class="line">                <span class="comment">// 向左扫描</span></span><br><span class="line">                <span class="keyword">int</span> temp = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (temp &lt; <span class="number">0</span> || array[temp] != array[mid])  &#123;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// 左边有相同的数值则添加进去</span></span><br><span class="line">                     resIndexList.add(temp--);</span><br><span class="line">                &#125;</span><br><span class="line">                resIndexList.add(mid);</span><br><span class="line">                <span class="comment">// 向右扫描</span></span><br><span class="line">                temp = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (temp &gt; right || array[temp] !=  array[mid]) &#123;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// 右边有相同的数值则添加进去</span></span><br><span class="line">                     resIndexList.add(temp++);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> resIndexList;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二分查找算法非递归法"><a href="#二分查找算法非递归法" class="headerlink" title="二分查找算法非递归法"></a>二分查找算法非递归法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/5</span></span><br><span class="line"><span class="comment">* BinarySearch</span></span><br><span class="line"><span class="comment">* 功能：实现二分查找算法非递归法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> search;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchNonRecursion</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span>[] array = &#123; <span class="number">3</span>, <span class="number">14</span>, <span class="number">53</span>, <span class="number">214</span>, <span class="number">542</span>, <span class="number">748</span> &#125;;</span><br><span class="line">           System.out.println(<span class="string">"查找的数值在数组的索引为：  "</span>+binarySearchNonRecursion(array, <span class="number">0</span>, array.length-<span class="number">1</span>, <span class="number">214</span>));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchNonRecursion</span><span class="params">(<span class="keyword">int</span>[] array,  <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findEleValue)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义查找的中间指针</span></span><br><span class="line">           <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                mid=(left + right) / <span class="number">2</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//找到该值则返回该索引</span></span><br><span class="line">                <span class="keyword">if</span>(findEleValue==array[mid]) &#123;</span><br><span class="line">                     <span class="keyword">return</span> mid;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (findEleValue &gt; array[mid]) &#123;<span class="comment">//向右查找</span></span><br><span class="line">                     left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findEleValue &lt; array[mid]) &#123;<span class="comment">//向左查找</span></span><br><span class="line">                     right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法-基数排序</title>
      <link href="/2020/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="基数排序算法介绍"><a href="#基数排序算法介绍" class="headerlink" title="基数排序算法介绍"></a>基数排序算法介绍</h3><p>基数排序是桶排序的扩展，通过键值的各个位的值，将要排序的元素分配至某些序号对应的“桶”中，达到排序的作用；即将所有待比较的数值统一为同样的数位长度，数位较短的数前面补零，然后，从最低位开始，依次进行一次排序，这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>基数排序算法分析：</p><p>假设有一组待排序的数组如下：<br>[ 81 , 29 , 13 , 764 , 21 , 3 , 51 , 4 , 6 , 10 ]<br>算法步骤：</p><ol><li>对待排序的数组每个数字按个位数进行取余，并进行排序得到按个位数排序的序列：[ 10 ， 81 ， 21 ， 51 ， 13 ， 3 ， 764 ， 4 ， 6 ， 29 ];</li><li>继续对十位数进行取余，并按十位数进行排序得到序列：[ 3 , 4 , 6 , 10 , 13 , 21 , 29 , 51 , 764 , 81 ];</li><li>继续对百位数进行取余，并按百位数进行排序得到序列：[ 3，4 ，6 ， 10 ，10 ， 13 ， 21 ， 29 ， 51 ， 81 ， 764  ]</li></ol><p>算法规律总结：外部排序的次数为最大数字的最大位数；</p><p>基数排序动态图演示：<br><img src="/images/dataStructure_img/sortAlgorithm/baseSort.gif" alt="基数排序动态图"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/4</span></span><br><span class="line"><span class="comment">* RadixSort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span>[] array = &#123; <span class="number">81</span> , <span class="number">29</span> , <span class="number">13</span> , <span class="number">764</span> , <span class="number">21</span> , <span class="number">3</span> , <span class="number">51</span> ,  <span class="number">4</span> , <span class="number">6</span> , <span class="number">10</span> &#125;;</span><br><span class="line">           radixSort(array);</span><br><span class="line">           System.out.println(<span class="string">"最终的结果为："</span>+Arrays.toString(array));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定义桶的个数及容量</span></span><br><span class="line">           <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][array.length];</span><br><span class="line">           <span class="comment">// 定义各个桶的桶容量索引</span></span><br><span class="line">           <span class="keyword">int</span>[] bucketNumberIndex = <span class="keyword">new</span> <span class="keyword">int</span>[bucket.length];</span><br><span class="line">           <span class="keyword">int</span> max = array[<span class="number">0</span>];<span class="comment">// 数组最大值</span></span><br><span class="line">           <span class="keyword">int</span> maxLength = <span class="number">0</span>;<span class="comment">// 数组最大值位数</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">                     max = array[i];</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           maxLength = (max + <span class="string">""</span>).length();</span><br><span class="line">           <span class="keyword">int</span> endDigit;<span class="comment">// 待排序对应的末尾数值</span></span><br><span class="line">           <span class="keyword">int</span> index=<span class="number">0</span>;<span class="comment">//定义重新排序后放回原数组的数值索引</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                     endDigit = array[j] / n % <span class="number">10</span>;</span><br><span class="line">                     <span class="comment">//按当前数值的第n位数的数值放入相应的桶</span></span><br><span class="line">                     bucket[endDigit][bucketNumberIndex[endDigit]++] = array[j];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//每次索引要重置</span></span><br><span class="line">                index=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketNumberIndex.length;  j++) &#123;</span><br><span class="line">                     <span class="comment">//桶为空则跳过</span></span><br><span class="line">                     <span class="keyword">if</span>(bucketNumberIndex[j]==<span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="comment">//将桶的数值按顺序取出放回待排序数组</span></span><br><span class="line">                           <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;  bucketNumberIndex[j]; k++) &#123;</span><br><span class="line">                                array[index++]=bucket[j][k];</span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                     bucketNumberIndex[j]=<span class="number">0</span>;<span class="comment">//取完一个桶则将其对应的桶索引指向原点</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                System.out.println(<span class="string">"按数字倒数第"</span>+(i+<span class="number">1</span>)+<span class="string">"位进行桶排序的结果为："</span>+Arrays.toString(array));</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 基数排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法-归并排序</title>
      <link href="/2020/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="归并排序算法介绍"><a href="#归并排序算法介绍" class="headerlink" title="归并排序算法介绍"></a>归并排序算法介绍</h3><p>归并排序是一种利用归并的思想实现排序的方法，该算法采用经典的分治策略；即将大问题分成小的问题进行递归求解。</p><a id="more"></a><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>假设有一组待排序的数据如下：<br>    [ 8 , 4 , 5 ,7 , 1 , 3 , 6 , 2  ]<br>算法步骤：</p><p><img src="/images/dataStructure_img/sortAlgorithm/mergeSortAnalysis.png" alt="归并排序步骤"></p><p>算法规律总结：一共合并array.length-1次。</p><p>归并排序动态图演示：<br><img src="/images/dataStructure_img/sortAlgorithm/mergeSort.gif" alt="归并排序动态图"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/4</span></span><br><span class="line"><span class="comment">* MergeSort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span>[] array = &#123; <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span> &#125;;</span><br><span class="line">           <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">           seperate(array, <span class="number">0</span>, array.length - <span class="number">1</span>, temp);</span><br><span class="line">           System.out.println(<span class="string">"归并排序的结果是：  "</span>+Arrays.toString(array));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 对待排序的数据进行拆分</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">seperate</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span>  right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;<span class="comment">//中间索引</span></span><br><span class="line">           <span class="keyword">if</span> (left &lt; right) &#123;<span class="comment">//左边拆分完毕即合并</span></span><br><span class="line">                </span><br><span class="line">                seperate(array, left, mid, temp);</span><br><span class="line">                seperate(array, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">                <span class="comment">// 合并</span></span><br><span class="line">                merge(array, left, mid, right, temp);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> mid,  <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//int mid = (left + right) / 2;</span></span><br><span class="line">           <span class="keyword">int</span> l = left;<span class="comment">// 左序列的首索引</span></span><br><span class="line">           <span class="keyword">int</span> r = mid + <span class="number">1</span>;<span class="comment">// 右序列的首索引</span></span><br><span class="line">           <span class="keyword">int</span> t = <span class="number">0</span>;<span class="comment">// 临时数组的首索引</span></span><br><span class="line">           <span class="comment">// 1.首先对俩边的数据进行比较,然后将小的移动到临时数组</span></span><br><span class="line">           <span class="keyword">while</span> (l &lt;= mid &amp;&amp; r &lt;= right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[l] &lt; array[r]) &#123;</span><br><span class="line">                     temp[t++] = array[l++];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     temp[t++] = array[r++];</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 2.将剩下的一边的全部移动到临时数组</span></span><br><span class="line">           <span class="comment">// 若左边还剩下数据，则将左边的数据全部移动到临时数组</span></span><br><span class="line">           <span class="keyword">while</span> (l &lt;= mid) &#123;</span><br><span class="line">                temp[t++] = array[l++];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 若右边还剩下数据，则将右边的数据全部移动到临时数组</span></span><br><span class="line">           <span class="keyword">while</span> (r &lt;= right) &#123;</span><br><span class="line">                temp[t++] = array[r++];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 3.将临时数组的拷贝回原来的数组</span></span><br><span class="line">           t = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">int</span> templeft = left;<span class="comment">// 临时左索引</span></span><br><span class="line">           <span class="keyword">while</span> (templeft &lt;= right) &#123;</span><br><span class="line">                array[templeft++] = temp[t++];</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法-快速排序</title>
      <link href="/2020/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="快速排序介绍"><a href="#快速排序介绍" class="headerlink" title="快速排序介绍"></a>快速排序介绍</h3><p>快速排序是基于冒泡排序算法的一种改进。<br>基本思想：通过一个待排序数据的一个中间变量将数据分割成俩部分，其中一部分比另一部分所有数据都要小，重复按照此方法对俩部分数据继续抽取各部分的一个变量作为中间变量进行分割，整个快速排序过程可以递归进行，最后得到一个有序序列</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>快速排序算法分析：<br>假设有一组待排序的数组如下：<br>[ 5，18，7，10，2，16 ]<br>算法步骤：</p><ol><li>将[ 5，18，7，10，2，16 ]按array[(left+right)/2]分成左右俩边的序列[ 5 , 2 , 7 , 10 , 18 , 16 ];</li><li>向左递归得到[ 2 ,  5 ] , 向右递归得到[ 10 , 16 , 18 ];</li><li>最后得到[ 2 , 5 , 7 , 10 , 16 ,18 ];</li></ol><p>快速排序动态图演示：<br><img src="/images/dataStructure_img/sortAlgorithm/quickSort.gif" alt="快速排序动态图"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/3</span></span><br><span class="line"><span class="comment">* QuickSort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span>[] array = &#123; <span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">18</span>,<span class="number">16</span> &#125;;</span><br><span class="line">           quickSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">           System.out.println(<span class="string">"快速排序后的结果为：  "</span>+Arrays.toString(array));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span>  right)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> temp = <span class="number">0</span>;<span class="comment">// 临时变量</span></span><br><span class="line">           <span class="keyword">int</span> lIndex = left, rIndex = right;<span class="comment">// l,r分别为左右俩组索引指针</span></span><br><span class="line">           <span class="keyword">int</span> pivotVal = array[(lIndex + rIndex) / <span class="number">2</span>];<span class="comment">//  pivotIndex为中间索引</span></span><br><span class="line">           <span class="keyword">while</span> (lIndex &lt; rIndex) &#123;</span><br><span class="line">                <span class="comment">// 对左边的分组进行筛选,遇到比array[pivot]大的数则跳出循环</span></span><br><span class="line">                <span class="keyword">while</span> (array[lIndex] &lt; pivotVal) &#123;</span><br><span class="line">                     lIndex+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 对右边的分组进行筛选，遇到比array[pivot]大的数则跳出循环</span></span><br><span class="line">                <span class="keyword">while</span> (array[rIndex] &gt; pivotVal) &#123;</span><br><span class="line">                     rIndex-=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果lIndex&gt;rIndex,说明左边比右边的小</span></span><br><span class="line">                <span class="keyword">if</span> (lIndex &gt;= rIndex) &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 上述俩个循环结束证明左边有比中间索引大的数,右边有比中间索引小的数</span></span><br><span class="line">                temp = array[lIndex];</span><br><span class="line">                array[lIndex] = array[rIndex];</span><br><span class="line">                array[rIndex] = temp;</span><br><span class="line">                <span class="comment">// 如果交换完后,发现这个array[lIndex] ==  array[pivotIndex]值 相等 rIndex--, 前移</span></span><br><span class="line">                <span class="keyword">if</span> (array[lIndex] == pivotVal) &#123;</span><br><span class="line">                     rIndex -= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果交换完后,发现这个array[rIndex] ==  pivotIndex值 相等 lIndex++, 后移</span></span><br><span class="line">                <span class="keyword">if</span> (array[rIndex] == pivotVal) &#123;</span><br><span class="line">                     lIndex += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 防止栈溢出</span></span><br><span class="line">           <span class="keyword">if</span> (lIndex == rIndex) &#123;</span><br><span class="line">                lIndex+=<span class="number">1</span>;</span><br><span class="line">                rIndex-=<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 递归左侧</span></span><br><span class="line">           <span class="keyword">if</span> (left &lt; rIndex) &#123;</span><br><span class="line">                quickSort(array, left, rIndex);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 递归右侧</span></span><br><span class="line">           <span class="keyword">if</span> (right &gt; lIndex) &#123;</span><br><span class="line">                quickSort(array, lIndex, right);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort2</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span>[] array = &#123; <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">           quickSort2(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">           System.out.println(Arrays.toString(array));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span>  </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> ((end - start) &lt;= <span class="number">0</span>) &#123; <span class="comment">// 区间长度小于等于1，则排序结束</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> pivotkey = start; <span class="comment">// 定义枢轴</span></span><br><span class="line">           <span class="keyword">int</span> low = start; <span class="comment">// 定义low，high的位置</span></span><br><span class="line">           <span class="keyword">int</span> high = end;</span><br><span class="line">           <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">                <span class="keyword">while</span> (low &lt; high &amp;&amp; a[high] &gt;= a[pivotkey]) &#123;  <span class="comment">// 从最右侧开始，如果a[high]的值&gt;=枢轴的值，则high--</span></span><br><span class="line">                     high--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//方法一：</span></span><br><span class="line">                <span class="comment">//a[high] = (a[high] + a[pivotkey]) -  (a[pivotkey] = a[high]);// 交换a[high] 与 a[pivotkey]的值</span></span><br><span class="line">                <span class="comment">//方法二：</span></span><br><span class="line">                temp=a[high];</span><br><span class="line">                a[high]=a[pivotkey];</span><br><span class="line">                a[pivotkey]=temp;</span><br><span class="line">                </span><br><span class="line">                pivotkey = high; <span class="comment">// 更改枢轴的位置</span></span><br><span class="line">                <span class="keyword">while</span> (low &lt; high &amp;&amp; a[low] &lt;= a[pivotkey]) &#123; <span class="comment">//  从最左侧开始，如果a[low]的值&lt;=枢轴的值，则low++</span></span><br><span class="line">                     low++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//方法一：</span></span><br><span class="line">                <span class="comment">//a[low] = (a[low] + a[pivotkey]) - (a[pivotkey]  = a[low]); // 交换a[low] 与 a[pivotkey]的值</span></span><br><span class="line">                <span class="comment">//方法二：</span></span><br><span class="line">                temp=a[low];</span><br><span class="line">                a[low]=a[pivotkey];</span><br><span class="line">                a[pivotkey]=temp;</span><br><span class="line">                </span><br><span class="line">                pivotkey = low; <span class="comment">// 更改枢轴的位置</span></span><br><span class="line">           &#125;</span><br><span class="line">           quickSort2(a, start, pivotkey - <span class="number">1</span>); <span class="comment">// 对分割成的两个子表在次快排</span></span><br><span class="line">           quickSort2(a, pivotkey + <span class="number">1</span>, end);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法-希尔排序</title>
      <link href="/2020/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="希尔排序算法介绍"><a href="#希尔排序算法介绍" class="headerlink" title="希尔排序算法介绍"></a>希尔排序算法介绍</h3><p>介绍：希尔排序是简单插入排序经过改进之后的更高效的一种算法，也称缩小增量排序。<br>基本思想：按下标进行增量分组，对每组使用直接插入排序，随着增量的减小，当增量减少至1时，数组恰为一组，算法便终止。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p><strong>希尔排序算法分析：</strong><br>假设有一组待排序的数组如下：<br>[ 8 , 9 , 1 , 7 , 2 , 3 , 5 , 4 , 6 , 0 ]</p><p>算法步骤：</p><ol><li><p>数组初始长度为10，则初始增量gap=10/2=5，即增量步长为5，且整个数组分为5组；[8,3],[9,5],[1,4],[7,6],[2,0];分组的方法为第1个数与第1+5个数为一组，以此类推；对其每一组进行插入排序，得到结果为[ 3 , 5 , 1 , 6 , 0 , 8 , 9 , 4 , 7 , 2 ]；</p></li><li><p>继续对得到的第一次排序完的数组进行分组，gap=5/2=2，即增量步长为2，且整个数组被分成2组；[ 3 , 1 , 0 , 9 ,7 ] , [ 5 , 6 , 8 , 4 , 2 ];对每一组进行插入排序得到的排序后的数组为：[ 0 , 2 , 1 , 4 , 3 , 5 , 7 , 6 , 9 , 8 ];</p></li><li><p>接着对得到的第二次排序完的数组进行分组，gap=2/2=1，即增量步长为1，且整个数组被分成1组，[ 0 , 2 , 1 , 4 , 3 , 5 , 7 , 6 , 9 , 8 ]，该组进行排序后的结果为：[ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]</p></li></ol><p>算法规律总结：外层循环了次，步长为gap/2；</p><p>希尔排序-交换法动态图演示：<br><img src="/images/dataStructure_img/sortAlgorithm/hillSort.gif" alt="希尔排序动态图演示"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/3</span></span><br><span class="line"><span class="comment">* ShellSort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span>[] array = &#123; <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span> &#125;;</span><br><span class="line">           System.out.println(<span class="string">"原始待排序的数组为："</span> +  Arrays.toString(array));</span><br><span class="line">           <span class="comment">// shellSortExchangeMethod(array);//采用希尔排序-交换法排序</span></span><br><span class="line">           shellSortInsertedMethod(array);<span class="comment">//采用希尔排序-移动法排序</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 希尔排序-交换法</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSortExchangeMethod</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">int</span> loopNum = <span class="number">0</span>;<span class="comment">// 循环的次数</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> gap = array.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)  &#123;<span class="comment">// 划分分组</span></span><br><span class="line">                loopNum++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; array.length; i++) &#123;<span class="comment">// 对各分组的元素进行排序</span></span><br><span class="line">                     <span class="keyword">for</span> (<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (array[j] &gt; array[j + gap]) &#123;<span class="comment">// 若同组前一个元素大于后面的元素则交换</span></span><br><span class="line">                                temp = array[j];</span><br><span class="line">                                array[j] = array[j + gap];</span><br><span class="line">                                array[j + gap] = temp;</span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"第"</span> + loopNum + <span class="string">"次希尔排序-交换法的结果："</span> + Arrays.toString(array));</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">"最终希尔排序-交换法的结果："</span> +  Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 分步骤分析 for (int i = 5; i &lt; array.length; i++) &#123;  for (int j = i-5; j &gt;=0; j-=5)</span></span><br><span class="line"><span class="comment">            * &#123; if(array[j]&gt;array[j+5]) &#123; temp=array[j];  array[j]=array[j+5];</span></span><br><span class="line"><span class="comment">            * array[j+5]=temp; &#125; &#125; &#125;  System.out.println(Arrays.toString(array));</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * for (int i = 2; i &lt; array.length; i++) &#123; for (int  j = i-2; j &gt;= 0; j-=2) &#123;</span></span><br><span class="line"><span class="comment">            * if(array[j]&gt;array[j+2]) &#123; temp=array[j];  array[j]=array[j+2];</span></span><br><span class="line"><span class="comment">            * array[j+2]=temp; &#125; &#125; &#125;  System.out.println(Arrays.toString(array));</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * for (int i = 1; i &lt; array.length; i++) &#123; for (int  j = i-1; j &gt;= 0; j-=1) &#123;</span></span><br><span class="line"><span class="comment">            * if(array[j]&gt;array[j+1]) &#123; temp=array[j];  array[j]=array[j+1];</span></span><br><span class="line"><span class="comment">            * array[j+1]=temp; &#125; &#125; &#125;  System.out.println(Arrays.toString(array));</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 希尔排序-移动法</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSortInsertedMethod</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> insertVal, insertIndex;<span class="comment">// 定于待插入元素insertVal,及待比较的元素索引</span></span><br><span class="line">           <span class="keyword">int</span> loopNum = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> gap = array.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)  &#123;<span class="comment">// 划分分组</span></span><br><span class="line">                loopNum++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; array.length; i++) &#123;<span class="comment">// 遍历各分组</span></span><br><span class="line">                     insertVal = array[i];<span class="comment">// 以当前分组的无序列表第一个为初始值</span></span><br><span class="line">                     insertIndex = i - gap;<span class="comment">// 有序列表倒数第一个值得索引为insertIndex的初始值</span></span><br><span class="line">                     <span class="comment">// insertIndex在索引范围内且尚&amp;&amp;未找到位置插入-&gt;继续循环</span></span><br><span class="line">                     <span class="comment">// insertVal &lt; array[insertIndex]升序排序</span></span><br><span class="line">                     <span class="comment">// insertVal &gt; array[insertIndex]降序排序</span></span><br><span class="line">                     <span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt;  array[insertIndex]) &#123;</span><br><span class="line">                           <span class="comment">// 1.若待插入值小于有序列表的倒数第N个值,则把前面的值后移,后面的值已经保存到insertVal</span></span><br><span class="line">                           array[insertIndex + gap] =  array[insertIndex];</span><br><span class="line">                           <span class="comment">// 2.索引以gap的步长向前移动</span></span><br><span class="line">                           insertIndex -= gap;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// 若到达数组最前则退出循环,并且在第一个分组的位置添加元素</span></span><br><span class="line">                     array[insertIndex + gap] = insertVal;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"第"</span> + loopNum + <span class="string">"次希尔排序-移动法的结果："</span> + Arrays.toString(array));</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">"最终希尔排序-移动法的结果："</span> +  Arrays.toString(array));</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序交换法与移动法比较"><a href="#希尔排序交换法与移动法比较" class="headerlink" title="希尔排序交换法与移动法比较"></a>希尔排序交换法与移动法比较</h3><p><strong>此结果具有硬件设施不同也不同，仅提供参考</strong></p><p>希尔排序交换法时间消耗:<br><img src="/images/dataStructure_img/sortAlgorithm/hillSort_exchangeMethod.gif" alt="希尔排序交换法"></p><p>希尔排序移动法时间消耗:<br><img src="/images/dataStructure_img/sortAlgorithm/hillSort_moveMethod.gif" alt="希尔排序移动法"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 希尔排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法-插入排序</title>
      <link href="/2020/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="插入排序算法介绍"><a href="#插入排序算法介绍" class="headerlink" title="插入排序算法介绍"></a>插入排序算法介绍</h3><p>将待排序序列分成一个无序序列和一个有序序列，每一步将一个无序序列中待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素为止。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p><strong>插入排序算法分析：</strong><br>假设有一组待排序的数组如下：<br>[ 8 , 1 , 6 , 3 , 7 ]</p><p>算法步骤：</p><ol><li>将数组分成一个有序序列和一个无序序列，有序序列即为数组第一个元素，无序序列为array[1]~array[array.length-1]的元素；</li><li>将无序序列第一个元素和有序序列倒数第一个元素比较大小，如果大于它则插入无序序列倒数第一个元素后面，反之与前面的元素继续比较，如果前面已经无元素，则插入前面；</li><li>直到将无序序列元素全部插完为止；</li></ol><p>原数组：[ 8 , 1 , 6 , 3 , 7 ]，无序序列 : [ 8 ];    有序序列 : [ 1 , 6 , 3 , 7 ]<br>第一次插入排序后：无序序列 : [ 1 ，8 ];    有序序列 : [ 6 , 3 , 7 ]；<br>第二次插入排序后：无序序列 : [ 1 ，6 ，8 ];    有序序列 : [ 3 , 7 ]；<br>第三次插入排序后：无序序列 : [ 1 ，3 ，6 ，8 ];    有序序列 : [ 7 ]；<br>第四次插入排序后：无序序列 : [ 1 ，3 ，6 ，7 ，8 ];    有序序列 : [ null ]；<br>规律总结：<br>插入排序的次数为array.length-1次，因为只需插入原数组后面n-1位。</p><p>插入排序动态图演示:<br><img src="/images/dataStructure_img/sortAlgorithm/insertSort.gif" alt="插入排序动态图演示"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*@author:ajiany</span></span><br><span class="line"><span class="comment">*@date:2020/7/2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span>[] array = &#123; <span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span> &#125;;</span><br><span class="line">           System.out.println(<span class="string">"原始数组："</span>+Arrays.toString(array));</span><br><span class="line">           insertSort(array);</span><br><span class="line">           System.out.println(<span class="string">"排序后数组："</span>+Arrays.toString(array));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> insertVal = array[i];<span class="comment">// 待插入的元素</span></span><br><span class="line">                <span class="keyword">int</span> insertIndex = i - <span class="number">1</span>;<span class="comment">//待比较元素的下标</span></span><br><span class="line">                <span class="comment">//待插入元素未找到合适位置插入则继续循环，insertIndex--</span></span><br><span class="line">                <span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt;  array[insertIndex]) &#123;</span><br><span class="line">                     array[insertIndex+<span class="number">1</span>] = array[insertIndex];</span><br><span class="line">                     insertIndex--;</span><br><span class="line">                &#125;</span><br><span class="line">                array[insertIndex + <span class="number">1</span>] = insertVal;<span class="comment">//在合适位置插入元素</span></span><br><span class="line">                System.out.println(<span class="string">"第"</span>+i+<span class="string">"轮插入排序:  "</span>+Arrays.toString(array));</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法-选择排序</title>
      <link href="/2020/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="选择排序算法介绍"><a href="#选择排序算法介绍" class="headerlink" title="选择排序算法介绍"></a>选择排序算法介绍</h3><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p><strong>选择排序算法分析：</strong></p><p>假设有一组待排序的数组如下：<br>[ 8 , 1 , 6 , 3 , 7 ]<br>算法步骤：</p><ol><li>从数组[ 8 , 1 , 6 , 3 , 7 ]的array[0]~array[array.length-1]个元素里选择最小的元素与array[0]交换，第一轮排序的结果为：[ 1 , 8 , 6 , 3 , 7 ];</li><li>从数组[ 1 , 8 , 6 , 3 , 7 ]的array[1]~array[array.length-1]个元素里选择最小的元素与array[1]交换，第二轮排序的结果为：[ 1 , 3 , 6 , 8 , 7 ]；</li><li>不断执行上述步骤，直到排序完成；</li></ol><p>原数组：[ 8 , 1 , 6 , 3 , 7 ]<br>第一轮排序：[ 1 , 8 , 6 , 3 , 7 ]<br>第二轮排序：[ 1 , 3 , 6 , 8 , 7 ]<br>第三轮排序：[ 1 , 3 , 6 , 8 , 7 ]<br>第四轮排序：[ 1 , 3 , 6 , 7 , 8 ]<br>规律总结：共经历array.length-1轮排序；第一轮寻找5次，第二轮寻找4次，第三轮寻找3次，第四轮寻找2次；</p><p>选择排序动态图演示：<br><img src="/images/dataStructure_img/sortAlgorithm/selectSort.gif" alt="选择排序动态图演示"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/2</span></span><br><span class="line"><span class="comment">* @SelectSort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span>[] array = &#123; <span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span> &#125;;</span><br><span class="line">           </span><br><span class="line">           System.out.println(<span class="string">"排序前："</span>+Arrays.toString(array));</span><br><span class="line">           selectSort(array);</span><br><span class="line">           System.out.println(<span class="string">"排序后："</span>+Arrays.toString(array));</span><br><span class="line">           </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> currentMin, currentMinIndex;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">                currentMin = array[i];<span class="comment">//将当前值作为最小值</span></span><br><span class="line">                currentMinIndex = i;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                     <span class="comment">// 若当前位置的元素比最小值小,则赋值给currentMin;</span></span><br><span class="line">                     <span class="keyword">if</span> (array[j] &lt; currentMin) &#123;<span class="comment">// 若想实现降序排序，则需改变小于号为大于号</span></span><br><span class="line">                           currentMin = array[j];</span><br><span class="line">                           currentMinIndex = j;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (currentMinIndex != i) &#123;<span class="comment">//如果为交换过,则当前第一位为最小值</span></span><br><span class="line">                     array[currentMinIndex] = array[i];<span class="comment">// 当前索引最小值与索引范围的第一位交换</span></span><br><span class="line">                     array[i] = currentMin;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"轮排序的结果为："</span>+Arrays.toString(array));</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 选择排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法-冒泡排序</title>
      <link href="/2020/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="冒泡排序介绍"><a href="#冒泡排序介绍" class="headerlink" title="冒泡排序介绍"></a>冒泡排序介绍</h3><p>冒泡排序重复地走访过要排序的元素列，依次比较两个相邻的元素，假设是递增方式，如果顺序错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。 </p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>冒泡排序算法分析：<br>假设有一组待排序的数组如下：<br>[ 8 , 1 , 6 , 3 , 7 ]<br>算法步骤：</p><ol><li>定义俩个指针分别指向第一和第二个元素，即8和1，8比1大，交换位置，当前数组[ 1 , 8 , 6 , 3 , 7 ]；</li><li>俩个指针向下移动一位分别指向第二位和第三位元素，即8和6，8比6大，交换位置，当前数组[ 1 , 6 , 8 , 3 , 7 ]；</li><li>不断执行步骤1和步骤2的过程，直到8出现在最后一个位置则第一轮冒泡结束，当前数组[ 1 , 6 , 3 , 7 , 8 ]，执行循环的次数为array.length-1；</li><li>继续第二轮冒泡排序，步骤如步骤1和步骤2；</li></ol><p>原数组：[ 8 , 1 , 6 , 3 , 7 ]<br>第一轮冒泡排序：</p><ol><li>[ 1 , 8 , 6 , 3 , 7 ]</li><li>[ 1 , 6 , 8 , 3 , 7 ]</li><li>[ 1 , 6 , 3 , 8 , 7 ]</li><li>[ 1 , 6 , 3 , 7 , 8 ]</li></ol><p>第二轮冒泡排序：</p><ol><li>[ 1 , 6 , 3 , 7 , 8 ]</li><li>[ 1 , 3 , 6 , 7 , 8 ]</li><li>[ 1 , 3 , 6 , 7 , 8 ]</li></ol><p>第三轮冒泡排序：</p><ol><li>[ 1 , 3 , 6 , 7 , 8 ]</li><li>[ 1 , 3 , 6 , 7 , 8 ]</li></ol><p>第四轮冒泡排序：</p><ol><li>[ 1 , 3 , 6 , 7 , 8 ]</li></ol><p>规律总结：共进行array.length-1轮冒泡排序，第一轮冒泡进行4次位置是否交换的判断，第二轮进行3次，第三轮进行2次，第四轮进行1次；</p><p>冒泡排序动态图解：<br><img src="/images/dataStructure_img/sortAlgorithm/bubbleSort.gif" alt="冒泡排序图解"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/2</span></span><br><span class="line"><span class="comment">* @BubbleSort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span>[] array = &#123; <span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span> &#125;;</span><br><span class="line">           System.out.println(<span class="string">"冒泡排序前：\n"</span> +  Arrays.toString(array));</span><br><span class="line">           <span class="comment">//bubbleSort(array);</span></span><br><span class="line">           OptimizeBubbleSort(array);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 冒泡排序</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i; j++) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                           temp = array[j];</span><br><span class="line">                           array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                           array[j + <span class="number">1</span>] = temp;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">"冒泡排序后：\n"</span> +  Arrays.toString(array));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 优化后的冒泡排序</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OptimizeBubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> temp = <span class="number">0</span>;<span class="comment">//作为交换的中间量</span></span><br><span class="line">           <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//交换位置的标识</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length-i; j++) &#123;</span><br><span class="line">                     <span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                           flag=<span class="keyword">true</span>;</span><br><span class="line">                           temp=array[j];</span><br><span class="line">                           array[j]=array[j+<span class="number">1</span>];</span><br><span class="line">                           array[j+<span class="number">1</span>]=temp;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果一轮冒泡后一次交换位置都没,则跳出冒泡</span></span><br><span class="line">                <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                     flag=<span class="keyword">false</span>;<span class="comment">//交换过位置,复原flag为false</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                     System.out.println(<span class="string">"第"</span>+i+<span class="string">"轮冒泡已经拍好序："</span>+Arrays.toString(array));</span><br><span class="line">                     <span class="keyword">break</span>;<span class="comment">//未交换过位置则跳出冒泡</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                System.out.println(<span class="string">"第"</span>+i+<span class="string">"轮冒泡排序的结果："</span>+Arrays.toString(array));</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 冒泡排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-回溯法-八皇后问题</title>
      <link href="/2020/07/28/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E6%B3%95-%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/28/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E6%B3%95-%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="八皇后问题介绍"><a href="#八皇后问题介绍" class="headerlink" title="八皇后问题介绍"></a>八皇后问题介绍</h3><p>问题表述为：在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。如果经过±90度、±180度旋转，和对角线对称变换的摆法看成一类，共有42类。计算机发明后，有多种计算机语言可以编程解决此问题。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><h4 id="八皇后摆放规则"><a href="#八皇后摆放规则" class="headerlink" title="八皇后摆放规则"></a>八皇后摆放规则</h4><ul><li>皇后不能在同一列；</li><li>皇后不能成对角线；<h4 id="八皇后摆放步骤"><a href="#八皇后摆放步骤" class="headerlink" title="八皇后摆放步骤"></a>八皇后摆放步骤</h4></li></ul><ol><li>先摆放第一个皇后在第一行第一列；</li><li>接着摆放第二个皇后在第二行第一列，冲突之后继续放到第二列，以此类推；</li><li>摆放第三个皇后同样，先放在第一列，接着第二列直到第八个皇后也放在一个不冲突的位置；</li><li>当得到一个解后，最后一行又会继续试探其他位置，试图找到其他不冲突的位置，全部位置都冲突，则回溯上一行改变上一行皇后的位置，再接着找下一个皇后所有不冲突的摆放位置；</li><li>不断回溯，直到得到第一个皇后摆放的第一列位置的全部解，接着第一个皇后移动到第二列，其他皇后继续2~4的操作；</li></ol><p>图例:<br><img src="/images/dataStructure_img/recursion/eightQueen.png" alt="国际象棋棋盘"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author:ajiany</span></span><br><span class="line"><span class="comment">* @date:2020/7/1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> recursion;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightQueensProblem</span> </span>&#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> maxSize = <span class="number">8</span>;<span class="comment">// 定义存放八皇后数组的大小</span></span><br><span class="line">     <span class="comment">// 定义存放八皇后的数组</span></span><br><span class="line">     <span class="comment">// i表示第几个皇后（第几行） queens[i]表示第几列</span></span><br><span class="line">     <span class="comment">// 即下标表示行 值表示列</span></span><br><span class="line">     <span class="comment">//例如[0, 4, 7, 5, 2, 6, 1, 3]</span></span><br><span class="line">     <span class="comment">//数组第一个索引0表示第一行，数值0表示第一列；数组第二个索引表示第二行，数值4表示第五列</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span>[] queens = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> judgeCount=<span class="number">0</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           setQueens(<span class="number">0</span>);</span><br><span class="line">           System.out.printf(<span class="string">"判断次数是%d,可行解次数是%d"</span>,judgeCount,count);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 回溯放置皇后</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(n==maxSize) &#123;</span><br><span class="line">                <span class="comment">//打印解</span></span><br><span class="line">                showSolution();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">                queens[n]=i;<span class="comment">//放置第n个皇后在第n行第i列</span></span><br><span class="line">                <span class="keyword">if</span>(judgePosition(n)) &#123;</span><br><span class="line">                     setQueens(n+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 判断位置是否冲突</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">judgePosition</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">           judgeCount++;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="comment">// 判断放置的第n个皇后是否与前面放置的皇后在同一列或者对角线</span></span><br><span class="line">                <span class="comment">// 假设n=1，即第二个皇后</span></span><br><span class="line">                <span class="keyword">if</span> (Math.abs(n - i) == Math.abs(queens[n] -  queens[i]) || queens[n] == queens[i]) &#123;</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 打印最优解的方法</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showSolution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           count++;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queens.length; i++) &#123;</span><br><span class="line">                System.out.print(queens[i] + <span class="string">" "</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 八皇后问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-中缀表达式实现简易运算器</title>
      <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%BF%90%E7%AE%97%E5%99%A8/"/>
      <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%BF%90%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="中缀表达式实现简易运算器"><a href="#中缀表达式实现简易运算器" class="headerlink" title="中缀表达式实现简易运算器"></a>中缀表达式实现简易运算器</h3><p>给定一个运算式子，为非浮点数的整型运算式子，用自定义栈的形式实现简单运算。<br>缺点：未实现浮点数计算功能，对于不合常理的写法无法运算，目前缺点尚且多，功能未十分完善。</p><a id="more"></a><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author:ajiany</span></span><br><span class="line"><span class="comment"> * @date:2020/6/26</span></span><br><span class="line"><span class="comment"> * @功能：中缀表达式实现简易运算器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorByStack</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ArrayStackByCalculator stackNumber = <span class="keyword">new</span> ArrayStackByCalculator(<span class="number">10</span>);</span><br><span class="line">ArrayStackByCalculator stackSymbol = <span class="keyword">new</span> ArrayStackByCalculator(<span class="number">10</span>);</span><br><span class="line">String calString = <span class="string">"70*2-5*6"</span>;<span class="comment">//18</span></span><br><span class="line">System.out.printf(<span class="string">"The operation result of this formula is %d"</span>,</span><br><span class="line">calculator(calString, stackNumber, stackSymbol));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对字符串中给定的运算式子进行遍历运算,****暂时只支持多位数运算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculator</span><span class="params">(String calString, ArrayStackByCalculator stackNumber,</span></span></span><br><span class="line"><span class="function"><span class="params">ArrayStackByCalculator stackSymbol)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">' '</span>;<span class="comment">// 待加入栈的字符，包括数字</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">// 运算式子索引</span></span><br><span class="line"><span class="keyword">char</span> topSymbol = <span class="string">' '</span>;<span class="comment">// 符号栈栈顶元素</span></span><br><span class="line"><span class="keyword">int</span> num1, num2 = <span class="number">0</span>;<span class="comment">// 弹出的数值栈的栈顶俩个数字</span></span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;<span class="comment">// 弹出栈顶俩个元素运算结果</span></span><br><span class="line">String keepNum=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// 运算结束，符号栈为空，跳出循环</span></span><br><span class="line"><span class="comment">//if (stackSymbol.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">ch = calString.substring(index, index + <span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (stackSymbol.judgeSymbol(ch)) &#123;<span class="comment">// 判断是否是合法运算符</span></span><br><span class="line"><span class="keyword">if</span> (stackSymbol.isEmpty()) &#123;<span class="comment">// 判断字符栈是否为空，是则直接push进去</span></span><br><span class="line">stackSymbol.insertElement(ch);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// 否则先判断符号栈栈顶元素与待push进去元素的优先级</span></span><br><span class="line">topSymbol = (<span class="keyword">char</span>) stackSymbol.stack[stackSymbol.top];</span><br><span class="line"><span class="keyword">if</span> (stackSymbol.judgeInsertSymbolPriority(ch, topSymbol)) &#123;<span class="comment">// true表示待加符号优先级大于符号栈栈顶符号</span></span><br><span class="line">stackSymbol.insertElement(ch);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// false表示待加符号优先级小于或等于符号栈栈顶符号</span></span><br><span class="line">num1 = stackNumber.popElement();<span class="comment">//先出来的</span></span><br><span class="line">num2 = stackNumber.popElement();<span class="comment">//后出来的</span></span><br><span class="line">topSymbol=(<span class="keyword">char</span>) stackSymbol.popElement();</span><br><span class="line">result = stackNumber.operation(num1, num2, topSymbol);</span><br><span class="line">stackNumber.insertElement(result);</span><br><span class="line">stackSymbol.insertElement(ch);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// 是运算数字</span></span><br><span class="line"><span class="comment">//stackNumber.insertElement(ch - 48);</span></span><br><span class="line"><span class="comment">//多位数运算</span></span><br><span class="line">keepNum+=ch;</span><br><span class="line"><span class="keyword">if</span>(index==calString.length()-<span class="number">1</span>) &#123;</span><br><span class="line">stackNumber.insertElement(Integer.parseInt(keepNum));</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(stackNumber.judgeSymbol(calString.substring(index+<span class="number">1</span>, index+<span class="number">2</span>).charAt(<span class="number">0</span>))) &#123;</span><br><span class="line">stackNumber.insertElement(Integer.parseInt(keepNum));</span><br><span class="line">keepNum=<span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index扫描到最后则跳出循环</span></span><br><span class="line">index++;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= calString.length()) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (stackSymbol.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">num1 = stackNumber.popElement();</span><br><span class="line">num2 = stackNumber.popElement();</span><br><span class="line">ch = (<span class="keyword">char</span>) stackSymbol.popElement();</span><br><span class="line">result = stackNumber.operation(num1, num2, ch);</span><br><span class="line">stackNumber.insertElement(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> stackNumber.popElement();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义栈（以数组的形式）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStackByCalculator</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化栈的大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayStackByCalculator</span><span class="params">(<span class="keyword">int</span> prammaxSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.maxSize = prammaxSize;</span><br><span class="line">stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为满</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往栈里插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertElement</span><span class="params">(<span class="keyword">int</span> elem)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">System.out.println(<span class="string">"Stack is full of elements"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">top++;</span><br><span class="line">stack[top] = elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往栈外弹出元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">popElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stack is empty"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> value = stack[top];</span><br><span class="line">top--;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为合法的运算符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSymbol</span><span class="params">(<span class="keyword">int</span> symbol)</span> </span>&#123;</span><br><span class="line"><span class="comment">//if(symbol == '*' || symbol == '/' || symbol == '+' || symbol == '-') &#123;</span></span><br><span class="line"><span class="comment">//return true;</span></span><br><span class="line"><span class="comment">//&#125;else &#123;</span></span><br><span class="line"><span class="comment">//throw new RuntimeException("The calculator don't support this symbol");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> symbol == <span class="string">'*'</span> || symbol == <span class="string">'/'</span> || symbol == <span class="string">'+'</span> || symbol == <span class="string">'-'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义加减乘除的符号优先级</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">symbolPriority</span><span class="params">(<span class="keyword">char</span> symbol)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (symbol == <span class="string">'*'</span> || symbol == <span class="string">'/'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (symbol == <span class="string">'+'</span> || symbol == <span class="string">'-'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对栈弹出的俩个元素进行运算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, <span class="keyword">char</span> symbol)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (symbol == <span class="string">'*'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> num1 * num2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (symbol == <span class="string">'/'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> num2 / num1;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (symbol == <span class="string">'+'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (symbol == <span class="string">'-'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> num2 - num1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"the calculator don't support this symbol"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断弹出元素与当前元素的优先级，true代表待加元素优先级大于符号栈栈顶元素，false代表待加元素小于或等于符号栈栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeInsertSymbolPriority</span><span class="params">(<span class="keyword">char</span> readyElem, <span class="keyword">char</span> topElem)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (symbolPriority(readyElem) &gt; symbolPriority(topElem)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 中缀表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-栈</title>
      <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
      <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h3 id="栈的介绍"><a href="#栈的介绍" class="headerlink" title="栈的介绍"></a>栈的介绍</h3><p>栈（stack）又名堆栈，限定仅在栈顶进行插入和删除操作的线性表。向一个栈插入新元素为入栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈，它是把栈顶元素删除掉，则原先栈顶位置的第二个元素成为新的栈顶元素。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><ol><li>初始化栈</li><li>判断栈是否为空</li><li>判断栈是否为满</li><li>往栈插入元素</li><li>从栈弹出元素</li><li>遍历栈的元素输出</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义栈（以数组的形式）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span>[] stack;</span><br><span class="line">     <span class="comment">// 初始化栈的大小</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> prammaxSize)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.maxSize = prammaxSize;</span><br><span class="line">           stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 判断栈是否为空</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 判断栈是否为满</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 往栈里插入元素</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertElement</span><span class="params">(<span class="keyword">int</span> elem)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Stack is full of elements"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           top++;</span><br><span class="line">           stack[top] = elem;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 往栈外弹出元素</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">popElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stack is empty"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> value = stack[top];</span><br><span class="line">           top--;</span><br><span class="line">           <span class="keyword">return</span> value;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 循环遍历栈内的元素</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showStackElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Stack is empty"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stack.length; i++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"the elements of the current  position stack are [%d] ,element is %d\n"</span>,i, stack[i]);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-中缀表达式转后缀表达式</title>
      <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="中缀表达式介绍"><a href="#中缀表达式介绍" class="headerlink" title="中缀表达式介绍"></a>中缀表达式介绍</h3><p>中缀表达式是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于操作数的中间（例：3 + 4）<br>故前缀表达式（例：+ 3 4）;后缀表达式（例：3 4 +）</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>中缀表达式转后缀表达式</p><ol><li>定义俩个栈，一个符号栈S1，另一个中间结果栈S2；</li><li>如果索引的结果是数字，则压入S2；</li><li>如果索引的结果是符号，进行如下判断；<ul><li>如果S1栈为空，则直接入栈；</li><li>如果S1栈为非空，且待压入符号为“（ ”，则直接入栈；</li><li>如果S1栈为非空，且待压入符号比栈顶元素优先级高，则直接入栈，若待压符号入S1栈；</li><li>如果S1栈为非空，且待压入符号小于或等于栈顶元素的优先级，则弹出S1栈顶元素，并压入栈S2；</li><li>如果S1栈为非空，且待压入符号为“ ）”，则弹出栈S1的元素，知道索引到“（ ”停止；</li></ul></li><li>最后运算式子索引完毕，弹出S1栈的所有符号元素，将其压入S2栈；</li><li>将S2栈的元素按栈底到栈顶倒序输出，即为所求的中缀表达式转后的后缀表达式。</li></ol><p>测试公式： 1+（（2+3）*4）-5<br>图解：</p><p><img src="/images/dataStructure_img/infixExpression/infix.png" alt="中缀表达式转后缀表达式"> </p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author：ajiany</span></span><br><span class="line"><span class="comment"> * @date：2020/6/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//后缀表达式的运算</span></span><br><span class="line"><span class="keyword">package</span> stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNatation</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String calString=<span class="string">"1 + ( ( 2 + 3 ) * 40 ) - 5"</span>;<span class="comment">//定义运算式子</span></span><br><span class="line">List&lt;String&gt; s=turnInfixToSuffixExpression(turnStringToArrayList(calString));<span class="comment">//得到后缀表达式</span></span><br><span class="line"><span class="keyword">int</span> result=calculateResult(s);<span class="comment">//利用后缀表达式计算结果</span></span><br><span class="line">System.out.println(<span class="string">"The end of result is : "</span>+result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将中缀表达式转后缀表达式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">turnInfixToSuffixExpression</span><span class="params">(List&lt;String&gt; calList)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 定义俩个栈，一个符号栈S1，另一个中间结果栈S2；</span></span><br><span class="line"><span class="comment">//2. 如果索引的结果是数字，则压入S2；</span></span><br><span class="line"><span class="comment">//3. 如果索引的结果是符号，进行如下判断，</span></span><br><span class="line"><span class="comment">//1）如果S1栈为空，则直接入栈；</span></span><br><span class="line">        <span class="comment">//2）如果S1栈为非空，且待压入符号为“（ ”，则直接入栈；</span></span><br><span class="line">        <span class="comment">//3）如果S1栈为非空，且待压入符号比栈顶元素优先级高，则直接入栈，若待压符号入S1栈；</span></span><br><span class="line">        <span class="comment">//4）如果S1栈为非空，且待压入符号小于或等于栈顶元素的优先级，则弹出S1栈顶元素，并压入栈S2；</span></span><br><span class="line">        <span class="comment">//5）如果S1栈为非空，且待压入符号为“ ）”，则弹出栈S1的元素，知道索引到“（ ”停止；</span></span><br><span class="line">    <span class="comment">//4.最后运算式子索引完毕，弹出S1栈的所有符号元素，将其压入S2栈；</span></span><br><span class="line">    <span class="comment">//5.将S2栈的元素按栈底到栈顶倒序输出，即为所求的中缀表达式转后的后缀表达式。</span></span><br><span class="line">Stack&lt;String&gt; s1=<span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">List&lt;String&gt; s2=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">String topSymbol;</span><br><span class="line"><span class="keyword">for</span>(String item:calList) &#123;</span><br><span class="line"><span class="keyword">if</span>(item.matches(<span class="string">"\\d+"</span>)) &#123;<span class="comment">//数字则入s2栈</span></span><br><span class="line">s2.add(item);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(s1.size()==<span class="number">0</span>) &#123;<span class="comment">//符号栈为空</span></span><br><span class="line">s1.push(item);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;<span class="comment">//符号栈为非空</span></span><br><span class="line">topSymbol=s1.peek();<span class="comment">//弹出栈顶元素</span></span><br><span class="line"><span class="keyword">if</span>(item.equals(<span class="string">"("</span>)) &#123;<span class="comment">//左小括号直接入栈</span></span><br><span class="line">s1.push(item);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">")"</span>)) &#123;<span class="comment">//右小括号</span></span><br><span class="line"><span class="keyword">while</span>(!s1.peek().equals(<span class="string">"("</span>)) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line">s1.pop();<span class="comment">//弹出左小括号</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(symbolPriority(item)&gt;symbolPriority(topSymbol)) &#123;</span><br><span class="line">s1.push(item);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(symbolPriority(item)&lt;=symbolPriority(topSymbol)) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">s1.push(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!(s1.size()==<span class="number">0</span>)) &#123;<span class="comment">//最后将s1中元素push到s2中</span></span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断符号的优先级</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">symbolPriority</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(symbol.equals(<span class="string">"*"</span>)||symbol.equals(<span class="string">"/"</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(symbol.equals(<span class="string">"+"</span>)||symbol.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串逐个添加到List容器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">turnStringToArrayList</span><span class="params">(String calString)</span> </span>&#123;</span><br><span class="line">String[] calArray=calString.split(<span class="string">" "</span>);</span><br><span class="line">List&lt;String&gt; calList=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span>(String i:calArray) &#123;</span><br><span class="line">calList.add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> calList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将List容器里的元素取出并运算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateResult</span><span class="params">(List&lt;String&gt; calList)</span> </span>&#123;</span><br><span class="line">Stack&lt;String&gt; stack=<span class="keyword">new</span> Stack&lt;String&gt;();<span class="comment">//定义一个栈存放运算过程的结果</span></span><br><span class="line"><span class="keyword">int</span> num2,num1,result=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//循环遍历list容器的元素</span></span><br><span class="line"><span class="keyword">for</span>(String i : calList) &#123;</span><br><span class="line"><span class="keyword">if</span>(i.matches(<span class="string">"\\d+"</span>)) &#123;<span class="comment">//匹配的是数字则直接入栈</span></span><br><span class="line">stack.push(i);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;<span class="comment">//如果是运算符则弹出栈顶俩个元素运算,结果再入栈</span></span><br><span class="line">num2=Integer.parseInt(stack.pop());</span><br><span class="line">num1=Integer.parseInt(stack.pop());</span><br><span class="line"><span class="keyword">if</span>(i.equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">result=num1*num2;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i.equals(<span class="string">"/"</span>)) &#123;</span><br><span class="line">result=num1/num2;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i.equals(<span class="string">"+"</span>)) &#123;</span><br><span class="line">result=num1+num2;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">result=num1-num2;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"runtime error"</span>);</span><br><span class="line">&#125;</span><br><span class="line">stack.push(<span class="string">""</span>+result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Integer.parseInt(stack.pop());<span class="comment">//最后将栈的最后一个元素弹出，即最终运算结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 中缀表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-单向环形链表-JosePhu问题</title>
      <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E5%90%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-JosePhu%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E5%90%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-JosePhu%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="约瑟夫问题介绍"><a href="#约瑟夫问题介绍" class="headerlink" title="约瑟夫问题介绍"></a>约瑟夫问题介绍</h3><p>问题提出：设编号为1，2，3……. n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出列编号的序列。</p><a id="more"></a><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Josephu问题</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> ajian</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2020/6/21</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> linkedlist;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JosephuProblem</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           CreateBoyNodeSingleList circleList=<span class="keyword">new</span>  CreateBoyNodeSingleList();</span><br><span class="line">           circleList.addBoyNode(<span class="number">5</span>);</span><br><span class="line">           circleList.showBoyNode();</span><br><span class="line">           </span><br><span class="line">           circleList.printKSpecifiedNode(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateBoyNodeSingleList</span></span>&#123;</span><br><span class="line">     <span class="comment">//创建头节点</span></span><br><span class="line">     Boy first=<span class="keyword">new</span> Boy(-<span class="number">1</span>);</span><br><span class="line">     <span class="comment">//创建跟随节点</span></span><br><span class="line">     Boy cur=<span class="keyword">new</span> Boy(-<span class="number">1</span>);</span><br><span class="line">     <span class="comment">//实际的链表</span></span><br><span class="line">     Boy helper=<span class="keyword">new</span> Boy(-<span class="number">1</span>);</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> nums 节点个数</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">addBoyNode</span><span class="params">(<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line">                Boy boy=<span class="keyword">new</span> Boy(i);</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">1</span>) &#123;<span class="comment">//第一个节点为封闭环</span></span><br><span class="line">                     first.next=boy;</span><br><span class="line">                     first=first.next;<span class="comment">//此时first为第一个节点</span></span><br><span class="line">                     cur=first;<span class="comment">//此时cur为第一个节点</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                     cur.next=boy;<span class="comment">//将当前节点指向新节点</span></span><br><span class="line">                     boy.next=first;<span class="comment">//移动后的节点指向first节点</span></span><br><span class="line">                     cur=boy;<span class="comment">//将节点后移</span></span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//回到第一个节点</span></span><br><span class="line">           cur=cur.next;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     <span class="comment">//指定第k个人开始数第k次出列</span></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> startNo 从哪个人开始报数</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> k     报数第k次</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> nums 人数</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">printKSpecifiedNode</span><span class="params">(<span class="keyword">int</span> startNo,<span class="keyword">int</span> k,<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(startNo&gt;nums||k&gt;nums||startNo&lt;<span class="number">0</span>||startNo&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"error "</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//使first循环到startNo的位置</span></span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(startNo==cur.no) &#123;</span><br><span class="line">                     first=cur;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur=cur.next;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//循环使helper指针指向first前一个位置</span></span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.next==first) &#123;</span><br><span class="line">                     helper=cur;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur=cur.next;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           </span><br><span class="line">           </span><br><span class="line">           <span class="comment">//执行循环弹出第k个boyNode</span></span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(first.next==helper.next) &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = startNo; i &lt;= k; i++) &#123;</span><br><span class="line">                     <span class="keyword">if</span>(i==k) &#123;</span><br><span class="line">                           System.out.println(first);</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     first=first.next;<span class="comment">//first移动到下一节点</span></span><br><span class="line">                     helper=helper.next;<span class="comment">//helper移动到下一节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                first=first.next;<span class="comment">//将first指向下一节点</span></span><br><span class="line">                helper.next=first;<span class="comment">//将helper指向新的first</span></span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(first);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">void</span>  <span class="title">showBoyNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(cur);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//最后一个节点跳出循环</span></span><br><span class="line">                <span class="keyword">if</span>(cur.next==first) &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur=cur.next;</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> no;</span><br><span class="line">     Boy next;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.no=no;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> no;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.no = no;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> Boy <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> next;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Boy next)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"Boy [no="</span> + no + <span class="string">"]"</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 约瑟夫问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-双向链表</title>
      <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="双向链表介绍"><a href="#双向链表介绍" class="headerlink" title="双向链表介绍"></a>双向链表介绍</h3><p>双向链表的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。故从双向链表中的任意一个结点开始，都可以访问它的前驱结点和后继结点。一般我们都构造双向循环链表。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>实现双向链表节点的增删改查，同时增加节点以正向顺序增加</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> linkedlist;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//初始化节点</span></span><br><span class="line">           DoubleLinkedListNode node1=<span class="keyword">new</span>  DoubleLinkedListNode(<span class="number">8</span>, <span class="string">"DiDi"</span>);</span><br><span class="line">           DoubleLinkedListNode node2=<span class="keyword">new</span>  DoubleLinkedListNode(<span class="number">1</span>, <span class="string">"HuaWei"</span>);</span><br><span class="line">           DoubleLinkedListNode node3=<span class="keyword">new</span>  DoubleLinkedListNode(<span class="number">2</span>, <span class="string">"Alibaba"</span>);</span><br><span class="line">           DoubleLinkedListNode node4=<span class="keyword">new</span>  DoubleLinkedListNode(<span class="number">3</span>, <span class="string">"Tengxun"</span>);</span><br><span class="line">           <span class="comment">//初始化双向链表</span></span><br><span class="line">           createDoubleLinkedList dlist=<span class="keyword">new</span>  createDoubleLinkedList();</span><br><span class="line">           dlist.addNodeByOrder(node1);</span><br><span class="line">           dlist.addNodeByOrder(node3);</span><br><span class="line">           dlist.addNodeByOrder(node2);</span><br><span class="line">           dlist.addNodeByOrder(node4);</span><br><span class="line">           <span class="comment">//显示双向链表</span></span><br><span class="line">           System.out.println(<span class="string">"definition the  doublelinkedlist:"</span>);</span><br><span class="line">           dlist.showDoubleLinkedList();</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//添加新节点</span></span><br><span class="line">           System.out.println(<span class="string">"add new node:"</span>);</span><br><span class="line">           DoubleLinkedListNode node5=<span class="keyword">new</span>  DoubleLinkedListNode(<span class="number">4</span>, <span class="string">"ByteDance"</span>);</span><br><span class="line">           dlist.addNodeByOrder(node5);</span><br><span class="line">           <span class="comment">//再次显示添加后的节点</span></span><br><span class="line">           dlist.showDoubleLinkedList();</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//删除节点</span></span><br><span class="line">           System.out.println(<span class="string">"delete the specified node:"</span>);</span><br><span class="line">           dlist.deleteNode(<span class="number">8</span>);</span><br><span class="line">           <span class="comment">//显示删除后的链表</span></span><br><span class="line">           dlist.showDoubleLinkedList();</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//修改节点内容name</span></span><br><span class="line">           System.out.println(<span class="string">"update specified node's name:"</span>);</span><br><span class="line">           node5=<span class="keyword">new</span> DoubleLinkedListNode(<span class="number">4</span>, <span class="string">"Pingduoduo"</span>);</span><br><span class="line">           dlist.updataNode(node5);</span><br><span class="line">           <span class="comment">//显示修改节点后的链表</span></span><br><span class="line">           dlist.showDoubleLinkedList();</span><br><span class="line">     </span><br><span class="line">           <span class="comment">//查找双向链表的指定节点</span></span><br><span class="line">           System.out.println(<span class="string">"search the specified node:"</span>);</span><br><span class="line">           dlist.searchNode(<span class="number">4</span>);</span><br><span class="line"><span class="comment">/*   */</span></span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义创建双向链表的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">createDoubleLinkedList</span></span>&#123;</span><br><span class="line">     <span class="comment">//定义头节点</span></span><br><span class="line">     DoubleLinkedListNode head=<span class="keyword">new</span> DoubleLinkedListNode(<span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//添加节点的方法</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">addNodeByOrder</span><span class="params">(DoubleLinkedListNode newNode)</span> </span>&#123;</span><br><span class="line">           DoubleLinkedListNode cur=head;</span><br><span class="line">           <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">boolean</span> flag1=<span class="keyword">false</span>;</span><br><span class="line">           <span class="comment">//1.循环链表</span></span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//1.1. 判断添加的no是否存在，存在返回相应提示信息</span></span><br><span class="line">                <span class="keyword">if</span>(cur.next==<span class="keyword">null</span>) &#123;<span class="comment">//如果链表暂时无节点，则令flag1等于true，在链表末尾增加节点</span></span><br><span class="line">                     flag1=<span class="keyword">true</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.next.no==newNode.no) &#123;<span class="comment">//如果待加节点序号已存在，flag为true，返回提示信息</span></span><br><span class="line">                     flag=<span class="keyword">true</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.next.no&gt;newNode.no) &#123;<span class="comment">//1.2. 找到合适的位置添加节点</span></span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur=cur.next;</span><br><span class="line">                <span class="comment">//cur.next.pre=cur;</span></span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//2.对no在链表存在的情况提示信息</span></span><br><span class="line">           <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"The newNode's no %d is  exits\n"</span>,newNode.no);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag1)&#123;</span><br><span class="line">                newNode.next=cur.next;<span class="comment">//将新节点指向下一节点</span></span><br><span class="line">                newNode.pre=cur;<span class="comment">//将新节点的前驱指针指向当前节点</span></span><br><span class="line">                cur.next=newNode;<span class="comment">//将当前节点的指向的下一节点为新节点</span></span><br><span class="line">                </span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                newNode.next=cur.next;</span><br><span class="line">                cur.next.pre=newNode;<span class="comment">//将下一个节点的前驱指针指向新节点</span></span><br><span class="line">                newNode.pre=cur;<span class="comment">//将新节点的前驱指针指向当前节点</span></span><br><span class="line">                cur.next=newNode;</span><br><span class="line">           &#125;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//删除节点的方法</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//1.判断双向链表是否存在</span></span><br><span class="line">           DoubleLinkedListNode cur=head;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(cur==<span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">//System.out.println("DoubleLinkedList is  empty!");</span></span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(no&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                     System.out.println(<span class="string">"no is error!"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.no==no) &#123;<span class="comment">//2.遍历找到节点并删除</span></span><br><span class="line">                     cur.pre.next=cur.next;</span><br><span class="line">                     <span class="keyword">if</span>(cur.next!=<span class="keyword">null</span>) &#123;<span class="comment">//如果删除的是末尾，则下面代码不指定</span></span><br><span class="line">                           cur.next.pre=cur.pre;</span><br><span class="line">                     &#125;</span><br><span class="line">                     </span><br><span class="line">                &#125;</span><br><span class="line">                cur=cur.next;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//修改节点的方法</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">updataNode</span><span class="params">(DoubleLinkedListNode newNode)</span> </span>&#123;</span><br><span class="line">           DoubleLinkedListNode cur=head;</span><br><span class="line">           <span class="keyword">if</span>(cur.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"DoubleLinkedList is  empty!"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">while</span>(cur!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(newNode.no==cur.no) &#123;</span><br><span class="line">                     cur.name=newNode.name;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur=cur.next;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//查找指定节点的方法</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">searchNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           DoubleLinkedListNode cur=head;</span><br><span class="line">           <span class="keyword">if</span>(cur.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"DoubleLinkedList is  empty!"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span>(cur!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.no==no) &#123;</span><br><span class="line">                     System.out.println(cur);</span><br><span class="line">                &#125;</span><br><span class="line">                cur=cur.next;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//显示双向链表的内容</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">showDoubleLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           DoubleLinkedListNode cur=head.next;</span><br><span class="line">           <span class="comment">//1.判断头节点后的节点是否存在，不存在则表示链表为空</span></span><br><span class="line">                <span class="keyword">if</span>(cur.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">                     System.out.println(<span class="string">"DoubleLinkedList is  Empty!"</span>);</span><br><span class="line">                     <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">           <span class="comment">//2.双向链表不为空     </span></span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                     <span class="keyword">if</span>(cur==<span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     System.out.println(cur);</span><br><span class="line">                     cur=cur.next;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"><span class="comment">//定义双向链表的节点的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedListNode</span></span>&#123;</span><br><span class="line">     <span class="comment">//标号no</span></span><br><span class="line">     <span class="keyword">int</span> no;</span><br><span class="line">     <span class="comment">//数据name</span></span><br><span class="line">     String name;</span><br><span class="line">     <span class="comment">//前驱指针Precursor pointer</span></span><br><span class="line">     DoubleLinkedListNode pre;</span><br><span class="line">     <span class="comment">//后驱指针next</span></span><br><span class="line">     DoubleLinkedListNode next;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//DoubleLinkedList的构造方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span>  <span class="title">DoubleLinkedListNode</span><span class="params">(<span class="keyword">int</span> no,String name)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.no=no;</span><br><span class="line">           <span class="keyword">this</span>.name=name;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//重写toString方法</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"DoubleLinkedListNode [no="</span> + no + <span class="string">", name="</span> +  name + <span class="string">"]"</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 双向链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-单链表</title>
      <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="单链表介绍"><a href="#单链表介绍" class="headerlink" title="单链表介绍"></a>单链表介绍</h3><p>单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。链表中的数据是以结点来表示的，每个结点的构成：元素+ 指针(指向后继结点的地址)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><p>实现单链表的增删改查</p><h4 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h4><ol><li>求单链表中有效节点的个数</li><li>查找单链表中的倒数第k个节点</li><li>单链表的反转</li><li>从尾到头打印单链表<ul><li>方法1：先将链表反转，再打印</li><li>方法2：用栈的特性倒序打印链表的节点</li></ul></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* author:ajian</span></span><br><span class="line"><span class="comment">* date:2020/6/19</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> linkedlist;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//create the node</span></span><br><span class="line">     HeroNode node1=<span class="keyword">new</span> HeroNode(<span class="number">2</span>,<span class="string">"ajian"</span>);</span><br><span class="line">     HeroNode node2=<span class="keyword">new</span> HeroNode(<span class="number">3</span>,<span class="string">"minqi"</span>);</span><br><span class="line">     HeroNode node3=<span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">"xxxx"</span>);</span><br><span class="line">     HeroNode node4=<span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">"yyyy"</span>);</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     SingleLinkedListDemo singleLinkedListdemo=<span class="keyword">new</span>  SingleLinkedListDemo();</span><br><span class="line">     singleLinkedListdemo.addNode(node1);</span><br><span class="line">     singleLinkedListdemo.addNode(node2);</span><br><span class="line">     singleLinkedListdemo.addNode(node3);</span><br><span class="line">     singleLinkedListdemo.addNode(node4);</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//reverse the linkedList</span></span><br><span class="line"><span class="comment">//   reverseLinkedList(singleLinkedListdemo.getHead());</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">//倒序打印单链表</span></span><br><span class="line">     System.out.println(<span class="string">"print the linkedList in the reverse  order~"</span>);</span><br><span class="line">     printReverseOrderList(singleLinkedListdemo.getHead());</span><br><span class="line">     singleLinkedListdemo.showLinkedList();</span><br><span class="line">     </span><br><span class="line"><span class="comment">/*   </span></span><br><span class="line"><span class="comment">     SingleLinkedListDemo singleLinkedListdemo=new  SingleLinkedListDemo();</span></span><br><span class="line"><span class="comment">     //按顺序往链表中添加节点</span></span><br><span class="line"><span class="comment">     singleLinkedListdemo.addNodeByOrder(node1);</span></span><br><span class="line"><span class="comment">     singleLinkedListdemo.addNodeByOrder(node2);</span></span><br><span class="line"><span class="comment">     singleLinkedListdemo.addNodeByOrder(node3);</span></span><br><span class="line"><span class="comment">     singleLinkedListdemo.addNodeByOrder(node4);</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     //将链表的节点打印到控制台</span></span><br><span class="line"><span class="comment">     singleLinkedListdemo.showLinkedList();</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     //对链表中指定节点的修改</span></span><br><span class="line"><span class="comment">     System.out.println("the linkedList was updated~");</span></span><br><span class="line"><span class="comment">     HeroNode node5=new HeroNode(1,"wosshiajian");</span></span><br><span class="line"><span class="comment">     singleLinkedListdemo.updateNodeName(node5);</span></span><br><span class="line"><span class="comment">     singleLinkedListdemo.showLinkedList();</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     //删除链表中指定的节点</span></span><br><span class="line"><span class="comment">     System.out.println("the node will be delete~");</span></span><br><span class="line"><span class="comment">     singleLinkedListdemo.deleteNode(1);</span></span><br><span class="line"><span class="comment">     singleLinkedListdemo.showLinkedList();</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     //计算链表的长度</span></span><br><span class="line"><span class="comment">     System.out.println("show the number of nodes~");</span></span><br><span class="line"><span class="comment">     singleLinkedListdemo.showLinkedList();</span></span><br><span class="line"><span class="comment">     System.out.println("the current number of nodes is:  "+countNumberNode(singleLinkedListdemo.getHead())+"\n");</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     //打印链表中倒序第k个节点的内容</span></span><br><span class="line"><span class="comment">     System.out.println("k digit in the reverse order  reciprocal~");</span></span><br><span class="line"><span class="comment">     System.out.println(showReverseNode(singleLinkedListdemo.getHead(),countNumberNode(singleLinkedListdemo.getHead()), 1));</span></span><br><span class="line"><span class="comment">*/</span>   </span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//利用栈来辅助倒序打印单链表的内容</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printReverseOrderList</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">           HeroNode cur=head.next;</span><br><span class="line">           Stack&lt;HeroNode&gt; stack=<span class="keyword">new</span> Stack&lt;HeroNode&gt;();</span><br><span class="line">           <span class="keyword">if</span>(head.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span>(cur!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur=cur.next;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">while</span>(stack.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(stack.pop());</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//反转单链表</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseLinkedList</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(head.next==<span class="keyword">null</span>||head.next.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           HeroNode cur=head.next;</span><br><span class="line">           HeroNode next=<span class="keyword">null</span>;</span><br><span class="line">           HeroNode reverseHead=<span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line">           <span class="keyword">while</span>(cur!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                next=cur.next;</span><br><span class="line">                cur.next=reverseHead.next;<span class="comment">//让当前cur指针指向reverseHead指针指向的后面的链表</span></span><br><span class="line">                reverseHead.next=cur;<span class="comment">//将reverseHead的next指针指向当前cur</span></span><br><span class="line">                cur=next;</span><br><span class="line">           &#125;</span><br><span class="line">           head.next=reverseHead.next;<span class="comment">//最后让原来的head指针指向reverseHead指针指向的后面的链表</span></span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//返回倒序第k个节点的内容</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">showReverseNode</span><span class="params">(HeroNode head,<span class="keyword">int</span>  size,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">           HeroNode cur=head;</span><br><span class="line">           <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">                     flag=<span class="keyword">true</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k&lt;<span class="number">0</span>||k&gt;size) &#123;</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum==size-k) &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum++;</span><br><span class="line">                cur=cur.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//out of the loop</span></span><br><span class="line">           <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                System.out.println(<span class="string">"the linkedlist is null"</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(cur.next);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> cur.next.data;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//计算链表的长度</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countNumberNode</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">           HeroNode cur=head;</span><br><span class="line">           <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum++;</span><br><span class="line">                cur=cur.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> sum;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建单链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span></span>&#123;</span><br><span class="line">     <span class="comment">// 创建头节点</span></span><br><span class="line">     <span class="keyword">private</span> HeroNode head =<span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">""</span>);</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//返回单链表的头节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//向链表中添加节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(HeroNode heronode)</span> </span>&#123;</span><br><span class="line">           HeroNode temp =head;</span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp=temp.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//当循环到链表末尾时添加节点</span></span><br><span class="line">           temp.next=heronode;</span><br><span class="line">           </span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//按照no值以正序的顺序往链表添加节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNodeByOrder</span><span class="params">(HeroNode heronode)</span> </span>&#123;</span><br><span class="line">           HeroNode temp=head;<span class="comment">//定义辅助节点</span></span><br><span class="line">           <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.next.no==heronode.no) &#123;</span><br><span class="line">                     flag=<span class="keyword">true</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp.next.no&gt;heronode.no)&#123;<span class="comment">//当下一个节点的no值大于要添加的节点的no值，则在当前位置添加节点</span></span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp=temp.next;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span>(flag) &#123;<span class="comment">//flag为true则表示要添加的no值已经在链表中存在</span></span><br><span class="line">                System.out.printf(<span class="string">"the insert number %d was in  the linkedlist\n"</span>,heronode.no);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                heronode.next=temp.next;</span><br><span class="line">                temp.next=heronode;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//修改链表中指定节点的信息</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateNodeName</span><span class="params">(HeroNode heronode)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//set up a temporary node</span></span><br><span class="line">           HeroNode temp=head;</span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no==heronode.no) &#123;</span><br><span class="line">                     System.out.printf(<span class="string">"The node %d to be  modified has been modified\n"</span>,heronode.no);</span><br><span class="line">                     temp.next.data=heronode.data;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp=temp.next;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//删除节点</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">           HeroNode temp=head;</span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp.next.no==no) &#123;</span><br><span class="line">                     temp.next=temp.next.next;</span><br><span class="line">                     System.out.printf(<span class="string">"the node %d haved  deleted\n"</span>,no);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp=temp.next;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//将链表中的每一个节点按顺序显示</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(head==<span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"the linkedlist is empty!"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           HeroNode temp=head.next;</span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp==<span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//print the information of node</span></span><br><span class="line">                System.out.println(temp);</span><br><span class="line">                </span><br><span class="line">                temp=temp.next;</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">"------------------------"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建单链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">     <span class="keyword">public</span> String data;</span><br><span class="line">     <span class="keyword">public</span> HeroNode next;<span class="comment">//point at the next node</span></span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no,String data)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.no=no;</span><br><span class="line">           <span class="keyword">this</span>.data=data;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//重写toString方法</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", data="</span> + data + <span class="string">"]"</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h4><p>功能：合并俩个单链表且合并后有序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*功能：合并俩个单链表且合并后有序</span></span><br><span class="line"><span class="comment">* author:ajian</span></span><br><span class="line"><span class="comment">* data:2020/6/20</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义链表一的节点</span></span><br><span class="line">        Node node1=<span class="keyword">new</span> Node(<span class="number">1</span>, <span class="string">"Alibaba"</span>);</span><br><span class="line">        Node node2=<span class="keyword">new</span> Node(<span class="number">3</span>, <span class="string">"ByteDance"</span>);</span><br><span class="line">        Node node3=<span class="keyword">new</span> Node(<span class="number">2</span>, <span class="string">"Tengxun"</span>);</span><br><span class="line">        Node node4=<span class="keyword">new</span> Node(<span class="number">6</span>,<span class="string">"MeiTuan"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义链表二的节点</span></span><br><span class="line">        Node node5=<span class="keyword">new</span> Node(<span class="number">4</span>, <span class="string">"Baidu"</span>);</span><br><span class="line">        Node node6=<span class="keyword">new</span> Node(<span class="number">5</span>, <span class="string">"PingDuoDuo"</span>);</span><br><span class="line">        Node node7=<span class="keyword">new</span> Node(<span class="number">7</span>, <span class="string">"HuaWei"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生成链表1</span></span><br><span class="line">        singleLinkedList1 singlelinkedlist1=<span class="keyword">new</span> singleLinkedList1();</span><br><span class="line"><span class="comment">//        singlelinkedlist.addNode(node1);</span></span><br><span class="line"><span class="comment">//        singlelinkedlist.addNode(node2);</span></span><br><span class="line"><span class="comment">//        singlelinkedlist.addNode(node3);</span></span><br><span class="line"><span class="comment">//        singlelinkedlist.addNode(node4);</span></span><br><span class="line">        </span><br><span class="line">        singlelinkedlist1.addNodeInOrder(node1);</span><br><span class="line">        singlelinkedlist1.addNodeInOrder(node2);</span><br><span class="line">        singlelinkedlist1.addNodeInOrder(node3);</span><br><span class="line">        singlelinkedlist1.addNodeInOrder(node4);</span><br><span class="line">        System.out.println(<span class="string">"链表1："</span>);</span><br><span class="line">        singlelinkedlist1.showLinkedList();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生成链表2</span></span><br><span class="line">        singleLinkedList1 singlelinkedlist2=<span class="keyword">new</span> singleLinkedList1();</span><br><span class="line">        singlelinkedlist2.addNodeInOrder(node5);</span><br><span class="line">        singlelinkedlist2.addNodeInOrder(node6);</span><br><span class="line">        singlelinkedlist2.addNodeInOrder(node7);</span><br><span class="line">        System.out.println(<span class="string">"链表2："</span>);</span><br><span class="line">        singlelinkedlist2.showLinkedList();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将链表2合并到链表1且排序</span></span><br><span class="line">        MergeLinkedList(singlelinkedlist1,singlelinkedlist2);</span><br><span class="line">        System.out.println(<span class="string">"合并链表2到链表1后按no值升序排序的结果："</span>);</span><br><span class="line">        singlelinkedlist1.showLinkedList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//list2为被合并的链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeLinkedList</span><span class="params">(singleLinkedList1 list1,singleLinkedList1 list2)</span> </span>&#123;</span><br><span class="line">        Node head2=list2.getHead();</span><br><span class="line">        Node temp2=head2.next;<span class="comment">//被合并的链表</span></span><br><span class="line">        Node next2=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp2==<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            next2=temp2.next;</span><br><span class="line">            <span class="comment">//把链表2的一个节点添加到链表1</span></span><br><span class="line">            temp2.next=<span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//讲链表2每个节点不断地按顺序添加到链表1</span></span><br><span class="line">            list1.addNodeInOrder(temp2);</span><br><span class="line">            temp2=next2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//生成单链表地方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleLinkedList1</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head =<span class="keyword">new</span> Node(<span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取头节点的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//无顺序添加节点的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Node newNode)</span> </span>&#123;</span><br><span class="line">        Node temp=head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">                temp.next=newNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//有顺序添加节点的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNodeInOrder</span><span class="params">(Node newNode)</span> </span>&#123;</span><br><span class="line">        Node temp=head;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>) &#123;<span class="comment">//判断当前节点是否在链表末尾</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.no==newNode.no) &#123;<span class="comment">//判断下一个节点是否等于待添节点的no</span></span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp.next.no&gt;newNode.no) &#123;<span class="comment">//判断下一个节点的no是否大于待添节点no</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"the newNode %d is exits"</span>,newNode.no);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            newNode.next=temp.next;</span><br><span class="line">            temp.next=newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将链表的节点显示</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node temp=head.next;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"----------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//definition the linkedList's node</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> no,String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no=no;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-环形队列</title>
      <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/"/>
      <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="环形队列介绍"><a href="#环形队列介绍" class="headerlink" title="环形队列介绍"></a>环形队列介绍</h3><p>为充分利用向量空间，克服”假溢出”现象的方法是：将向量空间想象为一个首尾相接的圆环，并称这种向量为循环向量。存储在其中的队列称为环形队列（Circular Queue），也称为循环队列。环形队列是把顺序队列首尾相连，把存储队列元素的表从逻辑上看成一个环，成为环形队列。<br>即环形队列就是将队列存储空间的最后一个位置绕到第一个位置，形成逻辑上的环状空间，供队列循环使用。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>功能：利用数组来实现环形队列,并往队列插入元素，弹出元素的功能。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleQueue</span></span>&#123;</span><br><span class="line">     <span class="comment">//定义对头最大存储长度</span></span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">int</span> maxSize=<span class="number">4</span>;</span><br><span class="line">                <span class="comment">//用数组来模拟队列</span></span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">int</span>[] simpleQueue=<span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">                <span class="comment">//定义队尾指针</span></span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">int</span> rear=<span class="number">0</span>;</span><br><span class="line">                <span class="comment">//定义队头指针</span></span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">int</span> front=<span class="number">0</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//判断队列是否为空</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                     <span class="keyword">return</span> rear==front;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//判断队列是否为满</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                     <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//往队列增加元素</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">                     </span><br><span class="line">                     <span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">                           System.out.println(<span class="string">"queue is full of  element!!!"</span>);</span><br><span class="line">                           <span class="keyword">return</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                           simpleQueue[rear]=num;</span><br><span class="line">                           rear=(rear+<span class="number">1</span>)%maxSize;</span><br><span class="line">                     </span><br><span class="line">                     </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//从队列取出元素</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                     <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">                           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"queue is  Empty"</span>);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">int</span> value=simpleQueue[front];</span><br><span class="line">                     front=(front+<span class="number">1</span>)%maxSize;</span><br><span class="line">                     <span class="keyword">return</span> value;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//查看对头元素</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueuefirstElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                     <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">                           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"queue is  Empty"</span>);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">return</span> simpleQueue[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 求出当前队列有效数据的个数</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                     <span class="keyword">return</span> (rear + maxSize - front) % maxSize;   </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 显示队列的所有数据</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                     <span class="comment">// 遍历</span></span><br><span class="line">                     <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">                           System.out.println(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line">                           <span class="keyword">return</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// 思路：从front开始遍历，遍历多少个元素</span></span><br><span class="line">                     <span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; front + size() ;  i++) &#123;</span><br><span class="line">                           System.out.printf(<span class="string">"simpleQueue[%d]=%d\n"</span>, i % maxSize,  simpleQueue[i % maxSize]);</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 环形队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-稀疏数组</title>
      <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"/>
      <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="稀疏数组的介绍"><a href="#稀疏数组的介绍" class="headerlink" title="稀疏数组的介绍"></a>稀疏数组的介绍</h3><p>在矩阵中，若数值为0的元素数目远远多于非0元素的数目，并且非0元素分布没有规律时，则称该矩阵为稀疏矩阵；反之若非0元素数目占大多数时，则称该矩阵为稠密矩阵。<br>即稀疏数组可以认为是无效数据远大于有效数据，故为了减少空间浪费，对原数组进行压缩形成稀疏数组。</p><a id="more"></a><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>通过一个场景来理解稀疏数组，假设一个棋盘有俩颗棋子，你需要用用代码表示这俩棵棋子在棋盘的位置，且保证使用空间最小。</p><p><img src="/images/dataStructure_img/sparseArray/checkboard.png" alt="棋盘"></p><p>假设有一个棋盘，里面存有少数棋子，用数组表示为：</p><p><img src="/images/dataStructure_img/sparseArray/srcArray.png" alt="数组表示棋盘"></p><p>但是这样存放会造成很多空间浪费，故采用稀疏数组缩减存储空间，上述数组转化成稀疏数组为：</p><p><img src="/images/dataStructure_img/sparseArray/sparseArray.png" alt="稀疏数组表示棋盘"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>先自定义原始数组并输出到txt文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sparseArray;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleArray</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//1.定义一个普通的二维数组，存放棋子</span></span><br><span class="line">                     <span class="keyword">int</span> simpleArray[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">                     simpleArray[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">                     simpleArray[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">                     System.out.println(<span class="string">"原始数组："</span>);</span><br><span class="line">                     <span class="comment">//2.打印原始数组</span></span><br><span class="line">                     <span class="keyword">for</span>(<span class="keyword">int</span>[] row:simpleArray) &#123;</span><br><span class="line">                           <span class="keyword">for</span>(<span class="keyword">int</span> rowData:row) &#123;</span><br><span class="line">                                System.out.printf(<span class="string">"%d\t"</span>,rowData);</span><br><span class="line">                           &#125;</span><br><span class="line">                           System.out.println();</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">//3.指定文件路径</span></span><br><span class="line">                     File sof=<span class="keyword">new</span>  File(<span class="string">"F:\\GoogleDownLoad\\simpleArray_outfile.txt"</span>);</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="comment">//4.将数组写入文件</span></span><br><span class="line">                           FileWriter out=<span class="keyword">new</span> FileWriter(sof);</span><br><span class="line">                           <span class="keyword">for</span>(<span class="keyword">int</span>[] row : simpleArray) &#123;</span><br><span class="line">                                <span class="keyword">for</span>(<span class="keyword">int</span> rowData:row) &#123;</span><br><span class="line">                                     out.write(rowData+<span class="string">"\t"</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                out.write(<span class="string">"\n"</span>);</span><br><span class="line">                           &#125;</span><br><span class="line">                     out.close();</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                     &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着将文件中的数组读入并生成稀疏数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sparseArray;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> sum=<span class="number">0</span>;<span class="comment">//稀疏数组的行数</span></span><br><span class="line">           <span class="keyword">int</span> simpleArray[][]=<span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1.将文件中的数组读出</span></span><br><span class="line">                </span><br><span class="line">                File sif=<span class="keyword">new</span>  File(<span class="string">"F:\\GoogleDownLoad\\simpleArray_outfile.txt"</span>);</span><br><span class="line">                BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span>  FileReader(sif));</span><br><span class="line">                <span class="comment">//获得数组的行数与列数</span></span><br><span class="line">                <span class="keyword">int</span> length= in.readLine().split(<span class="string">"\t"</span>).length;</span><br><span class="line">                <span class="comment">//接收文件读取的数组</span></span><br><span class="line">                simpleArray=<span class="keyword">new</span> <span class="keyword">int</span>[length][length];</span><br><span class="line">                </span><br><span class="line">                String line;<span class="comment">//接收文件读取每一行</span></span><br><span class="line">                <span class="keyword">int</span> row=<span class="number">0</span>;<span class="comment">//行数</span></span><br><span class="line">                <span class="keyword">while</span>((line=in.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                     String[] temp=line.split(<span class="string">"\t"</span>);</span><br><span class="line">                     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">                           <span class="comment">//System.out.printf(temp[i]+"\t");</span></span><br><span class="line">                           simpleArray[row][i]=Integer.parseInt(temp[i]);</span><br><span class="line">                     &#125;</span><br><span class="line">                     row++;</span><br><span class="line">                     <span class="comment">//System.out.println();</span></span><br><span class="line">                &#125;          </span><br><span class="line">                in.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span>[] row:simpleArray) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> rowData:row) &#123;</span><br><span class="line">                     <span class="keyword">if</span>(rowData!=<span class="number">0</span>) &#123;</span><br><span class="line">                           sum++;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//3.定义一个稀疏数组</span></span><br><span class="line">           <span class="keyword">int</span> sparseArray[][]=<span class="keyword">new</span> <span class="keyword">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">           sparseArray[<span class="number">0</span>][<span class="number">0</span>]=simpleArray.length;</span><br><span class="line">           sparseArray[<span class="number">0</span>][<span class="number">1</span>]=simpleArray.length;</span><br><span class="line">           sparseArray[<span class="number">0</span>][<span class="number">2</span>]=sum;</span><br><span class="line">           <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">           <span class="comment">//4.循环将这个二维数组转化为稀疏数组</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; simpleArray.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; simpleArray.length; j++) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (simpleArray[i][j]!=<span class="number">0</span>) &#123;</span><br><span class="line">                           count++;</span><br><span class="line">                           sparseArray[count][<span class="number">0</span>]=i;</span><br><span class="line">                           sparseArray[count][<span class="number">1</span>]=j;</span><br><span class="line">                           sparseArray[count][<span class="number">2</span>]=simpleArray[i][j];</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">"稀疏数组："</span>);</span><br><span class="line">           <span class="comment">//5.打印稀疏数组</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span>[] row :sparseArray) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> rowData:row) &#123;</span><br><span class="line">                     System.out.printf(<span class="string">"%d\t"</span>,rowData);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetCode-no-53</title>
      <link href="/2020/07/27/leetCode-no-53/"/>
      <url>/2020/07/27/leetCode-no-53/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。<br>在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字</p><a id="more"></a><p>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8</p><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最终效率：</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：40.1 MB, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//将缺失数组的每一个元素的数值作为新数组的下标，即nums[i]等于array数组的i，同时nums也是array[i]的数值</span></span><br><span class="line">        <span class="comment">//这样缺失的位置便空出来为0</span></span><br><span class="line">        <span class="comment">//注意：特殊情况0缺失的话，循环结束未return，则结束返回0，说明缺失的是0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            array[nums[i]]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;array.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution s=<span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span>[] nums=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> result=s.missingNumber(nums);</span><br><span class="line">        System.out.println(<span class="string">"The result is: "</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java优化效率版1"><a href="#Java优化效率版1" class="headerlink" title="Java优化效率版1"></a>Java优化效率版1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>]==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=i) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java优化效率版2"><a href="#Java优化效率版2" class="headerlink" title="Java优化效率版2"></a>Java优化效率版2</h4><p>上述俩种写法实际上时间复杂度都为O(n)，当数据过于庞大时，效率不高，用二分查找来找可能效率会较高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] == m) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">最终效率：</span></span><br><span class="line"><span class="string">执行用时：68 ms</span></span><br><span class="line"><span class="string">内存消耗：13.4 MB</span></span><br><span class="line"><span class="string">:type nums: List[int]</span></span><br><span class="line"><span class="string">:rtype: int</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        length=len(nums)+<span class="number">1</span></span><br><span class="line">        array=[<span class="number">0</span>]*length</span><br><span class="line">        print(array)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            array[i]=i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(array)):</span><br><span class="line">            <span class="keyword">if</span> array[i]==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">nums=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">s=Solution()</span><br><span class="line">result=s.missingNumber(nums)</span><br><span class="line">print(<span class="string">"result is :&#123;&#125;"</span>.format(result))</span><br></pre></td></tr></table></figure><h4 id="Python优化版2"><a href="#Python优化版2" class="headerlink" title="Python优化版2"></a>Python优化版2</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            m = (i + j) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] == m: i = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: j = m - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetNode-no-1051</title>
      <link href="/2020/07/27/leetNode-no-1051/"/>
      <url>/2020/07/27/leetNode-no-1051/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。<br>请你返回能让所有学生以 非递减 高度排列的最小必要移动人数。<br>注意，当一组学生被选中时，他们之间可以以任何可能的方式重新排序，而未被选中的学生应该保持不动。</p><a id="more"></a><p>输入：heights = [1,1,4,2,1,3]<br>输出：3<br>解释：<br>当前数组：[1,1,4,2,1,3]<br>目标数组：[1,1,1,2,3,4]<br>在下标 2 处（从 0 开始计数）出现 4 vs 1 ，所以我们必须移动这名学生。<br>在下标 4 处（从 0 开始计数）出现 1 vs 3 ，所以我们必须移动这名学生。<br>在下标 5 处（从 0 开始计数）出现 3 vs 4 ，所以我们必须移动这名学生</p><p>输入：heights = [5,1,2,3,4]<br>输出：5</p><p>输入：heights = [1,2,3,4,5]<br>输出：0</p><p>思路:</p><ol><li>先将heights数组中的每一个数值i作为array数组的索引，出现几次则令array[i]++；</li><li>遍历array数组，当数组元素大于0，表示该元素的索引即为heights的数值，数组元素的数值即为在heights数组中出现的次数；</li><li>接着判断heights数组当前位置的数值是否与array[i]相等，不相等则count++；</li><li>最后得到的count即为题目要求的最小必要移动人数</li></ol><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*执行用时：1 ms, 在所有 Java 提交中击败了82.45%的用户</span></span><br><span class="line"><span class="comment">*内存消耗：37.5 MB, 在所有 Java 提交中击败了10.00%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">heightChecker</span><span class="params">(<span class="keyword">int</span>[] heights)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>];</span><br><span class="line">        <span class="comment">//统计heights数组每个元素出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> height:heights)&#123;</span><br><span class="line">            array[height]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//因为i表示heights中的数值，heights数组中的数值最小为1，故从1开始计数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(array[i]-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//array[i]大于零表示当前索引i为heights数组中存在的值，array[i]表示这个值在heights数组存在的个数</span></span><br><span class="line">                <span class="comment">//接着判断heights数组与当前数组的索引是否相等，不相等则count增加1</span></span><br><span class="line">                <span class="keyword">if</span>(heights[j++]!=i) count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] heights=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        Solution s=<span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(<span class="string">"result is: "</span>+s.heightChecker(heights));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python代码实现-方法一"><a href="#Python代码实现-方法一" class="headerlink" title="Python代码实现,方法一"></a>Python代码实现,方法一</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行用时：20 ms, 在所有 Python 提交中击败了78.96%的用户</span></span><br><span class="line"><span class="string">内存消耗：12.9 MB, 在所有 Python 提交中击败了33.33%的用户</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heightChecker</span><span class="params">(self, heights)</span>:</span></span><br><span class="line">        n=<span class="number">0</span></span><br><span class="line">        temp=heights[:]</span><br><span class="line">        heights.sort(reverse=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(temp)):</span><br><span class="line">            <span class="keyword">if</span> temp[i]!=heights[i]:</span><br><span class="line">                n+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">heights = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]            </span><br><span class="line">x=Solution()</span><br><span class="line">n=x.heightChecker(heights)</span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure><h3 id="Python代码实现-方法二"><a href="#Python代码实现-方法二" class="headerlink" title="Python代码实现,方法二"></a>Python代码实现,方法二</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行用时：8 ms</span></span><br><span class="line"><span class="string">内存消耗：12.6 MB</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heightChecker</span><span class="params">(self,heights)</span>:</span></span><br><span class="line">        <span class="comment">#定义一个长度为101的列表，且每个元素为0</span></span><br><span class="line">        array=[<span class="number">0</span>]*<span class="number">101</span></span><br><span class="line">        <span class="comment">#用列表给heights列表的每一个元素计数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> heights:</span><br><span class="line">            array[i]+=<span class="number">1</span></span><br><span class="line">        count=j=<span class="number">0</span></span><br><span class="line">        <span class="comment">#找到array列表中给heights列表计数的位置，判断其是否和i相等</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(array)):</span><br><span class="line">            <span class="keyword">while</span> array[i]&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> heights[j]!=i:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">                array[i]-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">heights = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]            </span><br><span class="line">x=Solution()</span><br><span class="line">n=x.heightChecker(heights)</span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到我的博客</title>
      <link href="/2020/05/08/hello-world/"/>
      <url>/2020/05/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>这位朋友你好呀，我是阿健！欢迎来到我的博客 <a href="http://www.ajiany.com/" target="_blank" rel="noopener">ajian</a>! 博客记录了我的一些学习笔记和资源分享。 希望我的一些浅薄理解可以帮助到您。 </p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
